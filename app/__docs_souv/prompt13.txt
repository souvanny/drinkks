TablesScreen appelle generateTokenForTable du controller TablesController
qui appelle generateToken du service SfuService
qui appelle generateLiveKitToken du service ApiService
qui ensuite _dio pour faire un POST.

En utilisant ce _dio de ApiService on bÃ©nÃ©ficie du InterceptorsWrapper
qui vÃ©rifie que si on a une erreur 401 on fait un _refreshToken.

Je voudrai le mÃªme principe pour les appels dans UserProfileRemoteDataSourceImpl.
Il faut passer un service AccountService, serive Ã  crÃ©er avec de nouvelles mÃ©thodes Ã  crÃ©er aussi,
et ensuite faire appel Ã  ApiService oÃ¹ il faudra crÃ©er aussi toutes les mÃ©thodes.




FICHIERS POUR ANALYSE
=====================
Dossiers analysÃ©s:
  - flutter_lib/features/account
  - flutter_lib/providers
  - flutter_lib/services
  - flutter_lib/features/tables
Extensions: dart, php, yaml, yml
Date: 2026-02-23 23:20:12

ARBORESCENCE:
-------------
â””â”€â”€ ğŸ“ flutter_lib/
    â”œâ”€â”€ ğŸ“ features/
    â”‚   â”œâ”€â”€ ğŸ“ account/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ data/
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ datasources/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_remote_data_source.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_remote_data_source.g.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_remote_data_source.dart
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_remote_data_source.g.dart
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_model.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_model.freezed.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_model.g.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_model.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_model.freezed.dart
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_model.g.dart
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ repositories/
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ account_repository_impl.dart
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ account_repository_impl.g.dart
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ user_profile_repository.dart
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ user_profile_repository_impl.dart
    â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“„ user_profile_repository_impl.g.dart
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ domain/
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ entities/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_entity.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_entity.freezed.dart
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_entity.dart
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_entity.freezed.dart
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ repositories/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_repository.dart
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_repository.dart
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ usecases/
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ get_accounts_usecase.dart
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ get_accounts_usecase.g.dart
    â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ get_user_profile_usecase.dart
    â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“„ get_user_profile_usecase.g.dart
    â”‚   â”‚   â””â”€â”€ ğŸ“ presentation/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ controllers/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ account_controller.dart
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ account_controller.g.dart
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ user_profile_controller.dart
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ user_profile_controller.g.dart
    â”‚   â”‚       â””â”€â”€ ğŸ“ screens/
    â”‚   â”‚           â””â”€â”€ ğŸ“„ account_screen.dart
    â”‚   â””â”€â”€ ğŸ“ tables/
    â”‚       â”œâ”€â”€ ğŸ“ data/
    â”‚       â”‚   â”œâ”€â”€ ğŸ“ datasources/
    â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_remote_data_source.dart
    â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_remote_data_source.g.dart
    â”‚       â”‚   â”œâ”€â”€ ğŸ“ models/
    â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_model.dart
    â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_model.freezed.dart
    â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_model.g.dart
    â”‚       â”‚   â””â”€â”€ ğŸ“ repositories/
    â”‚       â”‚       â”œâ”€â”€ ğŸ“„ tables_repository_impl.dart
    â”‚       â”‚       â””â”€â”€ ğŸ“„ tables_repository_impl.g.dart
    â”‚       â”œâ”€â”€ ğŸ“ domain/
    â”‚       â”‚   â”œâ”€â”€ ğŸ“ entities/
    â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_entity.dart
    â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_entity.freezed.dart
    â”‚       â”‚   â”œâ”€â”€ ğŸ“ repositories/
    â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_repository.dart
    â”‚       â”‚   â””â”€â”€ ğŸ“ usecases/
    â”‚       â”‚       â”œâ”€â”€ ğŸ“„ get_tabless_usecase.dart
    â”‚       â”‚       â””â”€â”€ ğŸ“„ get_tabless_usecase.g.dart
    â”‚       â””â”€â”€ ğŸ“ presentation/
    â”‚           â”œâ”€â”€ ğŸ“ controllers/
    â”‚           â”‚   â”œâ”€â”€ ğŸ“„ tables_controller.dart
    â”‚           â”‚   â””â”€â”€ ğŸ“„ tables_controller.g.dart
    â”‚           â”œâ”€â”€ ğŸ“ screens/
    â”‚           â”‚   â”œâ”€â”€ ğŸ“„ connect.dart
    â”‚           â”‚   â”œâ”€â”€ ğŸ“„ prejoin.dart
    â”‚           â”‚   â”œâ”€â”€ ğŸ“„ room.dart
    â”‚           â”‚   â””â”€â”€ ğŸ“„ tables_screen.dart
    â”‚           â””â”€â”€ ğŸ“ widgets/
    â”‚               â”œâ”€â”€ ğŸ“„ controls.dart
    â”‚               â”œâ”€â”€ ğŸ“„ no_video.dart
    â”‚               â”œâ”€â”€ ğŸ“„ participant.dart
    â”‚               â”œâ”€â”€ ğŸ“„ participant_info.dart
    â”‚               â”œâ”€â”€ ğŸ“„ participant_stats.dart
    â”‚               â”œâ”€â”€ ğŸ“„ sound_waveform.dart
    â”‚               â””â”€â”€ ğŸ“„ text_field.dart
    â”œâ”€â”€ ğŸ“ providers/
    â”‚   â””â”€â”€ ğŸ“„ auth_provider.dart
    â””â”€â”€ ğŸ“ services/
        â”œâ”€â”€ ğŸ“„ api_service.dart
        â”œâ”€â”€ ğŸ“„ api_service.g.dart
        â”œâ”€â”€ ğŸ“„ auth_service.dart
        â”œâ”€â”€ ğŸ“„ sfu_service.dart
        â””â”€â”€ ğŸ“„ sfu_service.g.dart


CONTENU DES FICHIERS
====================

FICHIER: flutter_lib/features/account/data/datasources/account_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../core/providers/network_providers.dart';
import '../models/account_model.dart';

part 'account_remote_data_source.g.dart';

abstract class AccountRemoteDataSource {
  Future<List<AccountModel>> fetchAccounts();
  Future<AccountModel> fetchAccount(String id);
}

@riverpod
AccountRemoteDataSource accountRemoteDataSource(Ref ref) {
  final dio = ref.watch(dioProvider);
  return AccountRemoteDataSourceImpl(dio);
}

class AccountRemoteDataSourceImpl implements AccountRemoteDataSource {
  final Dio _dio;

  AccountRemoteDataSourceImpl(this._dio);

  @override
  Future<List<AccountModel>> fetchAccounts() async {
    // final response = await _dio.get('/accounts');
    // return (response.data as List).map((e) => AccountModel.fromJson(e)).toList();
    await Future.delayed(const Duration(seconds: 1));
    return [
      const AccountModel(id: '1', name: 'Item 1'),
      const AccountModel(id: '2', name: 'Item 2'),
    ];
  }

  @override
  Future<AccountModel> fetchAccount(String id) async {
    await Future.delayed(const Duration(seconds: 1));
    return AccountModel(id: id, name: 'Item ');
  }
}



FICHIER: flutter_lib/features/account/data/datasources/account_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountRemoteDataSource)
final accountRemoteDataSourceProvider = AccountRemoteDataSourceProvider._();

final class AccountRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          AccountRemoteDataSource,
          AccountRemoteDataSource,
          AccountRemoteDataSource
        >
    with $Provider<AccountRemoteDataSource> {
  AccountRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<AccountRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  AccountRemoteDataSource create(Ref ref) {
    return accountRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountRemoteDataSource>(value),
    );
  }
}

String _$accountRemoteDataSourceHash() =>
    r'53ff15520eb0b74c67501459a5e2e8b065c3b943';



FICHIER: flutter_lib/features/account/data/datasources/user_profile_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../core/providers/network_providers.dart';
import '../../../../providers/auth_provider.dart' hide dioProvider;
import '../models/user_profile_model.dart';

part 'user_profile_remote_data_source.g.dart';

abstract class UserProfileRemoteDataSource {
  Future<UserProfileModel> getProfile();
  Future<String> getAboutMe();
  Future<String> getPhoto();
  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  });
  Future<void> updateAboutMe(String aboutMe);
  Future<void> updatePhoto(String photoPath);
}

@riverpod
UserProfileRemoteDataSource userProfileRemoteDataSource(Ref ref) {
  final dio = ref.watch(dioProvider);
  final authState = ref.watch(authStateNotifierProvider);
  return UserProfileRemoteDataSourceImpl(dio, authState.jwtToken);
}

class UserProfileRemoteDataSourceImpl implements UserProfileRemoteDataSource {
  final Dio _dio;
  final String? _jwtToken;

  UserProfileRemoteDataSourceImpl(this._dio, this._jwtToken) {
    if (_jwtToken != null) {
      _dio.options.headers['Authorization'] = 'Bearer $_jwtToken';
    }
  }

  @override
  Future<UserProfileModel> getProfile() async {
    final response = await _dio.get('/api/account/me');
    return UserProfileModel.fromJson(response.data);
  }

  @override
  Future<String> getAboutMe() async {
    final response = await _dio.get('/api/account/about-me');
    return response.data['about_me'] ?? '';
  }

  @override
  Future<String> getPhoto() async {
    final response = await _dio.get('/api/account/photo');
    return response.data['photo_url'] ?? '';
  }

  @override
  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  }) async {
    final data = <String, dynamic>{};
    if (username != null) data['username'] = username;
    if (gender != null) data['gender'] = gender;
    if (birthdate != null) data['birthdate'] = birthdate.toIso8601String();

    await _dio.put('/api/account/me', data: data);
  }

  @override
  Future<void> updateAboutMe(String aboutMe) async {
    await _dio.put('/api/account/about-me', data: {'about_me': aboutMe});
  }

  @override
  Future<void> updatePhoto(String photoPath) async {
    final formData = FormData.fromMap({
      'photo': await MultipartFile.fromFile(photoPath),
    });
    await _dio.put('/api/account/photo', data: formData);
  }
}


FICHIER: flutter_lib/features/account/data/datasources/user_profile_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(userProfileRemoteDataSource)
final userProfileRemoteDataSourceProvider =
    UserProfileRemoteDataSourceProvider._();

final class UserProfileRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          UserProfileRemoteDataSource,
          UserProfileRemoteDataSource,
          UserProfileRemoteDataSource
        >
    with $Provider<UserProfileRemoteDataSource> {
  UserProfileRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'userProfileRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$userProfileRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<UserProfileRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  UserProfileRemoteDataSource create(Ref ref) {
    return userProfileRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(UserProfileRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<UserProfileRemoteDataSource>(value),
    );
  }
}

String _$userProfileRemoteDataSourceHash() =>
    r'64d4c19c04bba420484565a11a27cc96bad83f1a';



FICHIER: flutter_lib/features/account/data/models/account_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/account_entity.dart';

part 'account_model.freezed.dart';
part 'account_model.g.dart';

@freezed
abstract class AccountModel with _$AccountModel {
  const AccountModel._();

  const factory AccountModel({
    required String id,
    required String name,
  }) = _AccountModel;

  factory AccountModel.fromJson(Map<String, dynamic> json) =>
      _$AccountModelFromJson(json);

  AccountEntity toEntity() => AccountEntity(id: id, name: name);
}



FICHIER: flutter_lib/features/account/data/models/account_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$AccountModel {

 String get id; String get name;
/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AccountModelCopyWith<AccountModel> get copyWith => _$AccountModelCopyWithImpl<AccountModel>(this as AccountModel, _$identity);

  /// Serializes this AccountModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AccountModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $AccountModelCopyWith<$Res>  {
  factory $AccountModelCopyWith(AccountModel value, $Res Function(AccountModel) _then) = _$AccountModelCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$AccountModelCopyWithImpl<$Res>
    implements $AccountModelCopyWith<$Res> {
  _$AccountModelCopyWithImpl(this._self, this._then);

  final AccountModel _self;
  final $Res Function(AccountModel) _then;

/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [AccountModel].
extension AccountModelPatterns on AccountModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _AccountModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _AccountModel value)  $default,){
final _that = this;
switch (_that) {
case _AccountModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _AccountModel value)?  $default,){
final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _AccountModel():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _AccountModel extends AccountModel {
  const _AccountModel({required this.id, required this.name}): super._();
  factory _AccountModel.fromJson(Map<String, dynamic> json) => _$AccountModelFromJson(json);

@override final  String id;
@override final  String name;

/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AccountModelCopyWith<_AccountModel> get copyWith => __$AccountModelCopyWithImpl<_AccountModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AccountModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AccountModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$AccountModelCopyWith<$Res> implements $AccountModelCopyWith<$Res> {
  factory _$AccountModelCopyWith(_AccountModel value, $Res Function(_AccountModel) _then) = __$AccountModelCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$AccountModelCopyWithImpl<$Res>
    implements _$AccountModelCopyWith<$Res> {
  __$AccountModelCopyWithImpl(this._self, this._then);

  final _AccountModel _self;
  final $Res Function(_AccountModel) _then;

/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_AccountModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/data/models/account_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_AccountModel _$AccountModelFromJson(Map<String, dynamic> json) =>
    _AccountModel(id: json['id'] as String, name: json['name'] as String);

Map<String, dynamic> _$AccountModelToJson(_AccountModel instance) =>
    <String, dynamic>{'id': instance.id, 'name': instance.name};



FICHIER: flutter_lib/features/account/data/models/user_profile_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/user_profile_entity.dart';

part 'user_profile_model.freezed.dart';
part 'user_profile_model.g.dart';

@freezed
abstract class UserProfileModel with _$UserProfileModel {
  const UserProfileModel._();

  const factory UserProfileModel({
    required String id,
    String? username,
    int? gender,
    @JsonKey(name: 'birthdate') @DateTimeConverter() DateTime? birthdate,
    @JsonKey(name: 'about_me') String? aboutMe,
    @JsonKey(name: 'photo_url') String? photoUrl,
  }) = _UserProfileModel;

  factory UserProfileModel.fromJson(Map<String, dynamic> json) =>
      _$UserProfileModelFromJson(json);

  UserProfileEntity toEntity() => UserProfileEntity(
    id: id,
    username: username,
    gender: gender,
    birthdate: birthdate,
    aboutMe: aboutMe,
    photoUrl: photoUrl,
  );
}

class DateTimeConverter implements JsonConverter<DateTime?, String?> {
  const DateTimeConverter();

  @override
  DateTime? fromJson(String? json) {
    if (json == null) return null;
    return DateTime.parse(json);
  }

  @override
  String? toJson(DateTime? object) {
    if (object == null) return null;
    return object.toIso8601String();
  }
}


FICHIER: flutter_lib/features/account/data/models/user_profile_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_profile_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserProfileModel {

 String get id; String? get username; int? get gender;@JsonKey(name: 'birthdate')@DateTimeConverter() DateTime? get birthdate;@JsonKey(name: 'about_me') String? get aboutMe;@JsonKey(name: 'photo_url') String? get photoUrl;
/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UserProfileModelCopyWith<UserProfileModel> get copyWith => _$UserProfileModelCopyWithImpl<UserProfileModel>(this as UserProfileModel, _$identity);

  /// Serializes this UserProfileModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UserProfileModel&&(identical(other.id, id) || other.id == id)&&(identical(other.username, username) || other.username == username)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,username,gender,birthdate,aboutMe,photoUrl);

@override
String toString() {
  return 'UserProfileModel(id: $id, username: $username, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl)';
}


}

/// @nodoc
abstract mixin class $UserProfileModelCopyWith<$Res>  {
  factory $UserProfileModelCopyWith(UserProfileModel value, $Res Function(UserProfileModel) _then) = _$UserProfileModelCopyWithImpl;
@useResult
$Res call({
 String id, String? username, int? gender,@JsonKey(name: 'birthdate')@DateTimeConverter() DateTime? birthdate,@JsonKey(name: 'about_me') String? aboutMe,@JsonKey(name: 'photo_url') String? photoUrl
});




}
/// @nodoc
class _$UserProfileModelCopyWithImpl<$Res>
    implements $UserProfileModelCopyWith<$Res> {
  _$UserProfileModelCopyWithImpl(this._self, this._then);

  final UserProfileModel _self;
  final $Res Function(UserProfileModel) _then;

/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? username = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,username: freezed == username ? _self.username : username // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}


/// Adds pattern-matching-related methods to [UserProfileModel].
extension UserProfileModelPatterns on UserProfileModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _UserProfileModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _UserProfileModel value)  $default,){
final _that = this;
switch (_that) {
case _UserProfileModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _UserProfileModel value)?  $default,){
final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String? username,  int? gender, @JsonKey(name: 'birthdate')@DateTimeConverter()  DateTime? birthdate, @JsonKey(name: 'about_me')  String? aboutMe, @JsonKey(name: 'photo_url')  String? photoUrl)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that.id,_that.username,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String? username,  int? gender, @JsonKey(name: 'birthdate')@DateTimeConverter()  DateTime? birthdate, @JsonKey(name: 'about_me')  String? aboutMe, @JsonKey(name: 'photo_url')  String? photoUrl)  $default,) {final _that = this;
switch (_that) {
case _UserProfileModel():
return $default(_that.id,_that.username,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String? username,  int? gender, @JsonKey(name: 'birthdate')@DateTimeConverter()  DateTime? birthdate, @JsonKey(name: 'about_me')  String? aboutMe, @JsonKey(name: 'photo_url')  String? photoUrl)?  $default,) {final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that.id,_that.username,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _UserProfileModel extends UserProfileModel {
  const _UserProfileModel({required this.id, this.username, this.gender, @JsonKey(name: 'birthdate')@DateTimeConverter() this.birthdate, @JsonKey(name: 'about_me') this.aboutMe, @JsonKey(name: 'photo_url') this.photoUrl}): super._();
  factory _UserProfileModel.fromJson(Map<String, dynamic> json) => _$UserProfileModelFromJson(json);

@override final  String id;
@override final  String? username;
@override final  int? gender;
@override@JsonKey(name: 'birthdate')@DateTimeConverter() final  DateTime? birthdate;
@override@JsonKey(name: 'about_me') final  String? aboutMe;
@override@JsonKey(name: 'photo_url') final  String? photoUrl;

/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UserProfileModelCopyWith<_UserProfileModel> get copyWith => __$UserProfileModelCopyWithImpl<_UserProfileModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UserProfileModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UserProfileModel&&(identical(other.id, id) || other.id == id)&&(identical(other.username, username) || other.username == username)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,username,gender,birthdate,aboutMe,photoUrl);

@override
String toString() {
  return 'UserProfileModel(id: $id, username: $username, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl)';
}


}

/// @nodoc
abstract mixin class _$UserProfileModelCopyWith<$Res> implements $UserProfileModelCopyWith<$Res> {
  factory _$UserProfileModelCopyWith(_UserProfileModel value, $Res Function(_UserProfileModel) _then) = __$UserProfileModelCopyWithImpl;
@override @useResult
$Res call({
 String id, String? username, int? gender,@JsonKey(name: 'birthdate')@DateTimeConverter() DateTime? birthdate,@JsonKey(name: 'about_me') String? aboutMe,@JsonKey(name: 'photo_url') String? photoUrl
});




}
/// @nodoc
class __$UserProfileModelCopyWithImpl<$Res>
    implements _$UserProfileModelCopyWith<$Res> {
  __$UserProfileModelCopyWithImpl(this._self, this._then);

  final _UserProfileModel _self;
  final $Res Function(_UserProfileModel) _then;

/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? username = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,}) {
  return _then(_UserProfileModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,username: freezed == username ? _self.username : username // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/data/models/user_profile_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserProfileModel _$UserProfileModelFromJson(Map<String, dynamic> json) =>
    _UserProfileModel(
      id: json['id'] as String,
      username: json['username'] as String?,
      gender: (json['gender'] as num?)?.toInt(),
      birthdate: const DateTimeConverter().fromJson(
        json['birthdate'] as String?,
      ),
      aboutMe: json['about_me'] as String?,
      photoUrl: json['photo_url'] as String?,
    );

Map<String, dynamic> _$UserProfileModelToJson(_UserProfileModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'username': instance.username,
      'gender': instance.gender,
      'birthdate': const DateTimeConverter().toJson(instance.birthdate),
      'about_me': instance.aboutMe,
      'photo_url': instance.photoUrl,
    };



FICHIER: flutter_lib/features/account/data/repositories/account_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/account_entity.dart';
import '../../domain/repositories/account_repository.dart';
import '../datasources/account_remote_data_source.dart';

part 'account_repository_impl.g.dart';

@riverpod
AccountRepository accountRepository(Ref ref) {
  final remoteDataSource = ref.watch(accountRemoteDataSourceProvider);
  return AccountRepositoryImpl(remoteDataSource);
}

class AccountRepositoryImpl implements AccountRepository {
  final AccountRemoteDataSource _remoteDataSource;

  AccountRepositoryImpl(this._remoteDataSource);

  @override
  Future<List<AccountEntity>> getAccounts() async {
    final models = await _remoteDataSource.fetchAccounts();
    return models.map((e) => e.toEntity()).toList();
  }

  @override
  Future<AccountEntity> getAccount(String id) async {
    final model = await _remoteDataSource.fetchAccount(id);
    return model.toEntity();
  }
}



FICHIER: flutter_lib/features/account/data/repositories/account_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountRepository)
final accountRepositoryProvider = AccountRepositoryProvider._();

final class AccountRepositoryProvider
    extends
        $FunctionalProvider<
          AccountRepository,
          AccountRepository,
          AccountRepository
        >
    with $Provider<AccountRepository> {
  AccountRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountRepositoryHash();

  @$internal
  @override
  $ProviderElement<AccountRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  AccountRepository create(Ref ref) {
    return accountRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountRepository>(value),
    );
  }
}

String _$accountRepositoryHash() => r'8e9b066c582c158b7615cf5520bab449a8d821ba';



FICHIER: flutter_lib/features/account/data/repositories/user_profile_repository.dart
--------------------------------------------------------------------------------
import '../../domain/entities/user_profile_entity.dart';

abstract class UserProfileRepository {
  Future<UserProfileEntity> getProfile();
  Future<String?> getAboutMe();
  Future<String?> getPhoto();
  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  });
  Future<void> updateAboutMe(String aboutMe);
  Future<void> updatePhoto(String photoPath);
}


FICHIER: flutter_lib/features/account/data/repositories/user_profile_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/user_profile_entity.dart';
import '../../domain/repositories/user_profile_repository.dart';
import '../datasources/user_profile_remote_data_source.dart';

part 'user_profile_repository_impl.g.dart';

@riverpod
UserProfileRepository userProfileRepository(Ref ref) {
  final remoteDataSource = ref.watch(userProfileRemoteDataSourceProvider);
  return UserProfileRepositoryImpl(remoteDataSource);
}

class UserProfileRepositoryImpl implements UserProfileRepository {
  final UserProfileRemoteDataSource _remoteDataSource;

  UserProfileRepositoryImpl(this._remoteDataSource);

  @override
  Future<UserProfileEntity> getProfile() async {
    final model = await _remoteDataSource.getProfile();
    return model.toEntity();
  }

  @override
  Future<String?> getAboutMe() async {
    return await _remoteDataSource.getAboutMe();
  }

  @override
  Future<String?> getPhoto() async {
    return await _remoteDataSource.getPhoto();
  }

  @override
  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  }) async {
    await _remoteDataSource.updateProfile(
      username: username,
      gender: gender,
      birthdate: birthdate,
    );
  }

  @override
  Future<void> updateAboutMe(String aboutMe) async {
    await _remoteDataSource.updateAboutMe(aboutMe);
  }

  @override
  Future<void> updatePhoto(String photoPath) async {
    await _remoteDataSource.updatePhoto(photoPath);
  }
}


FICHIER: flutter_lib/features/account/data/repositories/user_profile_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(userProfileRepository)
final userProfileRepositoryProvider = UserProfileRepositoryProvider._();

final class UserProfileRepositoryProvider
    extends
        $FunctionalProvider<
          UserProfileRepository,
          UserProfileRepository,
          UserProfileRepository
        >
    with $Provider<UserProfileRepository> {
  UserProfileRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'userProfileRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$userProfileRepositoryHash();

  @$internal
  @override
  $ProviderElement<UserProfileRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  UserProfileRepository create(Ref ref) {
    return userProfileRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(UserProfileRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<UserProfileRepository>(value),
    );
  }
}

String _$userProfileRepositoryHash() =>
    r'faf8aa120f7405814b9f7beec63f479707caf213';



FICHIER: flutter_lib/features/account/domain/entities/account_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'account_entity.freezed.dart';

@freezed
abstract class AccountEntity with _$AccountEntity {
  const factory AccountEntity({
    required String id,
    required String name,
  }) = _AccountEntity;
}



FICHIER: flutter_lib/features/account/domain/entities/account_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$AccountEntity {

 String get id; String get name;
/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AccountEntityCopyWith<AccountEntity> get copyWith => _$AccountEntityCopyWithImpl<AccountEntity>(this as AccountEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AccountEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $AccountEntityCopyWith<$Res>  {
  factory $AccountEntityCopyWith(AccountEntity value, $Res Function(AccountEntity) _then) = _$AccountEntityCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$AccountEntityCopyWithImpl<$Res>
    implements $AccountEntityCopyWith<$Res> {
  _$AccountEntityCopyWithImpl(this._self, this._then);

  final AccountEntity _self;
  final $Res Function(AccountEntity) _then;

/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [AccountEntity].
extension AccountEntityPatterns on AccountEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _AccountEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _AccountEntity value)  $default,){
final _that = this;
switch (_that) {
case _AccountEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _AccountEntity value)?  $default,){
final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _AccountEntity():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc


class _AccountEntity implements AccountEntity {
  const _AccountEntity({required this.id, required this.name});


@override final  String id;
@override final  String name;

/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AccountEntityCopyWith<_AccountEntity> get copyWith => __$AccountEntityCopyWithImpl<_AccountEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AccountEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$AccountEntityCopyWith<$Res> implements $AccountEntityCopyWith<$Res> {
  factory _$AccountEntityCopyWith(_AccountEntity value, $Res Function(_AccountEntity) _then) = __$AccountEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$AccountEntityCopyWithImpl<$Res>
    implements _$AccountEntityCopyWith<$Res> {
  __$AccountEntityCopyWithImpl(this._self, this._then);

  final _AccountEntity _self;
  final $Res Function(_AccountEntity) _then;

/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_AccountEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/domain/entities/user_profile_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_profile_entity.freezed.dart';

@freezed
abstract class UserProfileEntity with _$UserProfileEntity {
  const factory UserProfileEntity({
    required String id,
    required String? username,
    required int? gender, // 1 = masculin, 2 = fÃ©minin
    required DateTime? birthdate,
    required String? aboutMe,
    required String? photoUrl,
  }) = _UserProfileEntity;
}


FICHIER: flutter_lib/features/account/domain/entities/user_profile_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_profile_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$UserProfileEntity {

 String get id; String? get username; int? get gender;// 1 = masculin, 2 = fÃ©minin
 DateTime? get birthdate; String? get aboutMe; String? get photoUrl;
/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UserProfileEntityCopyWith<UserProfileEntity> get copyWith => _$UserProfileEntityCopyWithImpl<UserProfileEntity>(this as UserProfileEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UserProfileEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.username, username) || other.username == username)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl));
}


@override
int get hashCode => Object.hash(runtimeType,id,username,gender,birthdate,aboutMe,photoUrl);

@override
String toString() {
  return 'UserProfileEntity(id: $id, username: $username, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl)';
}


}

/// @nodoc
abstract mixin class $UserProfileEntityCopyWith<$Res>  {
  factory $UserProfileEntityCopyWith(UserProfileEntity value, $Res Function(UserProfileEntity) _then) = _$UserProfileEntityCopyWithImpl;
@useResult
$Res call({
 String id, String? username, int? gender, DateTime? birthdate, String? aboutMe, String? photoUrl
});




}
/// @nodoc
class _$UserProfileEntityCopyWithImpl<$Res>
    implements $UserProfileEntityCopyWith<$Res> {
  _$UserProfileEntityCopyWithImpl(this._self, this._then);

  final UserProfileEntity _self;
  final $Res Function(UserProfileEntity) _then;

/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? username = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,username: freezed == username ? _self.username : username // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}


/// Adds pattern-matching-related methods to [UserProfileEntity].
extension UserProfileEntityPatterns on UserProfileEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _UserProfileEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _UserProfileEntity value)  $default,){
final _that = this;
switch (_that) {
case _UserProfileEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _UserProfileEntity value)?  $default,){
final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String? username,  int? gender,  DateTime? birthdate,  String? aboutMe,  String? photoUrl)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that.id,_that.username,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String? username,  int? gender,  DateTime? birthdate,  String? aboutMe,  String? photoUrl)  $default,) {final _that = this;
switch (_that) {
case _UserProfileEntity():
return $default(_that.id,_that.username,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String? username,  int? gender,  DateTime? birthdate,  String? aboutMe,  String? photoUrl)?  $default,) {final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that.id,_that.username,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl);case _:
  return null;

}
}

}

/// @nodoc


class _UserProfileEntity implements UserProfileEntity {
  const _UserProfileEntity({required this.id, required this.username, required this.gender, required this.birthdate, required this.aboutMe, required this.photoUrl});


@override final  String id;
@override final  String? username;
@override final  int? gender;
// 1 = masculin, 2 = fÃ©minin
@override final  DateTime? birthdate;
@override final  String? aboutMe;
@override final  String? photoUrl;

/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UserProfileEntityCopyWith<_UserProfileEntity> get copyWith => __$UserProfileEntityCopyWithImpl<_UserProfileEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UserProfileEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.username, username) || other.username == username)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl));
}


@override
int get hashCode => Object.hash(runtimeType,id,username,gender,birthdate,aboutMe,photoUrl);

@override
String toString() {
  return 'UserProfileEntity(id: $id, username: $username, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl)';
}


}

/// @nodoc
abstract mixin class _$UserProfileEntityCopyWith<$Res> implements $UserProfileEntityCopyWith<$Res> {
  factory _$UserProfileEntityCopyWith(_UserProfileEntity value, $Res Function(_UserProfileEntity) _then) = __$UserProfileEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String? username, int? gender, DateTime? birthdate, String? aboutMe, String? photoUrl
});




}
/// @nodoc
class __$UserProfileEntityCopyWithImpl<$Res>
    implements _$UserProfileEntityCopyWith<$Res> {
  __$UserProfileEntityCopyWithImpl(this._self, this._then);

  final _UserProfileEntity _self;
  final $Res Function(_UserProfileEntity) _then;

/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? username = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,}) {
  return _then(_UserProfileEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,username: freezed == username ? _self.username : username // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/domain/repositories/account_repository.dart
--------------------------------------------------------------------------------
import '../entities/account_entity.dart';

abstract class AccountRepository {
  Future<List<AccountEntity>> getAccounts();
  Future<AccountEntity> getAccount(String id);
}



FICHIER: flutter_lib/features/account/domain/repositories/user_profile_repository.dart
--------------------------------------------------------------------------------
import '../entities/user_profile_entity.dart';

abstract class UserProfileRepository {
  Future<UserProfileEntity> getProfile();
  Future<String?> getAboutMe();
  Future<String?> getPhoto();
  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  });
  Future<void> updateAboutMe(String aboutMe);
  Future<void> updatePhoto(String photoPath);
}


FICHIER: flutter_lib/features/account/domain/usecases/get_accounts_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/account_entity.dart';
import '../repositories/account_repository.dart';
import '../../data/repositories/account_repository_impl.dart';

part 'get_accounts_usecase.g.dart';

@riverpod
Future<List<AccountEntity>> getAccounts(Ref ref) {
  return ref.watch(accountRepositoryProvider).getAccounts();
}



FICHIER: flutter_lib/features/account/domain/usecases/get_accounts_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_accounts_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getAccounts)
final getAccountsProvider = GetAccountsProvider._();

final class GetAccountsProvider
    extends
        $FunctionalProvider<
          AsyncValue<List<AccountEntity>>,
          List<AccountEntity>,
          FutureOr<List<AccountEntity>>
        >
    with
        $FutureModifier<List<AccountEntity>>,
        $FutureProvider<List<AccountEntity>> {
  GetAccountsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getAccountsProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getAccountsHash();

  @$internal
  @override
  $FutureProviderElement<List<AccountEntity>> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<List<AccountEntity>> create(Ref ref) {
    return getAccounts(ref);
  }
}

String _$getAccountsHash() => r'c6cdda7c5e10644ce00d526909fb606832565b54';



FICHIER: flutter_lib/features/account/domain/usecases/get_user_profile_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/user_profile_entity.dart';
import '../repositories/user_profile_repository.dart';
import '../../data/repositories/user_profile_repository_impl.dart';

part 'get_user_profile_usecase.g.dart';

@riverpod
Future<UserProfileEntity> getUserProfile(Ref ref) {
  return ref.watch(userProfileRepositoryProvider).getProfile();
}


FICHIER: flutter_lib/features/account/domain/usecases/get_user_profile_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_user_profile_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getUserProfile)
final getUserProfileProvider = GetUserProfileProvider._();

final class GetUserProfileProvider
    extends
        $FunctionalProvider<
          AsyncValue<UserProfileEntity>,
          UserProfileEntity,
          FutureOr<UserProfileEntity>
        >
    with
        $FutureModifier<UserProfileEntity>,
        $FutureProvider<UserProfileEntity> {
  GetUserProfileProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getUserProfileProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getUserProfileHash();

  @$internal
  @override
  $FutureProviderElement<UserProfileEntity> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<UserProfileEntity> create(Ref ref) {
    return getUserProfile(ref);
  }
}

String _$getUserProfileHash() => r'7ccad3731031f4a0ef5233cbe58b660b3e7e4a3f';



FICHIER: flutter_lib/features/account/presentation/controllers/account_controller.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/account_entity.dart';
import '../../domain/usecases/get_accounts_usecase.dart';

part 'account_controller.g.dart';

@riverpod
class AccountController extends _$AccountController {
  @override
  FutureOr<List<AccountEntity>> build() {
    return ref.watch(getAccountsProvider.future);
  }

  Future<void> refresh() async {
     state = const AsyncValue.loading();
     state = await AsyncValue.guard(() => ref.refresh(getAccountsProvider.future));
  }
}



FICHIER: flutter_lib/features/account/presentation/controllers/account_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(AccountController)
final accountControllerProvider = AccountControllerProvider._();

final class AccountControllerProvider
    extends $AsyncNotifierProvider<AccountController, List<AccountEntity>> {
  AccountControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountControllerHash();

  @$internal
  @override
  AccountController create() => AccountController();
}

String _$accountControllerHash() => r'3d07a8cbbec8f9136c4aead37215e4922845c2c4';

abstract class _$AccountController extends $AsyncNotifier<List<AccountEntity>> {
  FutureOr<List<AccountEntity>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<List<AccountEntity>>, List<AccountEntity>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<AccountEntity>>, List<AccountEntity>>,
              AsyncValue<List<AccountEntity>>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/account/presentation/controllers/user_profile_controller.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../data/repositories/user_profile_repository_impl.dart';
import '../../domain/entities/user_profile_entity.dart';
import '../../domain/usecases/get_user_profile_usecase.dart';
import '../../domain/repositories/user_profile_repository.dart';

part 'user_profile_controller.g.dart';

@riverpod
class UserProfileController extends _$UserProfileController {
  @override
  FutureOr<UserProfileEntity> build() {
    return ref.watch(getUserProfileProvider.future);
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(
            () => ref.refresh(getUserProfileProvider.future));
  }

  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(userProfileRepositoryProvider);
      await repository.updateProfile(
        username: username,
        gender: gender,
        birthdate: birthdate,
      );
      return ref.refresh(getUserProfileProvider.future);
    });
  }

  Future<void> updateAboutMe(String aboutMe) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(userProfileRepositoryProvider);
      await repository.updateAboutMe(aboutMe);
      return ref.refresh(getUserProfileProvider.future);
    });
  }

  Future<void> updatePhoto(String photoPath) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(userProfileRepositoryProvider);
      await repository.updatePhoto(photoPath);
      return ref.refresh(getUserProfileProvider.future);
    });
  }
}


FICHIER: flutter_lib/features/account/presentation/controllers/user_profile_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(UserProfileController)
final userProfileControllerProvider = UserProfileControllerProvider._();

final class UserProfileControllerProvider
    extends $AsyncNotifierProvider<UserProfileController, UserProfileEntity> {
  UserProfileControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'userProfileControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$userProfileControllerHash();

  @$internal
  @override
  UserProfileController create() => UserProfileController();
}

String _$userProfileControllerHash() =>
    r'23db92ed8db34f1548c48d62ad919da8c762327b';

abstract class _$UserProfileController
    extends $AsyncNotifier<UserProfileEntity> {
  FutureOr<UserProfileEntity> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<UserProfileEntity>, UserProfileEntity>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<UserProfileEntity>, UserProfileEntity>,
              AsyncValue<UserProfileEntity>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/account/presentation/screens/account_screen.dart
--------------------------------------------------------------------------------
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import '../../../../providers/auth_provider.dart';
import '../../domain/entities/user_profile_entity.dart';
import '../controllers/user_profile_controller.dart';

class AccountScreen extends ConsumerStatefulWidget {
  const AccountScreen({super.key});

  @override
  ConsumerState<AccountScreen> createState() => _AccountScreenState();
}

class _AccountScreenState extends ConsumerState<AccountScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _formKey = GlobalKey<FormState>();
  final _aboutMeController = TextEditingController();

  // Champs pour le premier onglet
  final _usernameController = TextEditingController();
  int? _selectedGender;
  DateTime? _selectedDate;

  // Champs pour la photo
  XFile? _selectedImage;
  final ImagePicker _picker = ImagePicker();

  // Variable pour suivre si des changements ont Ã©tÃ© faits
  bool _hasChanges = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _usernameController.dispose();
    _aboutMeController.dispose();
    super.dispose();
  }

  void _loadProfileData(UserProfileEntity profile) {
    _usernameController.text = profile.username ?? '';
    _selectedGender = profile.gender;
    _selectedDate = profile.birthdate;
    _aboutMeController.text = profile.aboutMe ?? '';
  }

  // MÃ©thode pour dÃ©tecter les changements
  void _onFieldChanged() {
    if (!_hasChanges) {
      setState(() {
        _hasChanges = true;
      });
    }
  }

  Future<void> _pickImage(ImageSource source) async {
    final XFile? image = await _picker.pickImage(source: source);
    if (image != null) {
      setState(() {
        _selectedImage = image;
        _hasChanges = true;
      });
      // Upload automatique
      ref
          .read(userProfileControllerProvider.notifier)
          .updatePhoto(image.path);
    }
  }

  void _showImageSourceDialog() {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF1E1E3F),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.photo_library, color: Color(0xFF6366F1)),
              title: const Text('Galerie', style: TextStyle(color: Colors.white)),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.gallery);
              },
            ),
            ListTile(
              leading: const Icon(Icons.photo_camera, color: Color(0xFF6366F1)),
              title: const Text('Appareil photo', style: TextStyle(color: Colors.white)),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.camera);
              },
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Color(0xFF6366F1),
              onPrimary: Colors.white,
              surface: Color(0xFF1E1E3F),
              onSurface: Colors.white,
            ),
          ),
          child: child!,
        );
      },
    );
    if (picked != null) {
      setState(() {
        _selectedDate = picked;
        _hasChanges = true;
      });
    }
  }

  // MÃ©thode pour gÃ©rer le retour avec confirmation
  Future<bool> _onWillPop() async {
    if (!_hasChanges) {
      return true;
    }

    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E3F),
        title: const Text(
          'Modifications non enregistrÃ©es',
          style: TextStyle(color: Colors.white),
        ),
        content: const Text(
          'Vous avez des modifications non enregistrÃ©es. Voulez-vous vraiment quitter ?',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text(
              'Rester',
              style: TextStyle(color: Colors.white70),
            ),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF6366F1),
            ),
            child: const Text('Quitter'),
          ),
        ],
      ),
    );

    return confirm ?? false;
  }

  @override
  Widget build(BuildContext context) {
    final profileState = ref.watch(userProfileControllerProvider);
    final authState = ref.watch(authStateNotifierProvider);

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: const Color(0xFF0F0F23),
        appBar: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          // Bouton retour Ã  gauche
          leading: IconButton(
            icon: const Icon(Icons.arrow_back, color: Colors.white),
            onPressed: () async {
              if (await _onWillPop()) {
                context.go('/venues');
              }
            },
            tooltip: 'Retour aux bars',
          ),
          title: const Text(
            'Mon Compte',
            style: TextStyle(
              color: Colors.white,
              fontSize: 24,
              fontWeight: FontWeight.bold,
            ),
          ),
          centerTitle: true,
          // Plus de bouton settings Ã  droite
          actions: const [], // Vide car plus de bouton settings
          bottom: TabBar(
            controller: _tabController,
            indicatorColor: const Color(0xFF6366F1),
            labelColor: Colors.white,
            unselectedLabelColor: Colors.white60,
            tabs: const [
              Tab(icon: Icon(Icons.person), text: 'Profil'),
              Tab(icon: Icon(Icons.description), text: 'Ã€ propos'),
              Tab(icon: Icon(Icons.photo), text: 'Photo'),
            ],
          ),
        ),
        body: profileState.when(
          data: (profile) {
            _loadProfileData(profile);
            return TabBarView(
              controller: _tabController,
              children: [
                // Onglet 1 : Informations du compte
                _buildProfileTab(profile),

                // Onglet 2 : About Me
                _buildAboutMeTab(profile),

                // Onglet 3 : Photo
                _buildPhotoTab(profile),
              ],
            );
          },
          loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6366F1))),
          error: (err, stack) => Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text(
                  'Erreur: $err',
                  style: const TextStyle(color: Colors.white),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: () => ref.refresh(userProfileControllerProvider.notifier).refresh(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF6366F1),
                  ),
                  child: const Text('RÃ©essayer'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildProfileTab(UserProfileEntity profile) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(20),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Informations personnelles',
              style: TextStyle(
                color: Colors.white,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 20),

            // Email (lecture seule)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                color: const Color(0xFF1E1E3F),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                children: [
                  const Icon(Icons.email, color: Color(0xFF6366F1), size: 20),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Text(
                      profile.id, // L'email est dans l'ID
                      style: const TextStyle(color: Colors.white70),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 16),

            // Username
            TextFormField(
              controller: _usernameController,
              style: const TextStyle(color: Colors.white),
              onChanged: (value) => _onFieldChanged(),
              decoration: InputDecoration(
                labelText: 'Nom d\'utilisateur',
                labelStyle: const TextStyle(color: Colors.white70),
                prefixIcon: const Icon(Icons.person, color: Color(0xFF6366F1)),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor: const Color(0xFF1E1E3F),
              ),
            ),
            const SizedBox(height: 16),

            // Genre
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Genre',
                  style: TextStyle(color: Colors.white70, fontSize: 16),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _buildGenderOption('Masculin', 1),
                    ),
                    const SizedBox(width: 12),
                    Expanded(
                      child: _buildGenderOption('FÃ©minin', 2),
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Date de naissance
            InkWell(
              onTap: () => _selectDate(context),
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                decoration: BoxDecoration(
                  color: const Color(0xFF1E1E3F),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  children: [
                    const Icon(Icons.cake, color: Color(0xFF6366F1)),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        _selectedDate != null
                            ? 'Date de naissance: ${_selectedDate!.day}/${_selectedDate!.month}/${_selectedDate!.year}'
                            : 'SÃ©lectionner votre date de naissance',
                        style: TextStyle(
                          color: _selectedDate != null ? Colors.white : Colors.white60,
                        ),
                      ),
                    ),
                    const Icon(Icons.arrow_drop_down, color: Color(0xFF6366F1)),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),

            // Bouton de sauvegarde
            SizedBox(
              width: double.infinity,
              height: 50,
              child: ElevatedButton(
                onPressed: () {
                  if (_formKey.currentState!.validate()) {
                    ref
                        .read(userProfileControllerProvider.notifier)
                        .updateProfile(
                      username: _usernameController.text.isNotEmpty
                          ? _usernameController.text
                          : null,
                      gender: _selectedGender,
                      birthdate: _selectedDate,
                    ).then((_) {
                      setState(() {
                        _hasChanges = false;
                      });
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Profil mis Ã  jour'),
                          backgroundColor: Color(0xFF6366F1),
                        ),
                      );
                    });
                  }
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF6366F1),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: const Text(
                  'Enregistrer les modifications',
                  style: TextStyle(fontSize: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGenderOption(String label, int value) {
    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedGender = value;
          _hasChanges = true;
        });
      },
      child: Container(
        padding: const EdgeInsets.symmetric(vertical: 12),
        decoration: BoxDecoration(
          color: _selectedGender == value
              ? const Color(0xFF6366F1)
              : const Color(0xFF1E1E3F),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: _selectedGender == value
                ? const Color(0xFF6366F1)
                : Colors.transparent,
          ),
        ),
        child: Center(
          child: Text(
            label,
            style: const TextStyle(color: Colors.white),
          ),
        ),
      ),
    );
  }

  Widget _buildAboutMeTab(UserProfileEntity profile) {
    return Padding(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Ã€ propos de moi',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 20),
          Expanded(
            child: TextField(
              controller: _aboutMeController,
              maxLines: null,
              expands: true,
              style: const TextStyle(color: Colors.white),
              onChanged: (value) => _onFieldChanged(),
              decoration: InputDecoration(
                hintText: 'Parle-nous un peu de toi...',
                hintStyle: const TextStyle(color: Colors.white38),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                filled: true,
                fillColor: const Color(0xFF1E1E3F),
              ),
            ),
          ),
          const SizedBox(height: 20),
          SizedBox(
            width: double.infinity,
            height: 50,
            child: ElevatedButton(
              onPressed: () {
                ref
                    .read(userProfileControllerProvider.notifier)
                    .updateAboutMe(_aboutMeController.text)
                    .then((_) {
                  setState(() {
                    _hasChanges = false;
                  });
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Ã€ propos mis Ã  jour'),
                      backgroundColor: Color(0xFF6366F1),
                    ),
                  );
                });
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: const Color(0xFF6366F1),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text(
                'Enregistrer',
                style: TextStyle(fontSize: 16),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPhotoTab(UserProfileEntity profile) {
    return Padding(
      padding: const EdgeInsets.all(20),
      child: Column(
        children: [
          const SizedBox(height: 20),
          Container(
            width: 200,
            height: 200,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(color: const Color(0xFF6366F1), width: 3),
              image: _selectedImage != null
                  ? DecorationImage(
                image: FileImage(File(_selectedImage!.path)),
                fit: BoxFit.cover,
              )
                  : (profile.photoUrl != null
                  ? DecorationImage(
                image: NetworkImage(profile.photoUrl!),
                fit: BoxFit.cover,
              )
                  : null),
            ),
            child: _selectedImage == null && profile.photoUrl == null
                ? const Center(
              child: Icon(
                Icons.person,
                size: 80,
                color: Color(0xFF6366F1),
              ),
            )
                : null,
          ),
          const SizedBox(height: 30),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildPhotoButton(
                icon: Icons.photo_library,
                label: 'Galerie',
                onTap: () => _pickImage(ImageSource.gallery),
              ),
              _buildPhotoButton(
                icon: Icons.photo_camera,
                label: 'Appareil photo',
                onTap: () => _pickImage(ImageSource.camera),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildPhotoButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              color: const Color(0xFF1E1E3F),
              shape: BoxShape.circle,
            ),
            child: Icon(icon, color: const Color(0xFF6366F1), size: 30),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: const TextStyle(color: Colors.white70),
          ),
        ],
      ),
    );
  }
}


FICHIER: flutter_lib/features/tables/data/datasources/tables_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../core/providers/network_providers.dart';
import '../models/tables_model.dart';

part 'tables_remote_data_source.g.dart';

abstract class TablesRemoteDataSource {
  Future<List<TablesModel>> fetchTabless();
  Future<TablesModel> fetchTables(String id);
}

@riverpod
TablesRemoteDataSource tablesRemoteDataSource(Ref ref) {
  final dio = ref.watch(dioProvider);
  return TablesRemoteDataSourceImpl(dio);
}

class TablesRemoteDataSourceImpl implements TablesRemoteDataSource {
  final Dio _dio;

  TablesRemoteDataSourceImpl(this._dio);

  @override
  Future<List<TablesModel>> fetchTabless() async {
    // final response = await _dio.get('/tabless');
    // return (response.data as List).map((e) => TablesModel.fromJson(e)).toList();
    await Future.delayed(const Duration(seconds: 1));
    return [
      const TablesModel(id: '1', name: 'Item 1'),
      const TablesModel(id: '2', name: 'Item 2'),
    ];
  }

  @override
  Future<TablesModel> fetchTables(String id) async {
    await Future.delayed(const Duration(seconds: 1));
    return TablesModel(id: id, name: 'Item ');
  }
}



FICHIER: flutter_lib/features/tables/data/datasources/tables_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(tablesRemoteDataSource)
final tablesRemoteDataSourceProvider = TablesRemoteDataSourceProvider._();

final class TablesRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          TablesRemoteDataSource,
          TablesRemoteDataSource,
          TablesRemoteDataSource
        >
    with $Provider<TablesRemoteDataSource> {
  TablesRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tablesRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tablesRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<TablesRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  TablesRemoteDataSource create(Ref ref) {
    return tablesRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TablesRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TablesRemoteDataSource>(value),
    );
  }
}

String _$tablesRemoteDataSourceHash() =>
    r'faaf82b4441e0fce90ae1381dc58e5f62907abaf';



FICHIER: flutter_lib/features/tables/data/models/tables_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/tables_entity.dart';

part 'tables_model.freezed.dart';
part 'tables_model.g.dart';

@freezed
abstract class TablesModel with _$TablesModel {
  const TablesModel._();

  const factory TablesModel({
    required String id,
    required String name,
  }) = _TablesModel;

  factory TablesModel.fromJson(Map<String, dynamic> json) =>
      _$TablesModelFromJson(json);

  TablesEntity toEntity() => TablesEntity(id: id, name: name);
}



FICHIER: flutter_lib/features/tables/data/models/tables_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tables_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$TablesModel {

 String get id; String get name;
/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TablesModelCopyWith<TablesModel> get copyWith => _$TablesModelCopyWithImpl<TablesModel>(this as TablesModel, _$identity);

  /// Serializes this TablesModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TablesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $TablesModelCopyWith<$Res>  {
  factory $TablesModelCopyWith(TablesModel value, $Res Function(TablesModel) _then) = _$TablesModelCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$TablesModelCopyWithImpl<$Res>
    implements $TablesModelCopyWith<$Res> {
  _$TablesModelCopyWithImpl(this._self, this._then);

  final TablesModel _self;
  final $Res Function(TablesModel) _then;

/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [TablesModel].
extension TablesModelPatterns on TablesModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _TablesModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _TablesModel value)  $default,){
final _that = this;
switch (_that) {
case _TablesModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _TablesModel value)?  $default,){
final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _TablesModel():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _TablesModel extends TablesModel {
  const _TablesModel({required this.id, required this.name}): super._();
  factory _TablesModel.fromJson(Map<String, dynamic> json) => _$TablesModelFromJson(json);

@override final  String id;
@override final  String name;

/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TablesModelCopyWith<_TablesModel> get copyWith => __$TablesModelCopyWithImpl<_TablesModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TablesModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TablesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$TablesModelCopyWith<$Res> implements $TablesModelCopyWith<$Res> {
  factory _$TablesModelCopyWith(_TablesModel value, $Res Function(_TablesModel) _then) = __$TablesModelCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$TablesModelCopyWithImpl<$Res>
    implements _$TablesModelCopyWith<$Res> {
  __$TablesModelCopyWithImpl(this._self, this._then);

  final _TablesModel _self;
  final $Res Function(_TablesModel) _then;

/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_TablesModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/tables/data/models/tables_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_TablesModel _$TablesModelFromJson(Map<String, dynamic> json) =>
    _TablesModel(id: json['id'] as String, name: json['name'] as String);

Map<String, dynamic> _$TablesModelToJson(_TablesModel instance) =>
    <String, dynamic>{'id': instance.id, 'name': instance.name};



FICHIER: flutter_lib/features/tables/data/repositories/tables_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/tables_entity.dart';
import '../../domain/repositories/tables_repository.dart';
import '../datasources/tables_remote_data_source.dart';

part 'tables_repository_impl.g.dart';

@riverpod
TablesRepository tablesRepository(Ref ref) {
  final remoteDataSource = ref.watch(tablesRemoteDataSourceProvider);
  return TablesRepositoryImpl(remoteDataSource);
}

class TablesRepositoryImpl implements TablesRepository {
  final TablesRemoteDataSource _remoteDataSource;

  TablesRepositoryImpl(this._remoteDataSource);

  @override
  Future<List<TablesEntity>> getTabless() async {
    final models = await _remoteDataSource.fetchTabless();
    return models.map((e) => e.toEntity()).toList();
  }

  @override
  Future<TablesEntity> getTables(String id) async {
    final model = await _remoteDataSource.fetchTables(id);
    return model.toEntity();
  }
}



FICHIER: flutter_lib/features/tables/data/repositories/tables_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(tablesRepository)
final tablesRepositoryProvider = TablesRepositoryProvider._();

final class TablesRepositoryProvider
    extends
        $FunctionalProvider<
          TablesRepository,
          TablesRepository,
          TablesRepository
        >
    with $Provider<TablesRepository> {
  TablesRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tablesRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tablesRepositoryHash();

  @$internal
  @override
  $ProviderElement<TablesRepository> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  TablesRepository create(Ref ref) {
    return tablesRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TablesRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TablesRepository>(value),
    );
  }
}

String _$tablesRepositoryHash() => r'e1101c1fd0ee9937e6af20cff3e97441681de356';



FICHIER: flutter_lib/features/tables/domain/entities/tables_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'tables_entity.freezed.dart';

@freezed
abstract class TablesEntity with _$TablesEntity {
  const factory TablesEntity({
    required String id,
    required String name,
  }) = _TablesEntity;
}



FICHIER: flutter_lib/features/tables/domain/entities/tables_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tables_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$TablesEntity {

 String get id; String get name;
/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TablesEntityCopyWith<TablesEntity> get copyWith => _$TablesEntityCopyWithImpl<TablesEntity>(this as TablesEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TablesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $TablesEntityCopyWith<$Res>  {
  factory $TablesEntityCopyWith(TablesEntity value, $Res Function(TablesEntity) _then) = _$TablesEntityCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$TablesEntityCopyWithImpl<$Res>
    implements $TablesEntityCopyWith<$Res> {
  _$TablesEntityCopyWithImpl(this._self, this._then);

  final TablesEntity _self;
  final $Res Function(TablesEntity) _then;

/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [TablesEntity].
extension TablesEntityPatterns on TablesEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _TablesEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _TablesEntity value)  $default,){
final _that = this;
switch (_that) {
case _TablesEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _TablesEntity value)?  $default,){
final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _TablesEntity():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc


class _TablesEntity implements TablesEntity {
  const _TablesEntity({required this.id, required this.name});


@override final  String id;
@override final  String name;

/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TablesEntityCopyWith<_TablesEntity> get copyWith => __$TablesEntityCopyWithImpl<_TablesEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TablesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$TablesEntityCopyWith<$Res> implements $TablesEntityCopyWith<$Res> {
  factory _$TablesEntityCopyWith(_TablesEntity value, $Res Function(_TablesEntity) _then) = __$TablesEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$TablesEntityCopyWithImpl<$Res>
    implements _$TablesEntityCopyWith<$Res> {
  __$TablesEntityCopyWithImpl(this._self, this._then);

  final _TablesEntity _self;
  final $Res Function(_TablesEntity) _then;

/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_TablesEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/tables/domain/repositories/tables_repository.dart
--------------------------------------------------------------------------------
import '../entities/tables_entity.dart';

abstract class TablesRepository {
  Future<List<TablesEntity>> getTabless();
  Future<TablesEntity> getTables(String id);
}



FICHIER: flutter_lib/features/tables/domain/usecases/get_tabless_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/tables_entity.dart';
import '../repositories/tables_repository.dart';
import '../../data/repositories/tables_repository_impl.dart';

part 'get_tabless_usecase.g.dart';

@riverpod
Future<List<TablesEntity>> getTabless(Ref ref) {
  return ref.watch(tablesRepositoryProvider).getTabless();
}



FICHIER: flutter_lib/features/tables/domain/usecases/get_tabless_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_tabless_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getTabless)
final getTablessProvider = GetTablessProvider._();

final class GetTablessProvider
    extends
        $FunctionalProvider<
          AsyncValue<List<TablesEntity>>,
          List<TablesEntity>,
          FutureOr<List<TablesEntity>>
        >
    with
        $FutureModifier<List<TablesEntity>>,
        $FutureProvider<List<TablesEntity>> {
  GetTablessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getTablessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getTablessHash();

  @$internal
  @override
  $FutureProviderElement<List<TablesEntity>> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<List<TablesEntity>> create(Ref ref) {
    return getTabless(ref);
  }
}

String _$getTablessHash() => r'a540bcb396d51fbb80a1e6601cd7d6608e758543';



FICHIER: flutter_lib/features/tables/presentation/controllers/tables_controller.dart
--------------------------------------------------------------------------------
// flutter_lib/features/tables/presentation/controllers/tables_controller.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/tables_entity.dart';
import '../../domain/usecases/get_tabless_usecase.dart';
import '../../../../services/sfu_service.dart';
import '../../../../providers/auth_provider.dart';

part 'tables_controller.g.dart';

// Nouveau state pour gÃ©rer la gÃ©nÃ©ration de token
class TokenGenerationState {
  final bool isLoading;
  final Map<String, dynamic>? tokenData;
  final Object? error;

  const TokenGenerationState({
    this.isLoading = false,
    this.tokenData,
    this.error,
  });

  TokenGenerationState copyWith({
    bool? isLoading,
    Map<String, dynamic>? tokenData,
    Object? error,
  }) {
    return TokenGenerationState(
      isLoading: isLoading ?? this.isLoading,
      tokenData: tokenData ?? this.tokenData,
      error: error ?? this.error,
    );
  }
}

@riverpod
class TablesController extends _$TablesController {
  late SfuService _sfuService;

  @override
  FutureOr<List<TablesEntity>> build() {
    _sfuService = ref.watch(sfuServiceProvider);
    return ref.watch(getTablessProvider.future);
  }

  // Nouvelle mÃ©thode pour gÃ©nÃ©rer le token
  Future<Map<String, dynamic>?> generateTokenForTable(Map<String, dynamic> table) async {
    final authState = ref.read(authStateNotifierProvider);

    if (!authState.isFullyAuthenticated) {
      print('âŒ Utilisateur non authentifiÃ©');
      return null;
    }

    final connectedUserName = authState.user?.displayName ?? 'Utilisateur';
    final connectedUserIdentity = authState.user?.uid ?? '';

    if (connectedUserName.isEmpty || connectedUserIdentity.isEmpty) {
      print('âŒ Informations utilisateur manquantes');
      return null;
    }

    try {
      print('ğŸ”„ GÃ©nÃ©ration du token pour la table: ${table['name']}');

      final tokenData = await _sfuService.generateToken(
        participantIdentity: connectedUserIdentity,
        participantName: connectedUserName,
        roomName: table['name'],
      );

      print('âœ… Token gÃ©nÃ©rÃ© avec succÃ¨s');
      return tokenData;

    } catch (e) {
      print('âŒ Erreur lors de la gÃ©nÃ©ration du token: $e');
      rethrow;
    }
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => ref.refresh(getTablessProvider.future));
  }
}


FICHIER: flutter_lib/features/tables/presentation/controllers/tables_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(TablesController)
final tablesControllerProvider = TablesControllerProvider._();

final class TablesControllerProvider
    extends $AsyncNotifierProvider<TablesController, List<TablesEntity>> {
  TablesControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tablesControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tablesControllerHash();

  @$internal
  @override
  TablesController create() => TablesController();
}

String _$tablesControllerHash() => r'f15b9925908014fc546d034ff7c0a2a99081cf9c';

abstract class _$TablesController extends $AsyncNotifier<List<TablesEntity>> {
  FutureOr<List<TablesEntity>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<List<TablesEntity>>, List<TablesEntity>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<TablesEntity>>, List<TablesEntity>>,
              AsyncValue<List<TablesEntity>>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/tables/presentation/screens/connect.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:livekit_client/livekit_client.dart';
import './prejoin.dart';
import '../widgets/text_field.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:permission_handler/permission_handler.dart';

import 'dart:async';
import '../../../../drinkks/exts.dart';

class ConnectPage extends StatefulWidget {
  //
  const ConnectPage({
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _ConnectPageState();
}

class _ConnectPageState extends State<ConnectPage> {
  //
  static const _storeKeyUri = 'uri';
  static const _storeKeyToken = 'token';
  static const _storeKeySimulcast = 'simulcast';
  static const _storeKeyAdaptiveStream = 'adaptive-stream';
  static const _storeKeyDynacast = 'dynacast';
  static const _storeKeyE2EE = 'e2ee';
  static const _storeKeySharedKey = 'shared-key';
  static const _storeKeyMultiCodec = 'multi-codec';
  static const _storeKeyPreferredCodec = 'preferred-codec';

  final _uriCtrl = TextEditingController();
  final _tokenCtrl = TextEditingController();
  final _sharedKeyCtrl = TextEditingController();
  bool _simulcast = true;
  bool _adaptiveStream = true;
  bool _dynacast = true;
  bool _busy = false;
  bool _e2ee = false;
  bool _multiCodec = false;
  String _preferredCodec = 'VP8';

  @override
  void initState() {
    super.initState();
    unawaited(_readPrefs());
    if (lkPlatformIs(PlatformType.android)) {
      unawaited(_checkPermissions());
    }
  }

  @override
  void dispose() {
    _uriCtrl.dispose();
    _tokenCtrl.dispose();
    super.dispose();
  }

  Future<void> _checkPermissions() async {
    var status = await Permission.bluetooth.request();
    if (status.isPermanentlyDenied) {
      print('Bluetooth Permission disabled');
    }

    status = await Permission.bluetoothConnect.request();
    if (status.isPermanentlyDenied) {
      print('Bluetooth Connect Permission disabled');
    }

    status = await Permission.camera.request();
    if (status.isPermanentlyDenied) {
      print('Camera Permission disabled');
    }

    status = await Permission.microphone.request();
    if (status.isPermanentlyDenied) {
      print('Microphone Permission disabled');
    }
  }

  // Read saved URL and Token
  Future<void> _readPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    _uriCtrl.text =
        const bool.hasEnvironment('URL') ? const String.fromEnvironment('URL') : prefs.getString(_storeKeyUri) ?? '';
    _tokenCtrl.text = const bool.hasEnvironment('TOKEN')
        ? const String.fromEnvironment('TOKEN')
        : prefs.getString(_storeKeyToken) ?? '';
    _sharedKeyCtrl.text = const bool.hasEnvironment('E2EEKEY')
        ? const String.fromEnvironment('E2EEKEY')
        : prefs.getString(_storeKeySharedKey) ?? '';
    setState(() {
      _simulcast = prefs.getBool(_storeKeySimulcast) ?? true;
      _adaptiveStream = prefs.getBool(_storeKeyAdaptiveStream) ?? true;
      _dynacast = prefs.getBool(_storeKeyDynacast) ?? true;
      _e2ee = prefs.getBool(_storeKeyE2EE) ?? false;
      _multiCodec = prefs.getBool(_storeKeyMultiCodec) ?? false;
      _preferredCodec = prefs.getString(_storeKeyPreferredCodec) ?? 'VP8';
    });
  }

  // Save URL and Token
  Future<void> _writePrefs() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_storeKeyUri, _uriCtrl.text);
    await prefs.setString(_storeKeyToken, _tokenCtrl.text);
    await prefs.setString(_storeKeySharedKey, _sharedKeyCtrl.text);
    await prefs.setBool(_storeKeySimulcast, _simulcast);
    await prefs.setBool(_storeKeyAdaptiveStream, _adaptiveStream);
    await prefs.setBool(_storeKeyDynacast, _dynacast);
    await prefs.setBool(_storeKeyE2EE, _e2ee);
    await prefs.setBool(_storeKeyMultiCodec, _multiCodec);
    await prefs.setString(_storeKeyPreferredCodec, _preferredCodec);
  }

  Future<void> _connect(BuildContext ctx) async {
    //
    try {
      setState(() {
        _busy = true;
      });

      // Save URL and Token for convenience
      await _writePrefs();

      print('Connecting with url: ${_uriCtrl.text}, '
          'token: ${_tokenCtrl.text}...');

      final url = _uriCtrl.text;
      final token = _tokenCtrl.text;
      final e2eeKey = _sharedKeyCtrl.text;
      if (!ctx.mounted) return;
      await Navigator.push<void>(
        ctx,
        MaterialPageRoute(
            builder: (_) => PreJoinPage(
                  args: JoinArgs(
                    url: url,
                    token: token,
                    e2ee: _e2ee,
                    e2eeKey: e2eeKey,
                    simulcast: _simulcast,
                    adaptiveStream: _adaptiveStream,
                    dynacast: _dynacast,
                    preferredCodec: _preferredCodec,
                    enableBackupVideoCodec: ['VP9', 'AV1'].contains(_preferredCodec),
                  ),
                )),
      );
    } catch (error) {
      print('Could not connect $error');
      if (!ctx.mounted) return;
      await ctx.showErrorDialog(error);
    } finally {
      setState(() {
        _busy = false;
      });
    }
  }

  void _setSimulcast(bool? value) async {
    if (value == null || _simulcast == value) return;
    setState(() {
      _simulcast = value;
    });
  }

  void _setE2EE(bool? value) async {
    if (value == null || _e2ee == value) return;
    setState(() {
      _e2ee = value;
    });
  }

  void _setAdaptiveStream(bool? value) async {
    if (value == null || _adaptiveStream == value) return;
    setState(() {
      _adaptiveStream = value;
    });
  }

  void _setDynacast(bool? value) async {
    if (value == null || _dynacast == value) return;
    setState(() {
      _dynacast = value;
    });
  }

  void _setMultiCodec(bool? value) async {
    if (value == null || _multiCodec == value) return;
    setState(() {
      _multiCodec = value;
    });
  }

  @override
  Widget build(BuildContext context) => Scaffold(
        body: Container(
          alignment: Alignment.center,
          child: SingleChildScrollView(
            child: Container(
              padding: const EdgeInsets.symmetric(
                horizontal: 20,
                vertical: 20,
              ),
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.only(bottom: 70),
                    child: SvgPicture.asset(
                      'images/logo-dark.svg',
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 25),
                    child: LKTextField(
                      label: 'Server URL',
                      ctrl: _uriCtrl,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 25),
                    child: LKTextField(
                      label: 'Token',
                      ctrl: _tokenCtrl,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 25),
                    child: LKTextField(
                      label: 'Shared Key',
                      ctrl: _sharedKeyCtrl,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('E2EE'),
                        Switch(
                          value: _e2ee,
                          onChanged: (value) => _setE2EE(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Simulcast'),
                        Switch(
                          value: _simulcast,
                          onChanged: (value) => _setSimulcast(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Adaptive Stream'),
                        Switch(
                          value: _adaptiveStream,
                          onChanged: (value) => _setAdaptiveStream(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Dynacast'),
                        Switch(
                          value: _dynacast,
                          onChanged: (value) => _setDynacast(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: EdgeInsets.only(bottom: _multiCodec ? 5 : 25),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Multi Codec'),
                        Switch(
                          value: _multiCodec,
                          onChanged: (value) => _setMultiCodec(value),
                        ),
                      ],
                    ),
                  ),
                  if (_multiCodec)
                    Padding(
                        padding: const EdgeInsets.only(bottom: 5),
                        child: Row(mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
                          const Text('Preferred Codec:'),
                          DropdownButton<String>(
                            value: _preferredCodec,
                            icon: const Icon(
                              Icons.arrow_drop_down,
                              color: Colors.blue,
                            ),
                            elevation: 16,
                            style: const TextStyle(color: Colors.blue),
                            underline: Container(
                              height: 2,
                              color: Colors.blueAccent,
                            ),
                            onChanged: (String? value) {
                              if (value == null) return;
                              setState(() {
                                _preferredCodec = value;
                              });
                              unawaited(_writePrefs());
                            },
                            items: ['Preferred Codec', 'AV1', 'VP9', 'VP8', 'H264', 'H265']
                                .map<DropdownMenuItem<String>>((String value) {
                              return DropdownMenuItem<String>(
                                value: value,
                                child: Text(value),
                              );
                            }).toList(),
                          )
                        ])),
                  ElevatedButton(
                    onPressed: _busy ? null : () => _connect(context),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        if (_busy)
                          const Padding(
                            padding: EdgeInsets.only(right: 10),
                            child: SizedBox(
                              height: 15,
                              width: 15,
                              child: CircularProgressIndicator(
                                color: Colors.white,
                                strokeWidth: 2,
                              ),
                            ),
                          ),
                        const Text('CONNECT'),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/screens/prejoin.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:math' as math;

import 'package:dropdown_button2/dropdown_button2.dart';
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../../drinkks/exts.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../../drinkks/theme.dart';
import 'room.dart';

class JoinArgs {
  JoinArgs({
    required this.url,
    required this.token,
    this.e2ee = false,
    this.e2eeKey,
    this.simulcast = true,
    this.adaptiveStream = true,
    this.dynacast = true,
    this.preferredCodec = 'VP8',
    this.enableBackupVideoCodec = true,
  });
  final String url;
  final String token;
  final bool e2ee;
  final String? e2eeKey;
  final bool simulcast;
  final bool adaptiveStream;
  final bool dynacast;
  final String preferredCodec;
  final bool enableBackupVideoCodec;
}

class PreJoinPage extends StatefulWidget {
  const PreJoinPage({
    required this.args,
    super.key,
  });
  final JoinArgs args;
  @override
  State<StatefulWidget> createState() => _PreJoinPageState();
}

class _PreJoinPageState extends State<PreJoinPage> {
  static const _prefKeyEnableVideo = 'prejoin-enable-video';
  static const _prefKeyEnableAudio = 'prejoin-enable-audio';

  // Couleurs du thÃ¨me sombre
  final Color _backgroundColor = const Color(0xFF0F0F23); // Noir bleutÃ© profond
  final Color _surfaceColor = const Color(0xFF1A1A2E); // Surface lÃ©gÃ¨rement plus claire
  final Color _primaryColor = const Color(0xFF6366F1); // Indigo doux
  final Color _accentColor = const Color(0xFF8B5CF6); // Violet accent
  final Color _textPrimary = Colors.white;
  final Color _textSecondary = const Color(0xFF94A3B8); // Gris bleutÃ©
  final Color _borderColor = Colors.white.withOpacity(0.1);

  List<MediaDevice> _audioInputs = [];
  List<MediaDevice> _videoInputs = [];
  StreamSubscription? _subscription;

  bool _busy = false;
  bool _enableVideo = true;
  bool _enableAudio = true;
  LocalAudioTrack? _audioTrack;
  LocalVideoTrack? _videoTrack;

  MediaDevice? _selectedVideoDevice;
  MediaDevice? _selectedAudioDevice;
  VideoParameters _selectedVideoParameters = VideoParametersPresets.h720_169;

  // Nouvelle mÃ©thode pour vÃ©rifier et demander les permissions
  Future<bool> _checkAndRequestPermissions() async {
    Map<Permission, PermissionStatus> statuses = await [
      Permission.camera,
      Permission.microphone,
    ].request();

    bool cameraGranted = statuses[Permission.camera]?.isGranted ?? false;
    bool microphoneGranted = statuses[Permission.microphone]?.isGranted ?? false;

    if (!cameraGranted || !microphoneGranted) {
      if (mounted) {
        await showDialog(
          context: context,
          builder: (BuildContext context) => AlertDialog(
            backgroundColor: _surfaceColor,
            title: const Text(
              'Permissions requises',
              style: TextStyle(color: Colors.white),
            ),
            content: const Text(
              'L\'application a besoin des permissions camÃ©ra et microphone pour la visioconfÃ©rence. '
                  'Veuillez les activer dans les paramÃ¨tres.',
              style: TextStyle(color: Colors.white70),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                style: TextButton.styleFrom(
                  foregroundColor: _textSecondary,
                ),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
      return false;
    }
    return true;
  }

  @override
  void initState() {
    super.initState();
    unawaited(_initStateAsync());
  }

  Future<void> _initStateAsync() async {
    // VÃ©rifier les permissions avant de continuer
    bool hasPermissions = await _checkAndRequestPermissions();
    if (!hasPermissions) {
      return;
    }

    await _readPrefs();
    _subscription = Hardware.instance.onDeviceChange.stream.listen(_loadDevices);
    final devices = await Hardware.instance.enumerateDevices();
    await _loadDevices(devices);
  }

  Future<void> _loadDevices(List<MediaDevice> devices) async {
    _audioInputs = devices.where((d) => d.kind == 'audioinput').toList();
    _videoInputs = devices.where((d) => d.kind == 'videoinput').toList();

    if (_selectedAudioDevice != null && !_audioInputs.contains(_selectedAudioDevice)) {
      _selectedAudioDevice = null;
    }
    if (_audioInputs.isEmpty) {
      await _audioTrack?.stop();
      _audioTrack = null;
    }
    if (_selectedVideoDevice != null && !_videoInputs.contains(_selectedVideoDevice)) {
      _selectedVideoDevice = null;
    }
    if (_videoInputs.isEmpty) {
      await _videoTrack?.stop();
      _videoTrack = null;
    }

    if (_enableAudio && _audioInputs.isNotEmpty) {
      if (_selectedAudioDevice == null) {
        _selectedAudioDevice = _audioInputs.first;
        Future.delayed(const Duration(milliseconds: 100), () async {
          if (!mounted) return;
          await _changeLocalAudioTrack();
          if (mounted) setState(() {});
        });
      }
    }

    if (_enableVideo && _videoInputs.isNotEmpty) {
      if (_selectedVideoDevice == null) {
        _selectedVideoDevice = _videoInputs.first;
        Future.delayed(const Duration(milliseconds: 100), () async {
          if (!mounted) return;
          await _changeLocalVideoTrack();
          if (mounted) setState(() {});
        });
      }
    }
    if (mounted) setState(() {});
  }

  Future<void> _setEnableVideo(value) async {
    _enableVideo = value;
    await _writePrefs();
    if (!_enableVideo) {
      await _videoTrack?.stop();
      _videoTrack = null;
      _selectedVideoDevice = null;
    } else {
      // VÃ©rifier les permissions avant d'activer la camÃ©ra
      PermissionStatus cameraStatus = await Permission.camera.status;
      if (!cameraStatus.isGranted) {
        bool granted = await _checkAndRequestPermissions();
        if (!granted) {
          setState(() {
            _enableVideo = false;
          });
          return;
        }
      }

      if (_selectedVideoDevice == null && _videoInputs.isNotEmpty) {
        _selectedVideoDevice = _videoInputs.first;
      }
      await _changeLocalVideoTrack();
    }
    setState(() {});
  }

  Future<void> _setEnableAudio(value) async {
    _enableAudio = value;
    await _writePrefs();
    if (!_enableAudio) {
      await _audioTrack?.stop();
      _audioTrack = null;
      _selectedAudioDevice = null;
    } else {
      // VÃ©rifier les permissions avant d'activer le micro
      PermissionStatus microphoneStatus = await Permission.microphone.status;
      if (!microphoneStatus.isGranted) {
        bool granted = await _checkAndRequestPermissions();
        if (!granted) {
          setState(() {
            _enableAudio = false;
          });
          return;
        }
      }

      if (_selectedAudioDevice == null && _audioInputs.isNotEmpty) {
        _selectedAudioDevice = _audioInputs.first;
      }
      await _changeLocalAudioTrack();
    }
    setState(() {});
  }

  Future<void> _changeLocalAudioTrack() async {
    if (!_enableAudio) return;
    try {
      if (_audioTrack != null) {
        await _audioTrack!.stop();
        _audioTrack = null;
      }

      if (_selectedAudioDevice != null) {
        _audioTrack = await LocalAudioTrack.create(
          AudioCaptureOptions(
            deviceId: _selectedAudioDevice!.deviceId,
          ),
        );
        await _audioTrack!.start();
      }
    } catch (e) {
      print('Erreur lors de la crÃ©ation du track audio: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erreur audio: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  Future<void> _changeLocalVideoTrack() async {
    if (!_enableVideo) return;
    try {
      if (_videoTrack != null) {
        await _videoTrack!.stop();
        _videoTrack = null;
      }

      if (_selectedVideoDevice != null) {
        _videoTrack = await LocalVideoTrack.createCameraTrack(CameraCaptureOptions(
          deviceId: _selectedVideoDevice!.deviceId,
          params: _selectedVideoParameters,
        ));
        await _videoTrack!.start();
      }
    } catch (e) {
      print('Erreur lors de la crÃ©ation du track vidÃ©o: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erreur vidÃ©o: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
        // DÃ©sactiver la vidÃ©o en cas d'erreur
        setState(() {
          _enableVideo = false;
        });
      }
    }
  }

  @override
  void dispose() {
    unawaited(_subscription?.cancel());
    super.dispose();
  }

  _join(BuildContext context) async {
    _busy = true;

    setState(() {});

    final args = widget.args;

    try {
      // VÃ©rifier les permissions avant de rejoindre
      bool hasPermissions = await _checkAndRequestPermissions();
      if (!hasPermissions) {
        setState(() {
          _busy = false;
        });
        return;
      }

      //create new room
      const cameraEncoding = VideoEncoding(
        maxBitrate: 5 * 1000 * 1000,
        maxFramerate: 30,
      );

      const screenEncoding = VideoEncoding(
        maxBitrate: 3 * 1000 * 1000,
        maxFramerate: 15,
      );

      E2EEOptions? e2eeOptions;
      if (args.e2ee && args.e2eeKey != null) {
        final keyProvider = await BaseKeyProvider.create();
        e2eeOptions = E2EEOptions(keyProvider: keyProvider);
        await keyProvider.setKey(args.e2eeKey!);
      }

      final room = Room(
        roomOptions: RoomOptions(
          adaptiveStream: args.adaptiveStream,
          dynacast: args.dynacast,
          defaultAudioPublishOptions: const AudioPublishOptions(
            name: 'custom_audio_track_name',
          ),
          defaultCameraCaptureOptions: const CameraCaptureOptions(
              maxFrameRate: 30,
              params: VideoParameters(
                dimensions: VideoDimensions(1280, 720),
              )),
          defaultScreenShareCaptureOptions: const ScreenShareCaptureOptions(
              useiOSBroadcastExtension: true,
              params: VideoParameters(
                dimensions: VideoDimensionsPresets.h1080_169,
              )),
          defaultVideoPublishOptions: VideoPublishOptions(
            simulcast: args.simulcast,
            videoCodec: args.preferredCodec,
            backupVideoCodec: BackupVideoCodec(
              enabled: args.enableBackupVideoCodec,
            ),
            videoEncoding: cameraEncoding,
            screenShareEncoding: screenEncoding,
          ),
          encryption: e2eeOptions,
        ),
      );
      // Create a Listener before connecting
      final listener = room.createListener();

      await room.prepareConnection(args.url, args.token);

      // Try to connect to the room
      // This will throw an Exception if it fails for any reason.
      await room.connect(
        args.url,
        args.token,
        fastConnectOptions: FastConnectOptions(
          microphone: TrackOption(track: _audioTrack),
          camera: TrackOption(track: _videoTrack),
        ),
      );

      if (!context.mounted) return;
      await Navigator.push<void>(
        context,
        MaterialPageRoute(builder: (_) => RoomPage(room, listener)),
      );
    } catch (error) {
      print('Could not connect $error');
      if (!context.mounted) return;
      await context.showErrorDialog(error);
    } finally {
      setState(() {
        _busy = false;
      });
    }
  }

  void _actionBack(BuildContext context) async {
    await _setEnableVideo(false);
    await _setEnableAudio(false);
    if (!context.mounted) return;
    Navigator.of(context).pop();
  }

  Future<void> _readPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _enableVideo = prefs.getBool(_prefKeyEnableVideo) ?? true;
      _enableAudio = prefs.getBool(_prefKeyEnableAudio) ?? true;
    });
  }

  Future<void> _writePrefs() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_prefKeyEnableVideo, _enableVideo);
    await prefs.setBool(_prefKeyEnableAudio, _enableAudio);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: _backgroundColor,
      appBar: AppBar(
        backgroundColor: _surfaceColor,
        elevation: 0,
        title: const Text(
          'Configuration',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w600,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => _actionBack(context),
        ),
      ),
      body: Container(
        alignment: Alignment.center,
        child: SingleChildScrollView(
          child: Container(
            padding: const EdgeInsets.symmetric(
              horizontal: 20,
              vertical: 20,
            ),
            constraints: const BoxConstraints(maxWidth: 400),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // AperÃ§u vidÃ©o
                Padding(
                  padding: const EdgeInsets.only(bottom: 20),
                  child: Container(
                    width: 320,
                    height: 240,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(
                        color: _borderColor,
                        width: 1,
                      ),
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(15),
                      child: Container(
                        color: _surfaceColor,
                        child: _videoTrack != null
                            ? VideoTrackRenderer(
                          renderMode: VideoRenderMode.auto,
                          _videoTrack!,
                        )
                            : Container(
                          alignment: Alignment.center,
                          child: LayoutBuilder(
                            builder: (ctx, constraints) => Icon(
                              Icons.videocam_off,
                              color: _primaryColor.withOpacity(0.5),
                              size: math.min(constraints.maxHeight, constraints.maxWidth) * 0.3,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                // Section CamÃ©ra
                Container(
                  margin: const EdgeInsets.only(bottom: 16),
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: _surfaceColor,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: _borderColor,
                      width: 1,
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'CamÃ©ra',
                            style: TextStyle(
                              color: _textPrimary,
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          Switch(
                            value: _enableVideo,
                            onChanged: (value) => _setEnableVideo(value),
                            activeColor: _primaryColor,
                            activeTrackColor: _primaryColor.withOpacity(0.3),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_enableVideo) ...[
                        DropdownButtonHideUnderline(
                          child: DropdownButton2<MediaDevice>(
                            isExpanded: true,
                            hint: Text(
                              'SÃ©lectionner une camÃ©ra',
                              style: TextStyle(color: _textSecondary),
                            ),
                            items: _videoInputs
                                .map((MediaDevice item) => DropdownMenuItem<MediaDevice>(
                              value: item,
                              child: Text(
                                item.label,
                                style: TextStyle(
                                  fontSize: 14,
                                  color: _textPrimary,
                                ),
                              ),
                            ))
                                .toList(),
                            value: _selectedVideoDevice,
                            onChanged: (MediaDevice? value) async {
                              if (value != null) {
                                _selectedVideoDevice = value;
                                await _changeLocalVideoTrack();
                                setState(() {});
                              }
                            },
                            buttonStyleData: ButtonStyleData(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              height: 48,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                border: Border.all(color: _borderColor),
                                color: _backgroundColor,
                              ),
                            ),
                            menuItemStyleData: const MenuItemStyleData(
                              height: 48,
                            ),
                            dropdownStyleData: DropdownStyleData(
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: _surfaceColor,
                                border: Border.all(color: _borderColor),
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(height: 12),
                        DropdownButtonHideUnderline(
                          child: DropdownButton2<VideoParameters>(
                            isExpanded: true,
                            hint: Text(
                              'RÃ©solution vidÃ©o',
                              style: TextStyle(color: _textSecondary),
                            ),
                            items: [
                              VideoParametersPresets.h480_43,
                              VideoParametersPresets.h540_169,
                              VideoParametersPresets.h720_169,
                              VideoParametersPresets.h1080_169,
                            ]
                                .map((VideoParameters item) => DropdownMenuItem<VideoParameters>(
                              value: item,
                              child: Text(
                                '${item.dimensions.width}x${item.dimensions.height}',
                                style: TextStyle(
                                  fontSize: 14,
                                  color: _textPrimary,
                                ),
                              ),
                            ))
                                .toList(),
                            value: _selectedVideoParameters,
                            onChanged: (VideoParameters? value) async {
                              if (value != null) {
                                _selectedVideoParameters = value;
                                await _changeLocalVideoTrack();
                                setState(() {});
                              }
                            },
                            buttonStyleData: ButtonStyleData(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              height: 48,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                border: Border.all(color: _borderColor),
                                color: _backgroundColor,
                              ),
                            ),
                            menuItemStyleData: const MenuItemStyleData(
                              height: 48,
                            ),
                            dropdownStyleData: DropdownStyleData(
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: _surfaceColor,
                                border: Border.all(color: _borderColor),
                              ),
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ),

                // Section Microphone
                Container(
                  margin: const EdgeInsets.only(bottom: 24),
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: _surfaceColor,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: _borderColor,
                      width: 1,
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'Microphone',
                            style: TextStyle(
                              color: _textPrimary,
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          Switch(
                            value: _enableAudio,
                            onChanged: (value) => _setEnableAudio(value),
                            activeColor: _primaryColor,
                            activeTrackColor: _primaryColor.withOpacity(0.3),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_enableAudio)
                        DropdownButtonHideUnderline(
                          child: DropdownButton2<MediaDevice>(
                            isExpanded: true,
                            hint: Text(
                              'SÃ©lectionner un microphone',
                              style: TextStyle(color: _textSecondary),
                            ),
                            items: _audioInputs
                                .map((MediaDevice item) => DropdownMenuItem<MediaDevice>(
                              value: item,
                              child: Text(
                                item.label,
                                style: TextStyle(
                                  fontSize: 14,
                                  color: _textPrimary,
                                ),
                              ),
                            ))
                                .toList(),
                            value: _selectedAudioDevice,
                            onChanged: (MediaDevice? value) async {
                              if (value != null) {
                                _selectedAudioDevice = value;
                                await _changeLocalAudioTrack();
                                setState(() {});
                              }
                            },
                            buttonStyleData: ButtonStyleData(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              height: 48,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                border: Border.all(color: _borderColor),
                                color: _backgroundColor,
                              ),
                            ),
                            menuItemStyleData: const MenuItemStyleData(
                              height: 48,
                            ),
                            dropdownStyleData: DropdownStyleData(
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: _surfaceColor,
                                border: Border.all(color: _borderColor),
                              ),
                            ),
                          ),
                        ),
                    ],
                  ),
                ),

                // Bouton Rejoindre
                ElevatedButton(
                  onPressed: _busy ? null : () => _join(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _primaryColor,
                    foregroundColor: Colors.white,
                    minimumSize: const Size(double.infinity, 54),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                    elevation: 0,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (_busy)
                        Padding(
                          padding: const EdgeInsets.only(right: 10),
                          child: SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          ),
                        ),
                      Text(
                        _busy ? 'Connexion...' : 'Rejoindre la conversation',
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


FICHIER: flutter_lib/features/tables/presentation/screens/room.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:convert';
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';

import '../../../../drinkks/exts.dart';
import '../../../../drinkks/utils.dart';
import '../widgets/controls.dart';
import '../widgets/participant.dart';
import '../widgets/participant_info.dart';

class RoomPage extends StatefulWidget {
  final Room room;
  final EventsListener<RoomEvent> listener;

  const RoomPage(
      this.room,
      this.listener, {
        super.key,
      });

  @override
  State<StatefulWidget> createState() => _RoomPageState();
}

class _RoomPageState extends State<RoomPage> {
  // Couleurs du thÃ¨me sombre
  final Color _backgroundColor = const Color(0xFF0F0F23); // Noir bleutÃ© profond
  final Color _surfaceColor = const Color(0xFF1A1A2E); // Surface lÃ©gÃ¨rement plus claire
  final Color _primaryColor = const Color(0xFF6366F1); // Indigo doux
  final Color _accentColor = const Color(0xFF8B5CF6); // Violet accent
  final Color _textPrimary = Colors.white;
  final Color _textSecondary = const Color(0xFF94A3B8); // Gris bleutÃ©
  final Color _borderColor = Colors.white.withOpacity(0.1);

  List<ParticipantTrack> participantTracks = [];
  EventsListener<RoomEvent> get _listener => widget.listener;
  bool get fastConnection => widget.room.engine.fastConnectOptions != null;

  @override
  void initState() {
    super.initState();
    // add callback for a `RoomEvent` as opposed to a `ParticipantEvent`
    widget.room.addListener(_onRoomDidUpdate);
    // add callbacks for finer grained events
    _setUpListeners();
    _sortParticipants();
    WidgetsBindingCompatible.instance?.addPostFrameCallback((_) {
      if (!fastConnection) {
        _askPublish();
      }
    });

    if (lkPlatformIs(PlatformType.android)) {
      unawaited(Hardware.instance.setSpeakerphoneOn(true));
    }

    if (lkPlatformIsDesktop()) {
      onWindowShouldClose = () async {
        unawaited(widget.room.disconnect());
        await _listener.waitFor<RoomDisconnectedEvent>(duration: const Duration(seconds: 5));
      };
    }
  }

  @override
  void dispose() {
    // always dispose listener
    widget.room.removeListener(_onRoomDidUpdate);
    unawaited(_disposeRoomAsync());
    onWindowShouldClose = null;
    super.dispose();
  }

  Future<void> _disposeRoomAsync() async {
    await _listener.dispose();
    await widget.room.dispose();
  }

  /// for more information, see [event types](https://docs.livekit.io/client/events/#events)
  void _setUpListeners() => _listener
    ..on<RoomDisconnectedEvent>((event) async {
      if (event.reason != null) {
        print('Room disconnected: reason => ${event.reason}');
      }
      WidgetsBindingCompatible.instance
          ?.addPostFrameCallback((timeStamp) => Navigator.popUntil(context, (route) => route.isFirst));
    })
    ..on<ParticipantEvent>((event) {
      // sort participants on many track events as noted in documentation linked above
      _sortParticipants();
    })
    ..on<RoomRecordingStatusChanged>((event) {
      unawaited(context.showRecordingStatusChangedDialog(event.activeRecording));
    })
    ..on<RoomAttemptReconnectEvent>((event) {
      print('Attempting to reconnect ${event.attempt}/${event.maxAttemptsRetry}, '
          '(${event.nextRetryDelaysInMs}ms delay until next attempt)');
    })
    ..on<LocalTrackSubscribedEvent>((event) {
      print('Local track subscribed: ${event.trackSid}');
    })
    ..on<LocalTrackPublishedEvent>((_) => _sortParticipants())
    ..on<LocalTrackUnpublishedEvent>((_) => _sortParticipants())
    ..on<TrackSubscribedEvent>((_) => _sortParticipants())
    ..on<TrackUnsubscribedEvent>((_) => _sortParticipants())
    ..on<TrackE2EEStateEvent>(_onE2EEStateEvent)
    ..on<ParticipantNameUpdatedEvent>((event) {
      print('Participant name updated: ${event.participant.identity}, name => ${event.name}');
      _sortParticipants();
    })
    ..on<ParticipantMetadataUpdatedEvent>((event) {
      print('Participant metadata updated: ${event.participant.identity}, metadata => ${event.metadata}');
    })
    ..on<RoomMetadataChangedEvent>((event) {
      print('Room metadata changed: ${event.metadata}');
    })
    ..on<DataReceivedEvent>((event) {
      String decoded = 'Failed to decode';
      try {
        decoded = utf8.decode(event.data);
      } catch (err) {
        print('Failed to decode: $err');
      }
      unawaited(context.showDataReceivedDialog(decoded));
    })
    ..on<AudioPlaybackStatusChanged>((event) async {
      if (!widget.room.canPlaybackAudio) {
        print('Audio playback failed for iOS Safari ..........');
        final yesno = await context.showPlayAudioManuallyDialog();
        if (yesno == true) {
          await widget.room.startAudio();
        }
      }
    });

  void _askPublish() async {
    final result = await context.showPublishDialog();
    if (!mounted) return;
    if (result != true) return;
    // video will fail when running in ios simulator
    try {
      await widget.room.localParticipant?.setCameraEnabled(true);
    } catch (error) {
      print('could not publish video: $error');
      if (!mounted) return;
      await context.showErrorDialog(error);
    }
    try {
      await widget.room.localParticipant?.setMicrophoneEnabled(true);
    } catch (error) {
      print('could not publish audio: $error');
      if (!mounted) return;
      await context.showErrorDialog(error);
    }
  }

  void _onRoomDidUpdate() {
    _sortParticipants();
  }

  void _onE2EEStateEvent(TrackE2EEStateEvent e2eeState) {
    print('e2ee state: $e2eeState');
  }

  void _sortParticipants() {
    final userMediaTracks = <ParticipantTrack>[];
    final screenTracks = <ParticipantTrack>[];
    for (var participant in widget.room.remoteParticipants.values) {
      for (var t in participant.videoTrackPublications) {
        if (t.isScreenShare) {
          screenTracks.add(ParticipantTrack(
            participant: participant,
            type: ParticipantTrackType.kScreenShare,
          ));
        } else {
          userMediaTracks.add(ParticipantTrack(participant: participant));
        }
      }
    }
    // sort speakers for the grid
    userMediaTracks.sort((a, b) {
      // loudest speaker first
      if (a.participant.isSpeaking && b.participant.isSpeaking) {
        if (a.participant.audioLevel > b.participant.audioLevel) {
          return -1;
        } else {
          return 1;
        }
      }

      // last spoken at
      final aSpokeAt = a.participant.lastSpokeAt?.millisecondsSinceEpoch ?? 0;
      final bSpokeAt = b.participant.lastSpokeAt?.millisecondsSinceEpoch ?? 0;

      if (aSpokeAt != bSpokeAt) {
        return aSpokeAt > bSpokeAt ? -1 : 1;
      }

      // video on
      if (a.participant.hasVideo != b.participant.hasVideo) {
        return a.participant.hasVideo ? -1 : 1;
      }

      // joinedAt
      return a.participant.joinedAt.millisecondsSinceEpoch - b.participant.joinedAt.millisecondsSinceEpoch;
    });

    final localParticipantTracks = widget.room.localParticipant?.videoTrackPublications;
    if (localParticipantTracks != null) {
      for (var t in localParticipantTracks) {
        if (t.isScreenShare) {
          screenTracks.add(ParticipantTrack(
            participant: widget.room.localParticipant!,
            type: ParticipantTrackType.kScreenShare,
          ));
        } else {
          userMediaTracks.add(ParticipantTrack(participant: widget.room.localParticipant!));
        }
      }
    }
    setState(() {
      participantTracks = [...screenTracks, ...userMediaTracks];
    });
  }

  @override
  Widget build(BuildContext context) => Scaffold(
    backgroundColor: _backgroundColor,
    body: Stack(
      children: [
        // Participant principal
        Container(
          color: _backgroundColor,
          child: Column(
            children: [
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: _borderColor,
                      width: 0.5,
                    ),
                  ),
                  child: participantTracks.isNotEmpty
                      ? ParticipantWidget.widgetFor(
                    participantTracks.first,
                    showStatsLayer: true,
                  )
                      : _buildEmptyParticipant(),
                ),
              ),
              if (widget.room.localParticipant != null)
                SafeArea(
                  top: false,
                  child: ControlsWidget(
                    widget.room,
                    widget.room.localParticipant!,
                  ),
                )
            ],
          ),
        ),

        // Miniatures des autres participants
        Positioned(
          left: 0,
          right: 0,
          top: 0,
          child: Container(
            height: 140,
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [
                  _backgroundColor.withOpacity(0.9),
                  _backgroundColor.withOpacity(0.0),
                ],
              ),
            ),
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
              itemCount: math.max(0, participantTracks.length - 1),
              itemBuilder: (BuildContext context, int index) {
                return Container(
                  width: 180,
                  height: 120,
                  margin: const EdgeInsets.only(right: 8),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: _borderColor,
                      width: 1,
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.3),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(11),
                    child: ParticipantWidget.widgetFor(participantTracks[index + 1]),
                  ),
                );
              },
            ),
          ),
        ),
      ],
    ),
  );

  Widget _buildEmptyParticipant() {
    return Container(
      color: _surfaceColor,
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: LinearGradient(
                  colors: [
                    _primaryColor.withOpacity(0.2),
                    _accentColor.withOpacity(0.2),
                  ],
                ),
              ),
              child: Icon(
                Icons.videocam_off,
                size: 40,
                color: _primaryColor.withOpacity(0.5),
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'En attente de participants...',
              style: TextStyle(
                color: _textSecondary,
                fontSize: 16,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


FICHIER: flutter_lib/features/tables/presentation/screens/tables_screen.dart
--------------------------------------------------------------------------------
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:dio/dio.dart';
import '../../../../services/api_service.dart';
import '../controllers/tables_controller.dart';
import 'prejoin.dart';

class TablesScreen extends ConsumerWidget {
  final String venueId;
  final Dio _dio = Dio(); // Ã€ idÃ©alement injecter via un provider

  TablesScreen({
    super.key,
    required this.venueId,
  });

  // MÃ©thode pour gÃ©nÃ©rer le token LiveKit
  Future<void> _generateLiveKitToken(BuildContext context, WidgetRef ref, Map<String, dynamic> table) async {
    try {
      // Appel via le controller qui utilise le service
      final tokenData = await ref.read(tablesControllerProvider.notifier).generateTokenForTable(table);

      if (tokenData == null) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Impossible de gÃ©nÃ©rer le token de connexion'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      // Navigation vers la page de prÃ©-join
      if (context.mounted) {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (_) => PreJoinPage(
              args: JoinArgs(
                url: tokenData['server_url'],
                token: tokenData['participant_token'],
                e2ee: false,
                e2eeKey: null,
                simulcast: true,
                adaptiveStream: true,
                dynacast: true,
                preferredCodec: 'VP8',
                enableBackupVideoCodec: true,
              ),
            ),
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        String errorMessage = 'Erreur de connexion';
        if (e is ApiException) {
          errorMessage = e.message;
        }

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final tablesState = ref.watch(tablesControllerProvider);

    const backgroundColor = Color(0xFF0F0F23);
    const primaryColor = Color(0xFF6366F1);
    const secondaryColor = Color(0xFF8B5CF6);
    const textPrimary = Colors.white;
    const occupiedColor = Color(0xFF10B981);
    const emptyColor = Color(0xFF6B7280);
    const barColor = Color(0xFF8B4513); // Couleur bois du bar

    // DonnÃ©es statiques pour les tables
    final tablesData = [
      {
        'id': '1',
        'name': 'Table du Coin',
        'occupiedSeats': 3,
        'totalSeats': 4,
      },
      {
        'id': '2',
        'name': 'Table du Milieu',
        'occupiedSeats': 1,
        'totalSeats': 4,
      },
      {
        'id': '3',
        'name': 'Table VIP',
        'occupiedSeats': 4,
        'totalSeats': 4,
      },
      {
        'id': '4',
        'name': 'Table FenÃªtre',
        'occupiedSeats': 0,
        'totalSeats': 4,
      },
      {
        'id': '5',
        'name': 'Table Bar',
        'occupiedSeats': 2,
        'totalSeats': 4,
      },
      {
        'id': '6',
        'name': 'Table Intime',
        'occupiedSeats': 3,
        'totalSeats': 4,
      },
    ];

    return Scaffold(
      backgroundColor: backgroundColor,
      body: SafeArea(
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                backgroundColor.withOpacity(0.9),
                Color(0xFF1A1A2E),
              ],
            ),
          ),
          child: Stack(
            children: [
              // Effet d'Ã©toiles en arriÃ¨re-plan
              Positioned.fill(
                child: CustomPaint(
                  painter: _StarsPainter(),
                ),
              ),

              Column(
                children: [
                  // AppBar personnalisÃ©e
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.05),
                      border: Border(
                        bottom: BorderSide(color: Colors.white.withOpacity(0.1)),
                      ),
                    ),
                    child: Row(
                      children: [
                        IconButton(
                          icon: const Icon(Icons.arrow_back, color: textPrimary),
                          onPressed: () {
                            Navigator.pop(context);
                          },
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Le Lounge Ã‰toilÃ©',
                                style: TextStyle(
                                  color: textPrimary,
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              Text(
                                'Ambiance feutrÃ©e â€¢ Jazz doux',
                                style: TextStyle(
                                  color: textPrimary.withOpacity(0.6),
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                          decoration: BoxDecoration(
                            color: primaryColor.withOpacity(0.2),
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(color: primaryColor.withOpacity(0.3)),
                          ),
                          child: Text(
                            '${tablesData.length} tables',
                            style: TextStyle(
                              color: textPrimary,
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),

                  // LÃ©gende avec option pour le bar
                  Container(
                    padding: const EdgeInsets.all(12),
                    margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.03),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceAround,
                      children: [
                        _buildLegendItem(
                          color: occupiedColor,
                          label: 'OccupÃ©',
                          icon: Icons.person,
                        ),
                        _buildLegendItem(
                          color: emptyColor,
                          label: 'Libre',
                          icon: Icons.person_outline,
                        ),
                        _buildLegendItem(
                          color: barColor,
                          label: 'Bar',
                          icon: Icons.local_bar,
                        ),
                      ],
                    ),
                  ),

                  // Contenu principal avec le bar au centre
                  Expanded(
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16.0),
                      child: CustomScrollView(
                        slivers: [
                          // Sliver pour les tables (premiÃ¨re rangÃ©e)
                          SliverGrid(
                            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                              crossAxisCount: 2,
                              crossAxisSpacing: 16,
                              mainAxisSpacing: 24,
                              childAspectRatio: 1,
                            ),
                            delegate: SliverChildBuilderDelegate(
                                  (context, index) {
                                if (index < 2) {
                                  final table = tablesData[index];
                                  return _buildTableCard(
                                    table,
                                    occupiedColor,
                                    emptyColor,
                                    primaryColor,
                                    textPrimary,
                                    onTap: () {
                                      final isFull = (table['occupiedSeats'] as int) == (table['totalSeats'] as int);
                                      if (!isFull) {
                                        _generateLiveKitToken(context, ref, table);
                                      }
                                    },
                                  );
                                }
                                return null;
                              },
                              childCount: 2,
                            ),
                          ),

                          // // Sliver pour le bar central
                          // SliverToBoxAdapter(
                          //   child: Container(
                          //     height: 180,
                          //     margin: const EdgeInsets.symmetric(vertical: 20),
                          //     child: _buildBarIsland(  // â† Ici, il faut appeler la fonction
                          //       barColor,
                          //       primaryColor,
                          //       textPrimary,
                          //     ),
                          //   ),
                          // ),

                          // Sliver pour les autres tables
                          SliverGrid(
                            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                              crossAxisCount: 2,
                              crossAxisSpacing: 16,
                              mainAxisSpacing: 24,
                              childAspectRatio: 1,
                            ),
                            delegate: SliverChildBuilderDelegate(
                                  (context, index) {
                                if (index < tablesData.length - 2) {
                                  final table = tablesData[index + 2];
                                  return _buildTableCard(
                                    table,
                                    occupiedColor,
                                    emptyColor,
                                    primaryColor,
                                    textPrimary,
                                    onTap: () {
                                      final isFull = (table['occupiedSeats'] as int) == (table['totalSeats'] as int);
                                      if (!isFull) {
                                        _generateLiveKitToken(context, ref, table);
                                      }
                                    },
                                  );
                                }
                                return null;
                              },
                              childCount: tablesData.length - 2,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildLegendItem({
    required Color color,
    required String label,
    required IconData icon,
  }) {
    return Row(
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: color,
            shape: BoxShape.circle,
          ),
        ),
        const SizedBox(width: 6),
        Icon(icon, color: color, size: 14),
        const SizedBox(width: 4),
        Text(
          label,
          style: TextStyle(
            color: Colors.white.withOpacity(0.7),
            fontSize: 11,
          ),
        ),
      ],
    );
  }

  Widget _buildBarIsland(Color barColor, Color primaryColor, Color textPrimary) {
    return InkWell(
      onTap: () {
        // Lancer une visio avec le barman
        print('DÃ©marrer une visio avec le barman');
      },
      borderRadius: BorderRadius.circular(20),
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.all(16.0),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(20),
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              barColor.withOpacity(0.8),
              barColor.withOpacity(0.6),
            ],
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.4),
              blurRadius: 15,
              offset: const Offset(0, 5),
            ),
          ],
          border: Border.all(
            color: Colors.amber.withOpacity(0.5),
            width: 2,
          ),
        ),
        child: Stack(
          children: [
            // Effet de bois en arriÃ¨re-plan
            Positioned.fill(
              child: ClipRRect(
                borderRadius: BorderRadius.circular(20),
                child: CustomPaint(
                  painter: _WoodGrainPainter(),
                ),
              ),
            ),

            // Contenu principal Ã  gauche
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Avatar et informations du barman
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Avatar et nom sur la mÃªme ligne
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          // Avatar du barman
                          Container(
                            width: 60,
                            height: 60,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              border: Border.all(
                                color: Colors.white.withOpacity(0.3),
                                width: 2,
                              ),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.3),
                                  blurRadius: 8,
                                  offset: const Offset(0, 3),
                                ),
                              ],
                            ),
                            child: Stack(
                              alignment: Alignment.center,
                              children: [
                                // Avatar
                                Container(
                                  width: 54,
                                  height: 54,
                                  decoration: BoxDecoration(
                                    shape: BoxShape.circle,
                                    color: Color(0xFF2D3748),
                                    border: Border.all(
                                      color: Colors.amber,
                                      width: 1.5,
                                    ),
                                  ),
                                  child: const Icon(
                                    Icons.person,
                                    color: Colors.white,
                                    size: 32,
                                  ),
                                ),

                                // Badge "En ligne"
                                Positioned(
                                  bottom: 2,
                                  right: 2,
                                  child: Container(
                                    width: 16,
                                    height: 16,
                                    decoration: BoxDecoration(
                                      shape: BoxShape.circle,
                                      color: Colors.green,
                                      border: Border.all(
                                        color: Colors.white,
                                        width: 1.5,
                                      ),
                                    ),
                                    child: const Icon(
                                      Icons.check,
                                      color: Colors.white,
                                      size: 10,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),

                          const SizedBox(width: 12),

                          // Nom et description
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  'Marc, le Barman',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                    shadows: [
                                      Shadow(
                                        color: Colors.black.withOpacity(0.5),
                                        blurRadius: 3,
                                        offset: const Offset(0, 1),
                                      ),
                                    ],
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                ),

                                const SizedBox(height: 4),

                                Text(
                                  'SpÃ©cialiste cocktails â€¢ Disponible',
                                  style: TextStyle(
                                    color: Colors.white.withOpacity(0.9),
                                    fontSize: 12,
                                    fontStyle: FontStyle.italic,
                                  ),
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),

                      const SizedBox(height: 12),

                      // Compteur de personnes au bar
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.3),
                          borderRadius: BorderRadius.circular(10),
                          border: Border.all(
                            color: Colors.amber.withOpacity(0.2),
                            width: 1,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.group,
                              color: Colors.amber,
                              size: 14,
                            ),
                            const SizedBox(width: 6),
                            Text(
                              '3 personnes au bar',
                              style: TextStyle(
                                color: Colors.white.withOpacity(0.9),
                                fontSize: 12,
                              ),
                            ),
                          ],
                        ),
                      ),

                      // IcÃ´nes de bouteilles (optionnel)
                      const SizedBox(height: 12),
                      Row(
                        children: [
                          _buildBottleIcon(Icons.local_drink, Colors.blue.withOpacity(0.8), 24),
                          const SizedBox(width: 8),
                          _buildBottleIcon(Icons.wine_bar, Colors.red.withOpacity(0.8), 24),
                          const SizedBox(width: 8),
                          _buildBottleIcon(Icons.local_drink, Colors.green.withOpacity(0.8), 24),
                          const SizedBox(width: 8),
                          _buildBottleIcon(Icons.local_drink, Colors.purple.withOpacity(0.8), 24),
                        ],
                      ),
                    ],
                  ),
                ),

                // Bouton "Discuter" Ã  droite
                Padding(
                  padding: const EdgeInsets.only(left: 16.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.start,
                    children: [
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.amber.shade600,
                              Colors.orange.shade600,
                            ],
                          ),
                          borderRadius: BorderRadius.circular(20),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.3),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                            BoxShadow(
                              color: Colors.orange.withOpacity(0.4),
                              blurRadius: 6,
                              spreadRadius: 1,
                            ),
                          ],
                          border: Border.all(
                            color: Colors.white.withOpacity(0.3),
                            width: 1,
                          ),
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.video_call,
                              color: Colors.white,
                              size: 24,
                            ),
                            const SizedBox(height: 6),
                            Text(
                              'Discuter',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                                fontWeight: FontWeight.w600,
                                shadows: [
                                  Shadow(
                                    color: Colors.black.withOpacity(0.3),
                                    blurRadius: 2,
                                    offset: const Offset(0, 1),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),

                      // Petite indication (optionnel)
                      Container(
                        margin: const EdgeInsets.only(top: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.2),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Text(
                          '1:1',
                          style: TextStyle(
                            color: Colors.white.withOpacity(0.7),
                            fontSize: 10,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildBottleIcon(IconData icon, Color color, double size) {
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: color.withOpacity(0.2),
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: color.withOpacity(0.6),
          width: 1.5,
        ),
      ),
      child: Icon(
        icon,
        color: color,
        size: size * 0.6,
      ),
    );
  }


  Widget _buildTableCard(
      Map<String, dynamic> table,
      Color occupiedColor,
      Color emptyColor,
      Color primaryColor,
      Color textPrimary, {
        required VoidCallback onTap,
      }) {
    final occupiedSeats = table['occupiedSeats'] as int;
    final totalSeats = table['totalSeats'] as int;
    final isFull = occupiedSeats == totalSeats;
    final availableSeats = totalSeats - occupiedSeats;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Carte de la table
        Expanded(
          child: InkWell(
            onTap: isFull ? null : onTap,
            borderRadius: BorderRadius.circular(16),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              color: Colors.white.withOpacity(0.05),
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(
                    color: isFull ? Colors.red.withOpacity(0.3) : primaryColor.withOpacity(0.3),
                    width: 1,
                  ),
                ),
                child: Stack(
                  children: [
                    // SVG de la table au centre
                    Center(
                      child: SvgPicture.string(
                        '''
                        <svg width="80" height="80" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                          <!-- Plateau de table -->
                          <circle cx="50" cy="50" r="35" fill="#2D3748" stroke="#4A5568" stroke-width="2"/>

                          <!-- Pied de table -->
                          <rect x="48" y="70" width="4" height="20" fill="#4A5568" rx="2"/>

                          <!-- DÃ©tails du plateau -->
                          <circle cx="50" cy="50" r="30" fill="none" stroke="#6366F1" stroke-width="1" stroke-dasharray="4 4"/>
                        </svg>
                        ''',
                        width: 80,
                        height: 80,
                      ),
                    ),

                    // Places autour de la table
                    Positioned.fill(
                      child: _buildSeats(
                        occupiedSeats,
                        totalSeats,
                        occupiedColor,
                        emptyColor,
                      ),
                    ),

                    // Badge des places disponibles (en bas Ã  droite)
                    Positioned(
                      bottom: 8,
                      right: 8,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 1),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.chair,
                              color: isFull ? Colors.red : primaryColor,
                              size: 10,
                            ),
                            const SizedBox(width: 4),
                            Text(
                              '$availableSeats',
                              style: TextStyle(
                                color: isFull ? Colors.redAccent : primaryColor,
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                    // IcÃ´ne de verre (si occupÃ©) - en haut Ã  gauche
                    if (occupiedSeats > 0)
                      Positioned(
                        top: 4,
                        left: 4,
                        child: Container(
                          padding: const EdgeInsets.all(6),
                          child: Icon(
                            Icons.local_drink,
                            color: Colors.amber,
                            size: 16,
                          ),
                        ),
                      ),

                    // Indicateur "Complet" au centre de la table
                    if (isFull)
                      Center(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.red.withOpacity(0.9),
                            borderRadius: BorderRadius.circular(20),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.3),
                                blurRadius: 8,
                                offset: const Offset(0, 3),
                              ),
                            ],
                          ),
                          child: Text(
                            'COMPLET',
                            style: TextStyle(
                              color: Colors.white,
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                              letterSpacing: 1.5,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
        ),

        // Nom de la table en dehors du cadre (en bas)
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: Text(
            table['name'],
            style: TextStyle(
              color: textPrimary,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  Widget _buildSeats(int occupied, int total, Color occupiedColor, Color emptyColor) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final centerX = constraints.maxWidth / 2;
        final centerY = constraints.maxHeight / 2;
        final radius = 48.0;

        return Stack(
          children: List.generate(total, (index) {
            final angle = (2 * 3.14159 * index / total) - (3.14159 / 2);
            final x = centerX + radius * cos(angle);
            final y = centerY + radius * sin(angle);
            final isOccupied = index < occupied;

            return Positioned(
              left: x - 18,
              top: y - 18,
              child: Container(
                width: 36,
                height: 36,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isOccupied ? occupiedColor : emptyColor,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 4,
                      offset: const Offset(0, 2),
                    ),
                  ],
                  border: Border.all(
                    color: Colors.white.withOpacity(0.1),
                    width: 1,
                  ),
                ),
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    Icon(
                      isOccupied ? Icons.person : Icons.person_outline,
                      color: Colors.white,
                      size: 18,
                    ),
                    if (isOccupied)
                      Positioned(
                        top: 2,
                        right: 2,
                        child: Container(
                          width: 8,
                          height: 8,
                          decoration: BoxDecoration(
                            color: Colors.green,
                            shape: BoxShape.circle,
                            border: Border.all(
                              color: Colors.white,
                              width: 1,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            );
          }),
        );
      },
    );
  }
}

class _StarsPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withOpacity(0.1)
      ..style = PaintingStyle.fill;

    final random = Random(42);
    for (int i = 0; i < 30; i++) {
      final x = random.nextDouble() * size.width;
      final y = random.nextDouble() * size.height;
      final radius = random.nextDouble() * 1.2 + 0.3;

      canvas.drawCircle(Offset(x, y), radius, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class _WoodGrainPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final basePaint = Paint()
      ..color = Color(0xFF8B4513)
      ..style = PaintingStyle.fill;

    canvas.drawRect(Rect.fromLTWH(0, 0, size.width, size.height), basePaint);

    // Effet de grain de bois
    final grainPaint = Paint()
      ..color = Color(0xFF5D2906)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 0.5;

    final random = Random(123);
    for (int i = 0; i < 50; i++) {
      final startY = random.nextDouble() * size.height;
      final endY = startY + random.nextDouble() * 20;
      final x = random.nextDouble() * size.width;

      canvas.drawLine(
        Offset(x, startY),
        Offset(x + random.nextDouble() * 50, endY),
        grainPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// Classe Random simple pour le CustomPainter
class Random {
  final int seed;

  Random(this.seed);

  double nextDouble() {
    final x = sin(seed * 1000.0) * 10000.0;
    return x - x.floorToDouble();
  }
}


FICHIER: flutter_lib/features/tables/presentation/widgets/controls.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';
import 'package:flutter_background/flutter_background.dart';
import 'package:livekit_client/livekit_client.dart';
// ignore: depend_on_referenced_packages
import 'package:flutter_webrtc/flutter_webrtc.dart';

import '../../../../drinkks/exts.dart';

class ControlsWidget extends StatefulWidget {
  //
  final Room room;
  final LocalParticipant participant;

  const ControlsWidget(
    this.room,
    this.participant, {
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _ControlsWidgetState();
}

class _ControlsWidgetState extends State<ControlsWidget> {
  //
  CameraPosition position = CameraPosition.front;

  List<MediaDevice>? _audioInputs;
  List<MediaDevice>? _audioOutputs;
  List<MediaDevice>? _videoInputs;

  StreamSubscription? _subscription;

  bool _speakerphoneOn = Hardware.instance.speakerOn ?? false;

  @override
  void initState() {
    super.initState();
    participant.addListener(_onChange);
    _subscription = Hardware.instance.onDeviceChange.stream.listen((List<MediaDevice> devices) {
      _loadDevices(devices);
    });
    unawaited(Hardware.instance.enumerateDevices().then(_loadDevices));
  }

  @override
  void dispose() {
    unawaited(_subscription?.cancel());
    participant.removeListener(_onChange);
    super.dispose();
  }

  LocalParticipant get participant => widget.participant;

  void _loadDevices(List<MediaDevice> devices) async {
    _audioInputs = devices.where((d) => d.kind == 'audioinput').toList();
    _audioOutputs = devices.where((d) => d.kind == 'audiooutput').toList();
    _videoInputs = devices.where((d) => d.kind == 'videoinput').toList();
    setState(() {});
  }

  void _onChange() {
    // trigger refresh
    setState(() {});
  }

  void _unpublishAll() async {
    final result = await context.showUnPublishDialog();
    if (result == true) await participant.unpublishAllTracks();
  }

  bool get isMuted => participant.isMuted;

  void _disableAudio() async {
    await participant.setMicrophoneEnabled(false);
  }

  Future<void> _enableAudio() async {
    await participant.setMicrophoneEnabled(true);
  }

  void _disableVideo() async {
    await participant.setCameraEnabled(false);
  }

  void _enableVideo() async {
    await participant.setCameraEnabled(true);
  }

  void _selectAudioOutput(MediaDevice device) async {
    await widget.room.setAudioOutputDevice(device);
    setState(() {});
  }

  void _selectAudioInput(MediaDevice device) async {
    await widget.room.setAudioInputDevice(device);
    setState(() {});
  }

  void _selectVideoInput(MediaDevice device) async {
    await widget.room.setVideoInputDevice(device);
    setState(() {});
  }

  void _setSpeakerphoneOn() async {
    _speakerphoneOn = !_speakerphoneOn;
    await widget.room.setSpeakerOn(_speakerphoneOn, forceSpeakerOutput: false);
    setState(() {});
  }

  void _toggleCamera() async {
    final track = participant.videoTrackPublications.firstOrNull?.track;
    if (track == null) return;

    try {
      final newPosition = position.switched();
      await track.setCameraPosition(newPosition);
      setState(() {
        position = newPosition;
      });
    } catch (error) {
      print('could not restart track: $error');
      return;
    }
  }

  void _enableScreenShare() async {
    if (lkPlatformIsDesktop()) {
      try {
        final source = await showDialog<DesktopCapturerSource>(
          context: context,
          builder: (context) => ScreenSelectDialog(),
        );
        if (source == null) {
          print('cancelled screenshare');
          return;
        }
        print('DesktopCapturerSource: ${source.id}');
        final track = await LocalVideoTrack.createScreenShareTrack(
          ScreenShareCaptureOptions(
            sourceId: source.id,
            maxFrameRate: 15.0,
          ),
        );
        await participant.publishVideoTrack(track);
      } catch (e) {
        print('could not publish video: $e');
      }
      return;
    }
    if (lkPlatformIs(PlatformType.android)) {
      // Android specific
      final hasCapturePermission = await Helper.requestCapturePermission();
      if (!hasCapturePermission) {
        return;
      }

      requestBackgroundPermission([bool isRetry = false]) async {
        // Required for android screenshare.
        try {
          bool hasPermissions = await FlutterBackground.hasPermissions;
          if (!isRetry) {
            const androidConfig = FlutterBackgroundAndroidConfig(
              notificationTitle: 'Screen Sharing',
              notificationText: 'LiveKit Example is sharing the screen.',
              notificationImportance: AndroidNotificationImportance.normal,
              notificationIcon: AndroidResource(name: 'livekit_ic_launcher', defType: 'mipmap'),
            );
            hasPermissions = await FlutterBackground.initialize(androidConfig: androidConfig);
          }
          if (hasPermissions && !FlutterBackground.isBackgroundExecutionEnabled) {
            await FlutterBackground.enableBackgroundExecution();
          }
        } catch (e) {
          if (!isRetry) {
            return await Future<void>.delayed(const Duration(seconds: 1), () => requestBackgroundPermission(true));
          }
          print('could not publish video: $e');
        }
      }

      await requestBackgroundPermission();
    }

    if (lkPlatformIsWebMobile()) {
      if (!mounted) return;
      await context.showErrorDialog('Screen share is not supported on mobile web');
      return;
    }
    await participant.setScreenShareEnabled(true, captureScreenAudio: true);
  }

  void _disableScreenShare() async {
    await participant.setScreenShareEnabled(false);
    if (lkPlatformIs(PlatformType.android)) {
      // Android specific
      try {
        //   await FlutterBackground.disableBackgroundExecution();
      } catch (error) {
        print('error disabling screen share: $error');
      }
    }
  }

  void _onTapDisconnect() async {
    final result = await context.showDisconnectDialog();
    if (result == true) await widget.room.disconnect();
  }

  void _onTapUpdateSubscribePermission() async {
    final result = await context.showSubscribePermissionDialog();
    if (result != null) {
      try {
        widget.room.localParticipant?.setTrackSubscriptionPermissions(
          allParticipantsAllowed: result,
        );
      } catch (error) {
        if (!mounted) return;
        await context.showErrorDialog(error);
      }
    }
  }

  void _onTapSimulateScenario() async {
    final result = await context.showSimulateScenarioDialog();
    if (result != null) {
      print('${result}');

      if (SimulateScenarioResult.e2eeKeyRatchet == result) {
        await widget.room.e2eeManager?.ratchetKey();
      }

      if (SimulateScenarioResult.participantMetadata == result) {
        widget.room.localParticipant?.setMetadata('new metadata ${widget.room.localParticipant?.identity}');
      }

      if (SimulateScenarioResult.participantName == result) {
        widget.room.localParticipant?.setName('new name for ${widget.room.localParticipant?.identity}');
      }

      await widget.room.sendSimulateScenario(
        speakerUpdate: result == SimulateScenarioResult.speakerUpdate ? 3 : null,
        signalReconnect: result == SimulateScenarioResult.signalReconnect ? true : null,
        fullReconnect: result == SimulateScenarioResult.fullReconnect ? true : null,
        nodeFailure: result == SimulateScenarioResult.nodeFailure ? true : null,
        migration: result == SimulateScenarioResult.migration ? true : null,
        serverLeave: result == SimulateScenarioResult.serverLeave ? true : null,
        switchCandidate: result == SimulateScenarioResult.switchCandidate ? true : null,
      );
    }
  }

  void _onTapSendData() async {
    final result = await context.showSendDataDialog();
    if (result == true) {
      await widget.participant.publishData(
        utf8.encode('This is a sample data message'),
        reliable: true,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(
        vertical: 15,
        horizontal: 15,
      ),
      child: Wrap(
        alignment: WrapAlignment.center,
        spacing: 5,
        runSpacing: 5,
        children: [
          IconButton(
            onPressed: _unpublishAll,
            icon: const Icon(Icons.cancel),
            tooltip: 'Unpublish all',
          ),
          if (participant.isMicrophoneEnabled())
            if (lkPlatformIs(PlatformType.android))
              IconButton(
                onPressed: _disableAudio,
                icon: const Icon(Icons.mic),
                tooltip: 'mute audio',
              )
            else
              PopupMenuButton<MediaDevice>(
                icon: const Icon(Icons.settings_voice),
                offset: const Offset(0, -90),
                itemBuilder: (BuildContext context) {
                  return [
                    PopupMenuItem<MediaDevice>(
                      value: null,
                      onTap: isMuted ? _enableAudio : _disableAudio,
                      child: const ListTile(
                        leading: Icon(
                          Icons.mic_off,
                          color: Colors.white,
                        ),
                        title: Text('Mute Microphone'),
                      ),
                    ),
                    if (_audioInputs != null)
                      ..._audioInputs!.map((device) {
                        return PopupMenuItem<MediaDevice>(
                          value: device,
                          child: ListTile(
                            leading: (device.deviceId == widget.room.selectedAudioInputDeviceId)
                                ? const Icon(
                                    Icons.check_box_outlined,
                                    color: Colors.white,
                                  )
                                : const Icon(
                                    Icons.check_box_outline_blank,
                                    color: Colors.white,
                                  ),
                            title: Text(device.label),
                          ),
                          onTap: () => _selectAudioInput(device),
                        );
                      })
                  ];
                },
              )
          else
            IconButton(
              onPressed: _enableAudio,
              icon: const Icon(Icons.mic_off),
              tooltip: 'un-mute audio',
            ),
          if (!lkPlatformIsMobile())
            PopupMenuButton<MediaDevice>(
              icon: const Icon(Icons.volume_up),
              itemBuilder: (BuildContext context) {
                return [
                  const PopupMenuItem<MediaDevice>(
                    value: null,
                    child: ListTile(
                      leading: Icon(
                        Icons.speaker,
                        color: Colors.white,
                      ),
                      title: Text('Select Audio Output'),
                    ),
                  ),
                  if (_audioOutputs != null)
                    ..._audioOutputs!.map((device) {
                      return PopupMenuItem<MediaDevice>(
                        value: device,
                        child: ListTile(
                          leading: (device.deviceId == widget.room.selectedAudioOutputDeviceId)
                              ? const Icon(
                                  Icons.check_box_outlined,
                                  color: Colors.white,
                                )
                              : const Icon(
                                  Icons.check_box_outline_blank,
                                  color: Colors.white,
                                ),
                          title: Text(device.label),
                        ),
                        onTap: () => _selectAudioOutput(device),
                      );
                    })
                ];
              },
            ),
          if (!kIsWeb && lkPlatformIsMobile())
            IconButton(
              disabledColor: Colors.grey,
              onPressed: _setSpeakerphoneOn,
              icon: Icon(_speakerphoneOn ? Icons.speaker_phone : Icons.phone_android),
              tooltip: 'Switch SpeakerPhone',
            ),
          if (participant.isCameraEnabled())
            PopupMenuButton<MediaDevice>(
              icon: const Icon(Icons.videocam_sharp),
              itemBuilder: (BuildContext context) {
                return [
                  PopupMenuItem<MediaDevice>(
                    value: null,
                    onTap: _disableVideo,
                    child: const ListTile(
                      leading: Icon(
                        Icons.videocam_off,
                        color: Colors.white,
                      ),
                      title: Text('Disable Camera'),
                    ),
                  ),
                  if (_videoInputs != null)
                    ..._videoInputs!.map((device) {
                      return PopupMenuItem<MediaDevice>(
                        value: device,
                        child: ListTile(
                          leading: (device.deviceId == widget.room.selectedVideoInputDeviceId)
                              ? const Icon(
                                  Icons.check_box_outlined,
                                  color: Colors.white,
                                )
                              : const Icon(
                                  Icons.check_box_outline_blank,
                                  color: Colors.white,
                                ),
                          title: Text(device.label),
                        ),
                        onTap: () => _selectVideoInput(device),
                      );
                    })
                ];
              },
            )
          else
            IconButton(
              onPressed: _enableVideo,
              icon: const Icon(Icons.videocam_off),
              tooltip: 'un-mute video',
            ),
          IconButton(
            icon: Icon(position == CameraPosition.back ? Icons.video_camera_back : Icons.video_camera_front),
            onPressed: () => _toggleCamera(),
            tooltip: 'toggle camera',
          ),
          if (participant.isScreenShareEnabled())
            IconButton(
              icon: const Icon(Icons.monitor_outlined),
              onPressed: () => _disableScreenShare(),
              tooltip: 'unshare screen (experimental)',
            )
          else
            IconButton(
              icon: const Icon(Icons.monitor),
              onPressed: () => _enableScreenShare(),
              tooltip: 'share screen (experimental)',
            ),
          IconButton(
            onPressed: _onTapDisconnect,
            icon: const Icon(Icons.close_sharp),
            tooltip: 'disconnect',
          ),
          IconButton(
            onPressed: _onTapSendData,
            icon: const Icon(Icons.message),
            tooltip: 'send demo data',
          ),
          IconButton(
            onPressed: _onTapUpdateSubscribePermission,
            icon: const Icon(Icons.settings),
            tooltip: 'Subscribe permission',
          ),
          IconButton(
            onPressed: _onTapSimulateScenario,
            icon: const Icon(Icons.bug_report),
            tooltip: 'Simulate scenario',
          ),
        ],
      ),
    );
  }
}



FICHIER: flutter_lib/features/tables/presentation/widgets/no_video.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'dart:math' as math;

import '../../../../drinkks/theme.dart';

class NoVideoWidget extends StatelessWidget {
  //
  const NoVideoWidget({super.key});

  @override
  Widget build(BuildContext context) => Container(
        alignment: Alignment.center,
        child: LayoutBuilder(
          builder: (ctx, constraints) => Icon(
            Icons.videocam_off_outlined,
            color: LKColors.lkBlue,
            size: math.min(constraints.maxHeight, constraints.maxWidth) * 0.3,
          ),
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/widgets/participant.dart
--------------------------------------------------------------------------------
import 'package:collection/collection.dart';
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import '../../../../drinkks/theme.dart';

import 'dart:async';
import './no_video.dart';
import './participant_info.dart';
import './participant_stats.dart';
import './sound_waveform.dart';

abstract class ParticipantWidget extends StatefulWidget {
  // Convenience method to return relevant widget for participant
  static ParticipantWidget widgetFor(ParticipantTrack participantTrack, {bool showStatsLayer = false}) {
    if (participantTrack.participant is LocalParticipant) {
      return LocalParticipantWidget(
          participantTrack.participant as LocalParticipant, participantTrack.type, showStatsLayer);
    } else if (participantTrack.participant is RemoteParticipant) {
      return RemoteParticipantWidget(
          participantTrack.participant as RemoteParticipant, participantTrack.type, showStatsLayer);
    }
    throw UnimplementedError('Unknown participant type');
  }

  // Must be implemented by child class
  abstract final Participant participant;
  abstract final ParticipantTrackType type;
  abstract final bool showStatsLayer;
  final VideoQuality quality;

  const ParticipantWidget({
    this.quality = VideoQuality.MEDIUM,
    super.key,
  });
}

class LocalParticipantWidget extends ParticipantWidget {
  @override
  final LocalParticipant participant;
  @override
  final ParticipantTrackType type;
  @override
  final bool showStatsLayer;

  const LocalParticipantWidget(
    this.participant,
    this.type,
    this.showStatsLayer, {
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _LocalParticipantWidgetState();
}

class RemoteParticipantWidget extends ParticipantWidget {
  @override
  final RemoteParticipant participant;
  @override
  final ParticipantTrackType type;
  @override
  final bool showStatsLayer;

  const RemoteParticipantWidget(
    this.participant,
    this.type,
    this.showStatsLayer, {
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _RemoteParticipantWidgetState();
}

abstract class _ParticipantWidgetState<T extends ParticipantWidget> extends State<T> {
  bool _visible = true;
  VideoTrack? get activeVideoTrack;
  AudioTrack? get activeAudioTrack;
  TrackPublication? get videoPublication;
  TrackPublication? get audioPublication;
  bool get isScreenShare => widget.type == ParticipantTrackType.kScreenShare;
  EventsListener<ParticipantEvent>? _listener;

  @override
  void initState() {
    super.initState();
    _listener = widget.participant.createListener();
    _listener?.on<TranscriptionEvent>((e) {
      for (var seg in e.segments) {
        print('Transcription: ${seg.text} ${seg.isFinal}');
      }
    });

    widget.participant.addListener(_onParticipantChanged);
    _onParticipantChanged();
  }

  @override
  void dispose() {
    widget.participant.removeListener(_onParticipantChanged);
    unawaited(_listener?.dispose());
    super.dispose();
  }

  @override
  void didUpdateWidget(covariant T oldWidget) {
    oldWidget.participant.removeListener(_onParticipantChanged);
    widget.participant.addListener(_onParticipantChanged);
    _onParticipantChanged();
    super.didUpdateWidget(oldWidget);
  }

  // Notify Flutter that UI re-build is required, but we don't set anything here
  // since the updated values are computed properties.
  void _onParticipantChanged() => setState(() {});

  // Widgets to show above the info bar
  List<Widget> extraWidgets(bool isScreenShare) => [];

  @override
  Widget build(BuildContext ctx) => Container(
        foregroundDecoration: BoxDecoration(
          border: widget.participant.isSpeaking && !isScreenShare
              ? Border.all(
                  width: 5,
                  color: LKColors.lkBlue,
                )
              : null,
        ),
        decoration: BoxDecoration(
          color: Theme.of(ctx).cardColor,
        ),
        child: Stack(
          children: [
            // Video
            InkWell(
              onTap: () => setState(() => _visible = !_visible),
              child: activeVideoTrack != null && !activeVideoTrack!.muted
                  ? VideoTrackRenderer(
                      renderMode: VideoRenderMode.auto,
                      activeVideoTrack!,
                    )
                  : const NoVideoWidget(),
            ),
            // Bottom bar
            Align(
              alignment: Alignment.bottomCenter,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                mainAxisSize: MainAxisSize.min,
                children: [
                  ...extraWidgets(isScreenShare),
                  ParticipantInfoWidget(
                    title: widget.participant.name.isNotEmpty
                        ? '${widget.participant.name} (${widget.participant.identity})'
                        : widget.participant.identity,
                    audioAvailable: audioPublication?.muted == false && audioPublication?.subscribed == true,
                    connectionQuality: widget.participant.connectionQuality,
                    isScreenShare: isScreenShare,
                    enabledE2EE: widget.participant.isEncrypted,
                  ),
                ],
              ),
            ),
            if (widget.showStatsLayer)
              Positioned(
                  top: 130,
                  right: 30,
                  child: ParticipantStatsWidget(
                    participant: widget.participant,
                  )),
            if (activeAudioTrack != null && !activeAudioTrack!.muted)
              Positioned(
                top: 10,
                right: 10,
                left: 10,
                bottom: 10,
                child: SoundWaveformWidget(
                  key: ValueKey(activeAudioTrack!.hashCode),
                  audioTrack: activeAudioTrack!,
                  width: 8,
                ),
              ),
          ],
        ),
      );
}

class _LocalParticipantWidgetState extends _ParticipantWidgetState<LocalParticipantWidget> {
  @override
  LocalTrackPublication<LocalVideoTrack>? get videoPublication => widget.participant.videoTrackPublications
      .where((element) => element.source == widget.type.lkVideoSourceType)
      .firstOrNull;

  @override
  LocalTrackPublication<LocalAudioTrack>? get audioPublication => widget.participant.audioTrackPublications
      .where((element) => element.source == widget.type.lkAudioSourceType)
      .firstOrNull;

  @override
  VideoTrack? get activeVideoTrack => videoPublication?.track;

  @override
  AudioTrack? get activeAudioTrack => audioPublication?.track;
}

class _RemoteParticipantWidgetState extends _ParticipantWidgetState<RemoteParticipantWidget> {
  @override
  RemoteTrackPublication<RemoteVideoTrack>? get videoPublication => widget.participant.videoTrackPublications
      .where((element) => element.source == widget.type.lkVideoSourceType)
      .firstOrNull;

  @override
  RemoteTrackPublication<RemoteAudioTrack>? get audioPublication => widget.participant.audioTrackPublications
      .where((element) => element.source == widget.type.lkAudioSourceType)
      .firstOrNull;

  @override
  VideoTrack? get activeVideoTrack => videoPublication?.track;

  @override
  AudioTrack? get activeAudioTrack => audioPublication?.track;

  @override
  List<Widget> extraWidgets(bool isScreenShare) => [
        Row(
          mainAxisSize: MainAxisSize.max,
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            // Menu for RemoteTrackPublication<RemoteAudioTrack>
            if (audioPublication != null)
              RemoteTrackPublicationMenuWidget(
                pub: audioPublication!,
                icon: Icons.volume_up,
              ),
            // Menu for RemoteTrackPublication<RemoteVideoTrack>
            if (videoPublication != null)
              RemoteTrackPublicationMenuWidget(
                pub: videoPublication!,
                icon: isScreenShare ? Icons.monitor : Icons.videocam,
              ),
            if (videoPublication != null)
              RemoteTrackFPSMenuWidget(
                pub: videoPublication!,
                icon: Icons.menu,
              ),
            if (videoPublication != null)
              RemoteTrackQualityMenuWidget(
                pub: videoPublication!,
                icon: Icons.monitor_outlined,
              ),
          ],
        ),
      ];
}

class RemoteTrackPublicationMenuWidget extends StatelessWidget {
  final IconData icon;
  final RemoteTrackPublication pub;
  const RemoteTrackPublicationMenuWidget({
    required this.pub,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Material(
        color: Colors.black.withValues(alpha: 0.3),
        child: PopupMenuButton<Function>(
          tooltip: 'Subscribe menu',
          icon: Icon(icon,
              color: {
                TrackSubscriptionState.notAllowed: Colors.red,
                TrackSubscriptionState.unsubscribed: Colors.grey,
                TrackSubscriptionState.subscribed: Colors.green,
              }[pub.subscriptionState]),
          onSelected: (value) => value(),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<Function>>[
            // Subscribe/Unsubscribe
            if (pub.subscribed == false)
              PopupMenuItem(
                child: const Text('Subscribe'),
                value: () => pub.subscribe(),
              )
            else if (pub.subscribed == true)
              PopupMenuItem(
                child: const Text('Un-subscribe'),
                value: () => pub.unsubscribe(),
              ),
          ],
        ),
      );
}

class RemoteTrackFPSMenuWidget extends StatelessWidget {
  final IconData icon;
  final RemoteTrackPublication pub;
  const RemoteTrackFPSMenuWidget({
    required this.pub,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Material(
        color: Colors.black.withValues(alpha: 0.3),
        child: PopupMenuButton<Function>(
          tooltip: 'Preferred FPS',
          icon: Icon(icon, color: Colors.white),
          onSelected: (value) => value(),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<Function>>[
            PopupMenuItem(
              child: const Text('30'),
              value: () => pub.setVideoFPS(30),
            ),
            PopupMenuItem(
              child: const Text('15'),
              value: () => pub.setVideoFPS(15),
            ),
            PopupMenuItem(
              child: const Text('8'),
              value: () => pub.setVideoFPS(8),
            ),
          ],
        ),
      );
}

class RemoteTrackQualityMenuWidget extends StatelessWidget {
  final IconData icon;
  final RemoteTrackPublication pub;
  const RemoteTrackQualityMenuWidget({
    required this.pub,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Material(
        color: Colors.black.withValues(alpha: 0.3),
        child: PopupMenuButton<Function>(
          tooltip: 'Preferred Quality',
          icon: Icon(icon, color: Colors.white),
          onSelected: (value) => value(),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<Function>>[
            PopupMenuItem(
              child: const Text('HIGH'),
              value: () => pub.setVideoQuality(VideoQuality.HIGH),
            ),
            PopupMenuItem(
              child: const Text('MEDIUM'),
              value: () => pub.setVideoQuality(VideoQuality.MEDIUM),
            ),
            PopupMenuItem(
              child: const Text('LOW'),
              value: () => pub.setVideoQuality(VideoQuality.LOW),
            ),
          ],
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/widgets/participant_info.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';

enum ParticipantTrackType {
  kUserMedia,
  kScreenShare,
}

extension ParticipantTrackTypeExt on ParticipantTrackType {
  TrackSource get lkVideoSourceType => {
        ParticipantTrackType.kUserMedia: TrackSource.camera,
        ParticipantTrackType.kScreenShare: TrackSource.screenShareVideo,
      }[this]!;

  TrackSource get lkAudioSourceType => {
        ParticipantTrackType.kUserMedia: TrackSource.microphone,
        ParticipantTrackType.kScreenShare: TrackSource.screenShareAudio,
      }[this]!;
}

class ParticipantTrack {
  ParticipantTrack({required this.participant, this.type = ParticipantTrackType.kUserMedia});
  Participant participant;
  final ParticipantTrackType type;
}

class ParticipantInfoWidget extends StatelessWidget {
  final String? title;
  final bool audioAvailable;
  final ConnectionQuality connectionQuality;
  final bool isScreenShare;
  final bool enabledE2EE;

  const ParticipantInfoWidget({
    this.title,
    this.audioAvailable = true,
    this.connectionQuality = ConnectionQuality.unknown,
    this.isScreenShare = false,
    this.enabledE2EE = false,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Container(
        color: Colors.black.withValues(alpha: 0.3),
        padding: const EdgeInsets.symmetric(
          vertical: 7,
          horizontal: 10,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.end,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            if (title != null)
              Flexible(
                child: Text(
                  title!,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            isScreenShare
                ? const Padding(
                    padding: EdgeInsets.only(left: 5),
                    child: Icon(
                      Icons.monitor,
                      color: Colors.white,
                      size: 16,
                    ),
                  )
                : Padding(
                    padding: const EdgeInsets.only(left: 5),
                    child: Icon(
                      audioAvailable ? Icons.mic : Icons.mic_off,
                      color: audioAvailable ? Colors.white : Colors.red,
                      size: 16,
                    ),
                  ),
            if (connectionQuality != ConnectionQuality.unknown)
              Padding(
                padding: const EdgeInsets.only(left: 5),
                child: Icon(
                  connectionQuality == ConnectionQuality.poor ? Icons.wifi_off_outlined : Icons.wifi,
                  color: {
                    ConnectionQuality.excellent: Colors.green,
                    ConnectionQuality.good: Colors.orange,
                    ConnectionQuality.poor: Colors.red,
                  }[connectionQuality],
                  size: 16,
                ),
              ),
            Padding(
              padding: const EdgeInsets.only(left: 5),
              child: Icon(
                enabledE2EE ? Icons.lock : Icons.lock_open,
                color: enabledE2EE ? Colors.green : Colors.red,
                size: 16,
              ),
            ),
          ],
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/widgets/participant_stats.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import 'dart:async';

enum StatsType {
  kUnknown,
  kLocalAudioSender,
  kLocalVideoSender,
  kRemoteAudioReceiver,
  kRemoteVideoReceiver,
}

class ParticipantStatsWidget extends StatefulWidget {
  const ParticipantStatsWidget({super.key, required this.participant});
  final Participant participant;
  @override
  State<StatefulWidget> createState() => _ParticipantStatsWidgetState();
}

class _ParticipantStatsWidgetState extends State<ParticipantStatsWidget> {
  List<EventsListener<TrackEvent>> listeners = [];
  StatsType statsType = StatsType.kUnknown;
  Map<String, Map<String, String>> stats = {'audio': {}, 'video': {}};

  void _setUpListener(Track track) {
    final listener = track.createListener();
    listeners.add(listener);
    if (track is LocalVideoTrack) {
      statsType = StatsType.kLocalVideoSender;
      listener.on<VideoSenderStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          stats['tx'] = 'total sent ${event.currentBitrate.toInt()} kpbs';
          event.stats.forEach((key, value) {
            stats['layer-$key'] =
                '${value.frameWidth ?? 0}x${value.frameHeight ?? 0} ${value.framesPerSecond?.toDouble() ?? 0} fps, ${event.bitrateForLayers[key] ?? 0} kbps';
          });
          final firstStats = event.stats['f'] ?? event.stats['h'] ?? event.stats['q'];
          if (firstStats != null) {
            stats['encoder'] = firstStats.encoderImplementation ?? '';
            if (firstStats.mimeType != null) {
              stats['codec'] = '${firstStats.mimeType!.split('/')[1]}/${firstStats.clockRate}';
            }
            stats['payload'] = '${firstStats.payloadType}';
            stats['qualityLimitationReason'] = firstStats.qualityLimitationReason ?? '';
          }

          this.stats['video']!.addEntries(stats.entries);
        });
      });
    } else if (track is RemoteVideoTrack) {
      statsType = StatsType.kRemoteVideoReceiver;
      listener.on<VideoReceiverStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          if (!event.currentBitrate.isNaN) {
            stats['rx'] = '${event.currentBitrate.toInt()} kpbs';
          }
          if (event.stats.mimeType != null) {
            stats['codec'] = '${event.stats.mimeType!.split('/')[1]}/${event.stats.clockRate}';
          }
          stats['payload'] = '${event.stats.payloadType}';
          stats['size/fps'] =
              '${event.stats.frameWidth}x${event.stats.frameHeight} ${event.stats.framesPerSecond?.toDouble()}fps';
          stats['jitter'] = '${event.stats.jitter} s';
          stats['decoder'] = '${event.stats.decoderImplementation}';
          //stats['video packets lost'] = '${event.stats.packetsLost}';
          //stats['video packets received'] = '${event.stats.packetsReceived}';
          stats['frames received'] = '${event.stats.framesReceived}';
          stats['frames decoded'] = '${event.stats.framesDecoded}';
          stats['frames dropped'] = '${event.stats.framesDropped}';

          this.stats['video']!.addEntries(stats.entries);
        });
      });
    } else if (track is LocalAudioTrack) {
      statsType = StatsType.kLocalAudioSender;
      listener.on<AudioSenderStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          stats['tx'] = '${event.currentBitrate.toInt()} kpbs';
          if (event.stats.mimeType != null) {
            stats['codec'] = '${event.stats.mimeType!.split('/')[1]}/${event.stats.clockRate}/${event.stats.channels}';
          }
          stats['payload'] = '${event.stats.payloadType}';
          this.stats['audio']!.addEntries(stats.entries);
        });
      });
    } else if (track is RemoteAudioTrack) {
      statsType = StatsType.kRemoteAudioReceiver;
      listener.on<AudioReceiverStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          stats['rx'] = '${event.currentBitrate.toInt()} kpbs';
          if (event.stats.mimeType != null) {
            stats['codec'] = '${event.stats.mimeType!.split('/')[1]}/${event.stats.clockRate}/${event.stats.channels}';
          }
          stats['payload'] = '${event.stats.payloadType}';
          stats['jitter'] = '${event.stats.jitter} s';
          //stats['concealed samples'] =
          //    '${event.stats.concealedSamples} / ${event.stats.concealmentEvents}';
          stats['packets lost'] = '${event.stats.packetsLost}';
          stats['packets received'] = '${event.stats.packetsReceived}';

          this.stats['audio']!.addEntries(stats.entries);
        });
      });
    }
  }

  _onParticipantChanged() {
    for (var element in listeners) {
      unawaited(element.dispose());
    }
    listeners.clear();
    for (var track in [...widget.participant.videoTrackPublications, ...widget.participant.audioTrackPublications]) {
      if (track.track != null) {
        _setUpListener(track.track!);
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.participant.addListener(_onParticipantChanged);
    // trigger initial change
    _onParticipantChanged();
  }

  @override
  void deactivate() {
    for (var element in listeners) {
      unawaited(element.dispose());
    }
    widget.participant.removeListener(_onParticipantChanged);
    super.deactivate();
  }

  num sendBitrate = 0;

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black.withValues(alpha: 0.3),
      padding: const EdgeInsets.symmetric(
        vertical: 8,
        horizontal: 8,
      ),
      child: Column(children: [
        const Text('audio stats', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        ...stats['audio']!.entries.map((e) => Text('${e.key}: ${e.value}')),
        const Text('video stats', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        ...stats['video']!.entries.map((e) => Text('${e.key}: ${e.value}')),
      ]),
    );
  }
}



FICHIER: flutter_lib/features/tables/presentation/widgets/sound_waveform.dart
--------------------------------------------------------------------------------
/*
 * Copyright 2024 LiveKit, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * [SoundWaveformWidget] Originally adapted from: https://github.com/SushanShakya/sound_waveform
 *
 * MIT License
 *
 * Copyright (c) 2022 Sushan Shakya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import 'dart:async';

class SoundWaveformWidget extends StatefulWidget {
  final int barCount;
  final double width;
  final double minHeight;
  final double maxHeight;
  final int durationInMilliseconds;
  const SoundWaveformWidget({
    super.key,
    required this.audioTrack,
    this.barCount = 5,
    this.width = 5,
    this.minHeight = 8,
    this.maxHeight = 100,
    this.durationInMilliseconds = 500,
  });
  final AudioTrack audioTrack;
  @override
  State<SoundWaveformWidget> createState() => _SoundWaveformWidgetState();
}

class _SoundWaveformWidgetState extends State<SoundWaveformWidget> with TickerProviderStateMixin {
  late AnimationController controller;
  late List<double> samples;
  AudioVisualizer? _visualizer;
  EventsListener<AudioVisualizerEvent>? _listener;

  Future<void> _startVisualizer(AudioTrack track) async {
    samples = List.filled(widget.barCount, 0);
    _visualizer ??= createVisualizer(track, options: AudioVisualizerOptions(barCount: widget.barCount));
    _listener ??= _visualizer?.createListener();
    _listener?.on<AudioVisualizerEvent>((e) {
      if (mounted) {
        setState(() {
          samples = e.event.map((e) => ((e as num) * 100).toDouble()).toList();
        });
      }
    });

    await _visualizer!.start();
  }

  void _stopVisualizer(AudioTrack track) async {
    await _visualizer?.stop();
    await _visualizer?.dispose();
    _visualizer = null;
    await _listener?.dispose();
    _listener = null;
  }

  @override
  void initState() {
    super.initState();

    unawaited(_startVisualizer(widget.audioTrack));

    controller = AnimationController(
        vsync: this,
        duration: Duration(
          milliseconds: widget.durationInMilliseconds,
        ))
      ..repeat(); // ignore: discarded_futures
  }

  @override
  void dispose() {
    controller.dispose();
    _stopVisualizer(widget.audioTrack);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final count = widget.barCount;
    final minHeight = widget.minHeight;
    final maxHeight = widget.maxHeight;
    return AnimatedBuilder(
      animation: controller,
      builder: (c, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(
            count,
            (i) => AnimatedContainer(
              duration: Duration(milliseconds: widget.durationInMilliseconds ~/ count),
              margin: i == (samples.length - 1) ? EdgeInsets.zero : const EdgeInsets.only(right: 5),
              height: samples[i] < minHeight
                  ? minHeight
                  : samples[i] > maxHeight
                      ? maxHeight
                      : samples[i],
              width: widget.width,
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(9999),
              ),
            ),
          ),
        );
      },
    );
  }
}



FICHIER: flutter_lib/features/tables/presentation/widgets/text_field.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';

class LKTextField extends StatelessWidget {
  final String label;
  final TextEditingController? ctrl;
  const LKTextField({
    required this.label,
    this.ctrl,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 10),
            child: Text(
              label,
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(
              vertical: 15,
              horizontal: 15,
            ),
            decoration: BoxDecoration(
              border: Border.all(
                width: 1,
                color: Colors.white.withValues(alpha: .3),
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: TextField(
              controller: ctrl,
              decoration: const InputDecoration.collapsed(
                hintText: '',
              ),
              keyboardType: TextInputType.url,
              autocorrect: false,
            ),
          ),
        ],
      );
}



FICHIER: flutter_lib/providers/auth_provider.dart
--------------------------------------------------------------------------------
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../services/api_service.dart';
import '../services/auth_service.dart';

// Provider pour FlutterSecureStorage (sÃ©parÃ© pour Ã©viter les dÃ©pendances circulaires)
final secureStorageProvider = Provider<FlutterSecureStorage>((ref) {
  return const FlutterSecureStorage();
});

// Provider pour Dio
final dioProvider = Provider<Dio>((ref) {
  return Dio();
});

// Provider pour ApiService (sans rÃ©fÃ©rence Ã  authStateNotifierProvider)
final apiServiceProvider = Provider<ApiService>((ref) {
  final dio = ref.watch(dioProvider);
  final storage = ref.watch(secureStorageProvider);
  return ApiService(dio: dio, storage: storage);
});

// Provider pour AuthService
final authServiceProvider = Provider<AuthService>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthService(
    onAuthenticationEvent: (event) async {
      print('Authentication event: $event');
    },
    onAuthenticationError: (error) async {
      print('Authentication error: $error');
    },
    apiService: apiService,
  );
});

// Stream provider pour les changements d'Ã©tat Firebase
final authStateProvider = StreamProvider<User?>((ref) {
  final authService = ref.watch(authServiceProvider);
  return authService.authStateChanges;
});

// Provider pour l'utilisateur courant Firebase
final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authServiceProvider).currentUser;
});

// Provider pour rÃ©cupÃ©rer le JWT applicatif (version FutureProvider)
final appJwtProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getAppJwt();
});

// Provider pour rÃ©cupÃ©rer le refresh token
final refreshTokenProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getRefreshToken();
});

// ============================================================
// GESTION COMPLÃˆTE DE L'AUTH
// ============================================================

// Enum pour les diffÃ©rents statuts d'authentification
enum AuthStatus {
  initial,           // Non connectÃ©
  authenticated,     // Firebase OK mais JWT en cours
  fullyAuthenticated, // Firebase + JWT OK
  error,             // Erreur
}

// Classe reprÃ©sentant l'Ã©tat d'authentification complet
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? jwtToken;
  final String? refreshToken;
  final Object? error;

  const AuthState({
    required this.status,
    this.user,
    this.jwtToken,
    this.refreshToken,
    this.error,
  });

  static const AuthState initial = AuthState(status: AuthStatus.initial);

  const AuthState.authenticated(User user) : this(
    status: AuthStatus.authenticated,
    user: user,
  );

  const AuthState.fullyAuthenticated({
    required User user,
    required String jwtToken,
    String? refreshToken,
  }) : this(
    status: AuthStatus.fullyAuthenticated,
    user: user,
    jwtToken: jwtToken,
    refreshToken: refreshToken,
  );

  const AuthState.error(Object error) : this(
    status: AuthStatus.error,
    error: error,
  );

  // MÃ©thodes utilitaires
  bool get isFullyAuthenticated => status == AuthStatus.fullyAuthenticated;
  bool get isAuthenticated => status == AuthStatus.authenticated || status == AuthStatus.fullyAuthenticated;
  bool get isInitial => status == AuthStatus.initial;
  bool get hasError => status == AuthStatus.error;

  // MÃ©thode copyWith
  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? jwtToken,
    String? refreshToken,
    Object? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      jwtToken: jwtToken ?? this.jwtToken,
      refreshToken: refreshToken ?? this.refreshToken,
      error: error ?? this.error,
    );
  }

  @override
  String toString() {
    return 'AuthState(status: $status, user: ${user?.uid ?? 'null'}, hasJwt: ${jwtToken != null}, hasRefresh: ${refreshToken != null})';
  }
}

// StateNotifier pour gÃ©rer l'Ã©tat d'authentification complet
class AuthStateNotifier extends StateNotifier<AuthState> {
  final AuthService _authService;
  final Ref _ref;
  StreamSubscription<User?>? _authSubscription;

  AuthStateNotifier({
    required AuthService authService,
    required Ref ref,
  }) : _authService = authService,
        _ref = ref,
        super(AuthState.initial) {
    _init();
  }

  Future<void> _init() async {
    print('ğŸŸ¡ [NOTIFIER] Initialisation...');

    // Configurer le callback unauthorized dans ApiService APRÃˆS la crÃ©ation
    // Mais on ne peut pas le faire ici car Ã§a crÃ©erait une dÃ©pendance circulaire
    // On va plutÃ´t le faire depuis le main ou depuis un provider sÃ©parÃ©

    // Ã‰couter DIRECTEMENT le stream Firebase Auth (plus fiable)
    _authSubscription = _authService.authStateChanges.listen(
          (user) {
        print('ğŸ”µ [NOTIFIER] Firebase Auth State Change: ${user?.uid ?? 'null'}');

        if (user != null) {
          print('âœ… [NOTIFIER] Utilisateur Firebase connectÃ©');
          state = AuthState.authenticated(user);
          _checkTokens(user);
        } else {
          print('âŒ [NOTIFIER] Utilisateur Firebase DÃ‰CONNECTÃ‰ - RÃ©initialisation');
          state = AuthState.initial;
        }
      },
      onError: (error) {
        print('âŒ [NOTIFIER] Erreur auth stream: $error');
        state = AuthState.error(error);
      },
    );

    // Garder le listener du provider pour compatibilitÃ©
    _ref.listen(authStateProvider, (previous, next) {
      next.whenData((user) {
        print('ğŸŸ¡ [PROVIDER] authStateProvider: ${user?.uid ?? 'null'}');
      });
    });

    // Ã‰couter les Ã©vÃ©nements d'authentification
    _authService.onAuthenticationEvent = (event) async {
      if (event is GoogleSignInAuthenticationEventSignIn) {
        print('ğŸ“¡ [NOTIFIER] Ã‰vÃ©nement d\'authentification reÃ§u');

        const maxAttempts = 10;
        var attempts = 0;
        String? jwt;
        String? refreshToken;

        while (attempts < maxAttempts) {
          await Future.delayed(const Duration(milliseconds: 300));
          jwt = await _authService.getAppJwt();
          refreshToken = await _authService.getRefreshToken();
          if (jwt != null && jwt.isNotEmpty) {
            break;
          }
          attempts++;
        }

        final user = _authService.currentUser;

        if (jwt != null && jwt.isNotEmpty && user != null) {
          state = AuthState.fullyAuthenticated(
            user: user,
            jwtToken: jwt,
            refreshToken: refreshToken,
          );
          print('âœ… [NOTIFIER] Authentification complÃ¨te (Firebase + JWT)');
        } else if (user != null) {
          state = AuthState.authenticated(user);
          print('âš ï¸ [NOTIFIER] Firebase authentifiÃ© mais JWT manquant');
        }
      }
    };

    // Ã‰couter les erreurs d'authentification
    _authService.onAuthenticationError = (error) async {
      state = AuthState.error(error);
      print('âŒ [NOTIFIER] Erreur d\'authentification: $error');
    };
  }

  Future<void> _checkTokens(User user) async {
    try {
      final existingJwt = await _authService.getAppJwt();
      final existingRefresh = await _authService.getRefreshToken();

      if (existingJwt != null && existingJwt.isNotEmpty) {
        state = AuthState.fullyAuthenticated(
          user: user,
          jwtToken: existingJwt,
          refreshToken: existingRefresh,
        );
        print('âœ… [NOTIFIER] Tokens dÃ©jÃ  prÃ©sents');
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur vÃ©rification tokens: $e');
    }
  }

  /*
  // Nouvelle mÃ©thode pour gÃ©rer les erreurs 401
  Future<void> handleUnauthorized() async {
    print('âš ï¸ [NOTIFIER] Erreur 401 - Tentative de refresh token...');

    try {
      final newToken = await _authService.refreshJwtToken();

      if (newToken != null && state.user != null) {
        final refreshToken = await _authService.getRefreshToken();
        state = AuthState.fullyAuthenticated(
          user: state.user!,
          jwtToken: newToken,
          refreshToken: refreshToken,
        );
        print('âœ… [NOTIFIER] Token rafraÃ®chi avec succÃ¨s');
      } else {
        // Impossible de rafraÃ®chir, dÃ©connexion
        print('âŒ [NOTIFIER] Ã‰chec du refresh - DÃ©connexion');
        await signOut();
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur handleUnauthorized: $e');
      await signOut();
    }
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ [NOTIFIER] signOut() appelÃ©');

    try {
      state = AuthState.initial;
      await _authService.signOut();

      final userAfter = _authService.currentUser;
      print('ğŸ‘¤ [NOTIFIER] Utilisateur aprÃ¨s service.signOut(): ${userAfter?.uid ?? 'null'}');

      await Future.delayed(const Duration(milliseconds: 200));

      if (_authService.currentUser != null) {
        print('âš ï¸ [NOTIFIER] Utilisateur toujours connectÃ© - tentative de force');
        await _authService.forceSignOut();
        state = AuthState.initial;
      }

      print('âœ… [NOTIFIER] signOut() terminÃ©');
    } catch (e, stack) {
      print('âŒ [NOTIFIER] Erreur signOut: $e');
      print('ğŸ“š [NOTIFIER] Stack: $stack');
      state = AuthState.initial;
      rethrow;
    }
  }

  // MÃ©thode pour rÃ©initialiser manuellement l'Ã©tat
  void reset() {
    print('ğŸŸ¡ [NOTIFIER] reset() appelÃ©');
    state = AuthState.initial;
  }

  // MÃ©thode pour forcer une erreur
  void setError(Object error) {
    print('âŒ [NOTIFIER] setError(): $error');
    state = AuthState.error(error);
  }

  @override
  void dispose() {
    _authSubscription?.cancel();
    super.dispose();
  }
}

// StateNotifierProvider
final authStateNotifierProvider = StateNotifierProvider<AuthStateNotifier, AuthState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return AuthStateNotifier(
    authService: authService,
    ref: ref,
  );
});

// Providers utilitaires
final isFullyAuthenticatedProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.isFullyAuthenticated;
});

final appJwtSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.jwtToken;
});

final refreshTokenSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.refreshToken;
});

final currentUserSyncProvider = Provider<User?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.user;
});

final isAuthenticatingProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.status == AuthStatus.authenticated;
});

final authErrorProvider = Provider<Object?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.error;
});

/*
// Provider sÃ©parÃ© pour configurer le callback unauthorized (Ã  utiliser dans main.dart)
final unauthorizedCallbackProvider = Provider<void Function()>((ref) {
  return () {
    // Cette fonction sera appelÃ©e quand une erreur 401 non rÃ©cupÃ©rable survient
    ref.read(authStateNotifierProvider.notifier).handleUnauthorized();
  };
});

 */


FICHIER: flutter_lib/services/api_service.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:developer';
import 'dart:ui';

import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'api_service.g.dart';

class ApiException implements Exception {
  final String message;
  final int? statusCode;
  final dynamic originalError;

  ApiException({
    required this.message,
    this.statusCode,
    this.originalError,
  });

  @override
  String toString() => 'ApiException: $message (Status: $statusCode)';
}

class ApiService {
  final Dio _dio;
  final FlutterSecureStorage _storage;
  static const _baseUrl = 'http://192.168.1.56:8101/api';

  // Callback pour la dÃ©connexion en cas d'Ã©chec de refresh
  VoidCallback? onUnauthorized;

  ApiService({
    required Dio dio,
    required FlutterSecureStorage storage,
  })  : _dio = dio,
        _storage = storage {
    _dio.options.baseUrl = _baseUrl;
    _dio.options.headers['accept'] = 'application/json';
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.connectTimeout = const Duration(seconds: 10);
    _dio.options.receiveTimeout = const Duration(seconds: 10);

    _dio.interceptors.add(LogInterceptor(requestBody: true, responseBody: true));

    // Ajouter l'intercepteur pour le refresh token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {

          print("******************* ON REQUEST *******************************");
          print(options.path);


          // Ne pas ajouter le token pour les endpoints d'auth
          // if (!options.path.contains('/auth/refresh') &&
          if (!options.path.contains('/auth/refresh') &&
          // if (
              !options.path.contains('/auth/login') &&
              !options.path.contains('/users/jwt-by-firebase-token')) {

            print("******************* TEST 1 *******************************");

            final token = await _storage.read(key: 'app_jwt_token');

            print("******************* TEST 2 *******************************");
            // print(token);

            if (token != null) {
              print("******************* TEST 3 *******************************");
              options.headers['Authorization'] = 'Bearer $token';
            }
          }

          print("******************* ON REQUEST END *******************************");
          log(options.headers['Authorization'].toString());

          return handler.next(options);
        },
        onError: (error, handler) async {
          // Si erreur 401 et que ce n'est pas dÃ©jÃ  une tentative de refresh
          if (error.response?.statusCode == 401 &&
              !error.requestOptions.path.contains('/auth/refresh')) {

            try {
              // Tenter de rafraÃ®chir le token
              final newToken = await _refreshToken();
              // final refreshToken = await _storage.read(key: 'refresh_token');
              // final newToken = await refreshJwtToken(refreshToken.toString());

              if (newToken != null) {
                // Rejouer la requÃªte originale avec le nouveau token
                final options = error.requestOptions;
                options.headers['Authorization'] = 'Bearer $newToken';

                final response = await _dio.fetch(options);
                return handler.resolve(response);
              }
            } catch (refreshError) {
              print('âŒ Erreur lors du refresh: $refreshError');
            }

            // Si le refresh Ã©choue, notifier pour dÃ©connecter l'utilisateur
            if (onUnauthorized != null) {
              onUnauthorized!();
            }
          }

          return handler.next(error);
        },
      ),
    );
  }

  bool _isRefreshing = false;
  final List<Completer<String?>> _refreshCompleters = [];

  Future<String?> _refreshToken() async {
    if (_isRefreshing) {
      // Si un refresh est dÃ©jÃ  en cours, attendre son rÃ©sultat
      final completer = Completer<String?>();
      _refreshCompleters.add(completer);
      return completer.future;
    }

    _isRefreshing = true;
    final completer = Completer<String?>();
    _refreshCompleters.add(completer);

    try {
      final refreshToken = await _storage.read(key: 'refresh_token');

      if (refreshToken == null) {
        throw Exception('No refresh token');
      }

      final appJwtToken = await _storage.read(key: 'app_jwt_token');

      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
          extra: {'noToken': true},
          headers: {'Authorization': 'Bearer $appJwtToken'}

        ),
      );

      if (response.statusCode == 200) {
        final newToken = response.data['token'];
        final newRefreshToken = response.data['refresh_token'];

        await _storage.write(key: 'app_jwt_token', value: newToken);
        if (newRefreshToken != null) {
          await _storage.write(key: 'refresh_token', value: newRefreshToken);
        }

        // RÃ©soudre tous les completer en attente
        for (final c in _refreshCompleters) {
          c.complete(newToken);
        }

        return newToken;
      }
    } catch (e) {
      print('âŒ Erreur refresh token: $e');
      // En cas d'erreur, Ã©chouer tous les completer
      for (final c in _refreshCompleters) {
        c.completeError(e);
      }
    } finally {
      _isRefreshing = false;
      _refreshCompleters.clear();
    }

    return null;
  }

  // MÃ©thode gÃ©nÃ©rique pour gÃ©rer les requÃªtes avec gestion d'erreur centralisÃ©e
  Future<T> safeApiCall<T>({
    required Future<T> Function() apiCall,
    String? errorMessage,
  }) async {
    try {
      return await apiCall();
    } on DioException catch (e) {
      throw _handleDioError(e, errorMessage);
    } catch (e) {
      throw ApiException(
        message: errorMessage ?? 'Une erreur inattendue est survenue',
        originalError: e,
      );
    }
  }

  ApiException _handleDioError(DioException e, String? customMessage) {
    String message;
    int? statusCode = e.response?.statusCode;

    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        message = 'DÃ©lai de connexion dÃ©passÃ©';
        break;
      case DioExceptionType.badResponse:
        message = _parseErrorResponse(e.response);
        break;
      case DioExceptionType.cancel:
        message = 'RequÃªte annulÃ©e';
        break;
      case DioExceptionType.connectionError:
        message = 'Erreur de connexion rÃ©seau';
        break;
      default:
        message = customMessage ?? 'Erreur rÃ©seau inconnue';
    }

    return ApiException(
      message: message,
      statusCode: statusCode,
      originalError: e,
    );
  }

  String _parseErrorResponse(Response? response) {
    try {
      if (response?.data != null && response!.data is Map) {
        return response.data['message'] ??
            response.data['error'] ??
            'Erreur serveur (${response.statusCode})';
      }
      return 'Erreur serveur (${response?.statusCode ?? 'inconnue'})';
    } catch (_) {
      return 'Erreur serveur inconnue';
    }
  }

  // MÃ©thodes API spÃ©cifiques
  Future<Map<String, dynamic>> getJwtFromFirebaseToken(String firebaseToken) async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.post(
          '/users/jwt-by-firebase-token',
          data: {'token': firebaseToken},
          options: Options(extra: {'noToken': true}),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la rÃ©cupÃ©ration du JWT',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le token JWT',
    );
  }

  /*
  // Nouvelle mÃ©thode pour rafraÃ®chir le token
  Future<Map<String, dynamic>?> refreshJwtToken(String refreshToken) async {
    try {
      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(extra: {'noToken': true}),
      );

      if (response.statusCode == 200) {
        return response.data as Map<String, dynamic>;
      }
    } catch (e) {
      print('âŒ Erreur refresh token API: $e');
    }
    return null;
  }

   */

  // Nouvelle mÃ©thode pour rÃ©voquer le refresh token (logout)
  Future<void> revokeRefreshToken(String refreshToken) async {
    try {
      final token = await _storage.read(key: 'app_jwt_token');
      await _dio.post(
        '/auth/logout',
        data: {'refresh_token': refreshToken},
        options: Options(
          headers: token != null ? {'Authorization': 'Bearer $token'} : {},
          extra: {'noToken': true},
        ),
      );
    } catch (e) {
      print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
    }
  }

  Future<Map<String, dynamic>> generateLiveKitToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return safeApiCall(
      apiCall: () async {
        final payload = {
          "participant_identity": participantIdentity,
          "participant_name": participantName,
          "participant_metadata": participantMetadata,
          "participant_attributes": participantAttributes,
          "room_name": roomName,
          "room_config": roomConfig
        };

        final appJwt = await _storage.read(key: 'app_jwt_token');

        if (appJwt == null) {
          throw ApiException(message: 'JWT token non disponible');
        }

        final response = await _dio.post(
          '/sfu/generate-token',
          data: payload,
          options: Options(
            headers: {
              'Authorization': 'Bearer $appJwt',
            },
          ),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la gÃ©nÃ©ration du token LiveKit',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de gÃ©nÃ©rer le token LiveKit',
    );
  }
}

@riverpod
ApiService apiService(Ref ref) {
  final dio = Dio();
  final storage = const FlutterSecureStorage();
  return ApiService(dio: dio, storage: storage);
}


FICHIER: flutter_lib/services/api_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'api_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(apiService)
final apiServiceProvider = ApiServiceProvider._();

final class ApiServiceProvider
    extends $FunctionalProvider<ApiService, ApiService, ApiService>
    with $Provider<ApiService> {
  ApiServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'apiServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$apiServiceHash();

  @$internal
  @override
  $ProviderElement<ApiService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  ApiService create(Ref ref) {
    return apiService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ApiService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ApiService>(value),
    );
  }
}

String _$apiServiceHash() => r'eb9a66cc54e1c15d5870b8da260d4ea1f6b053ac';



FICHIER: flutter_lib/services/auth_service.dart
--------------------------------------------------------------------------------
import 'dart:developer';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'api_service.dart';

class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final ApiService _apiService;

  final _storage = const FlutterSecureStorage();

  static const _tokenKey = 'firebase_id_token';
  static const _appJwtKey = 'app_jwt_token';
  static const _refreshTokenKey = 'refresh_token';
  static const _userIdentityKey = 'connected_user_identity';
  static const _userDisplayNameKey = 'connected_user_displayname';

  Future<void> Function(GoogleSignInAuthenticationEvent)? onAuthenticationEvent;
  Future<void> Function(Object)? onAuthenticationError;

  AuthService({
    this.onAuthenticationEvent,
    this.onAuthenticationError,
    required ApiService apiService,
  }) : _apiService = apiService;

  User? get currentUser => _firebaseAuth.currentUser;

  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

  bool _isSignInInitialized = false;

  String? clientId;
  String? serverClientId = '1084343369802-36565dmgarm2gkos54eb6j9q6so0s9bf.apps.googleusercontent.com';
  List<String> scopes = <String>[
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
  ];
  final GoogleSignIn signIn = GoogleSignIn.instance;

  Future<void> _handleAuthenticationEvent(GoogleSignInAuthenticationEvent event) async {
    final GoogleSignInAccount? user = switch (event) {
      GoogleSignInAuthenticationEventSignIn() => event.user,
      GoogleSignInAuthenticationEventSignOut() => null,
    };

    final GoogleSignInClientAuthorization? authorization = await user?.authorizationClient.authorizationForScopes(scopes);

    if (user != null && authorization != null) {
      print(user);
      print("===== user =======");

      try {
        final OAuthCredential googleCredential = GoogleAuthProvider.credential(
          accessToken: authorization.accessToken,
          idToken: user.authentication.idToken,
        );

        final UserCredential googleUserCredential = await FirebaseAuth.instance.signInWithCredential(googleCredential);

        IdTokenResult tokenResult = await FirebaseAuth.instance.currentUser!.getIdTokenResult();

        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        log(tokenResult.token.toString());

        if (tokenResult.token != null) {
          await _storage.write(key: _tokenKey, value: tokenResult.token);
          await _storage.write(key: _userIdentityKey, value: user.displayName);
          await _storage.write(key: _userDisplayNameKey, value: user.displayName);

          try {
            print('ğŸ”„ RÃ©cupÃ©ration du JWT applicatif... =======================================');
            final response = await _apiService.getJwtFromFirebaseToken(tokenResult.token!);

            // La rÃ©ponse contient maintenant jwt ET refresh_token
            if (response is Map<String, dynamic>) {
              print('TOKEN ==============');
              log('***** from firebase token : ' + response['token'].toString());
              await _storage.write(key: _appJwtKey, value: response['token']);
              if (response['refresh_token'] != null) {
                print('REFRESH TOKEN ==============');
                print(response['refresh_token']);
                await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
              }
            } else {
              // Pour compatibilitÃ© avec l'ancien format
              await _storage.write(key: _appJwtKey, value: response.toString());
            }

            print('âœ… JWT applicatif rÃ©cupÃ©rÃ© et stockÃ©');
          } catch (e) {
            print('âŒ Erreur lors de la rÃ©cupÃ©ration du JWT applicatif: $e');
          }

          if (onAuthenticationEvent != null) {
            await onAuthenticationEvent!(event);
          }

          print(tokenResult.token);
          print("====== tokenResult.token =======");
        }
      } catch (error) {
        print(error);
        print('error');

        if (onAuthenticationError != null) {
          await onAuthenticationError!(error);
        }
      }
    }
  }

  Future<void> _handleAuthenticationError(Object e) async {
    print(e);
    if (onAuthenticationError != null) {
      await onAuthenticationError!(e);
    }
  }

  Future<void> initGoogleSignIn() async {
    if (_isSignInInitialized) return;

    _isSignInInitialized = true;

    await signIn.initialize(clientId: clientId, serverClientId: serverClientId).then((_) async {
      signIn.authenticationEvents.listen(_handleAuthenticationEvent).onError(_handleAuthenticationError);
    });
  }

  Future<User?> signInWithGoogle() async {
    await initGoogleSignIn();

    if (GoogleSignIn.instance.supportsAuthenticate()) {
      try {
        await GoogleSignIn.instance.authenticate();
      } catch (e) {
        print("Erreur Google Sign-In : $e");
      }
    }
  }

  Future<String?> getAppJwt() async {
    return await _storage.read(key: _appJwtKey);
  }

  Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }

  /*
  // Nouvelle mÃ©thode pour rafraÃ®chir le token
  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ DÃ‰BUT DÃ‰CONNEXION - Utilisateur avant: ${_firebaseAuth.currentUser?.uid}');

    try {
      // 1. RÃ©voquer le refresh token cÃ´tÃ© serveur
      final refreshToken = await getRefreshToken();
      if (refreshToken != null) {
        try {
          await _apiService.revokeRefreshToken(refreshToken);
          print('âœ… Refresh token rÃ©voquÃ© cÃ´tÃ© serveur');
        } catch (e) {
          print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
        }
      }

      // 2. DÃ©connexion Google
      await GoogleSignIn.instance.signOut();

      // 3. DÃ©connexion Firebase
      print('ğŸŸ¡ DÃ©connexion Firebase...');
      await _firebaseAuth.signOut();
      print('âœ… Firebase signOut() exÃ©cutÃ©');

      // 4. VÃ©rification post-dÃ©connexion
      final userAfter = _firebaseAuth.currentUser;
      print('ğŸ‘¤ Utilisateur aprÃ¨s Firebase.signOut(): $userAfter');

      // 5. Attendre un cycle d'event loop pour propager le changement
      await Future.delayed(const Duration(milliseconds: 100));

      // 6. Nettoyer le stockage
      print('ğŸŸ¡ Nettoyage du stockage...');
      await _storage.delete(key: _tokenKey);
      await _storage.delete(key: _appJwtKey);
      await _storage.delete(key: _refreshTokenKey);
      await _storage.delete(key: _userIdentityKey);
      await _storage.delete(key: _userDisplayNameKey);
      print('âœ… Stockage nettoyÃ©');

      // 7. VÃ©rification finale
      final finalUser = _firebaseAuth.currentUser;
      if (finalUser != null) {
        print('âš ï¸ ATTENTION: Utilisateur toujours prÃ©sent aprÃ¨s dÃ©connexion!');
        await forceSignOut();
      } else {
        print('âœ… Utilisateur bien null aprÃ¨s dÃ©connexion');
      }

      print('âœ… DÃ‰CONNEXION TERMINÃ‰E');
    } catch (e, stack) {
      print('âŒ ERREUR DÃ‰CONNEXION: $e');
      print('ğŸ“š Stack: $stack');
      rethrow;
    }
  }

  // MÃ©thode utilitaire pour forcer une dÃ©connexion radicale
  Future<void> forceSignOut() async {
    print('ğŸ”´ FORCE SIGN OUT - MÃ©thode radicale');

    try {
      await _firebaseAuth.signOut();
      await GoogleSignIn.instance.signOut();
      await _storage.deleteAll();
      await Future.delayed(const Duration(milliseconds: 200));
      print('âœ… Force sign out exÃ©cutÃ©');
      print('ğŸ‘¤ Utilisateur aprÃ¨s force: ${_firebaseAuth.currentUser?.uid ?? 'null'}');
    } catch (e) {
      print('âŒ Erreur force sign out: $e');
    }
  }

  bool isLoggedIn() {
    return _firebaseAuth.currentUser != null;
  }

  Future<bool> isUserLoggedIn() async {
    return _firebaseAuth.currentUser != null;
  }
}


FICHIER: flutter_lib/services/sfu_service.dart
--------------------------------------------------------------------------------
// CrÃ©er un nouveau fichier: flutter_lib/features/tables/services/sfu_service.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../services/api_service.dart';

part 'sfu_service.g.dart';

class SfuService {
  final ApiService _apiService;

  SfuService({required ApiService apiService}) : _apiService = apiService;

  Future<Map<String, dynamic>> generateToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return _apiService.generateLiveKitToken(
      participantIdentity: participantIdentity,
      participantName: participantName,
      participantAttributes: participantAttributes,
      participantMetadata: participantMetadata,
      roomName: roomName,
      roomConfig: roomConfig,
    );
  }
}

@riverpod
SfuService sfuService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return SfuService(apiService: apiService);
}


FICHIER: flutter_lib/services/sfu_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sfu_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(sfuService)
final sfuServiceProvider = SfuServiceProvider._();

final class SfuServiceProvider
    extends $FunctionalProvider<SfuService, SfuService, SfuService>
    with $Provider<SfuService> {
  SfuServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'sfuServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$sfuServiceHash();

  @$internal
  @override
  $ProviderElement<SfuService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  SfuService create(Ref ref) {
    return sfuService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(SfuService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<SfuService>(value),
    );
  }
}

String _$sfuServiceHash() => r'eec97a26458eb6027d15e5c5845938b8e56f520d';



FIN
============
Total fichiers: 61