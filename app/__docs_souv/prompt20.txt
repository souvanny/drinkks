Revoici la derniÃ¨re version du projet Flutter/symfony.

LÃ  pour cette tÃ¢che je voudrais modifier AccountController.php
Pour /api/account/me di firstAccess alors modifier (setFirstAccess(false)) first_access en le mettant Ã  false.
L'idÃ©e est de dire que c'est plus la premiÃ¨re fois que l'on accÃ¨de Ã  /account/me.


Ensuite je voudrais modifier AccountScreen.

- pour chaque onglet, vÃ©rifier s'il manque des infos, et affiche Ã  cÃ´tÃ© des onglets un marqueur pour montrer qu'il y a un manque
    - onglet "Profil"
        - est le nom d'affichage est saisi
        - est-ce le gender doit Ãªtre choisi (diffÃ©rent de 0)
        - date de naissance, l'Ã¢ge doit Ãªtre au minimum de 18 ans
    - onglet "A propos"
        - est-ce quil a Ã©tÃ© saisi
    - Photo
        - est-ce qu'une photo est tÃ©lÃ©chargÃ©


Au charment de cette page, vÃ©rifier ces information dans la rÃ©ponse de l'api.
S'il manque une information :
    - si first_access = true, alors afficher une popup indiquant un bienvenue et que c'est la premiÃ¨re fois que l'utilisateur accÃ¨de Ã  l'appli et que donc il faut qu'il remplisse toutes les information
    - dans cette popup Ã  n'afficher qu'une seule fois, bien rappeler les rÃ¨gles:
        - display_name non vide
        - gender Ã  renseigner
        - Ã¢ge >= >8
        - about_me Ã  saisir
        - photo Ã  tÃ©lÃ©charger

FICHIERS POUR ANALYSE
=====================
Dossiers analysÃ©s:
  - flutter_lib/features/account
  - flutter_lib/providers
  - flutter_lib/services
  - src
Extensions: dart, php, yaml, yml
Date: 2026-02-25 13:24:30

ARBORESCENCE:
-------------
â”œâ”€â”€ ğŸ“ flutter_lib/
â”‚   â”œâ”€â”€ ğŸ“ features/
â”‚   â”‚   â””â”€â”€ ğŸ“ account/
â”‚   â”‚       â”œâ”€â”€ ğŸ“ data/
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ datasources/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_remote_data_source.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_remote_data_source.g.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_remote_data_source.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_remote_data_source.g.dart
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ models/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_model.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_model.freezed.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_model.g.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_model.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_model.freezed.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_model.g.dart
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ repositories/
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ account_repository_impl.dart
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ account_repository_impl.g.dart
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ user_profile_repository.dart
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ user_profile_repository_impl.dart
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“„ user_profile_repository_impl.g.dart
â”‚   â”‚       â”œâ”€â”€ ğŸ“ domain/
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ entities/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_entity.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_entity.freezed.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ user_profile_entity.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_entity.freezed.dart
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ repositories/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ account_repository.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ user_profile_repository.dart
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ usecases/
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ get_accounts_usecase.dart
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ get_accounts_usecase.g.dart
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ get_user_profile_usecase.dart
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“„ get_user_profile_usecase.g.dart
â”‚   â”‚       â””â”€â”€ ğŸ“ presentation/
â”‚   â”‚           â”œâ”€â”€ ğŸ“ controllers/
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“„ account_controller.dart
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“„ account_controller.g.dart
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“„ user_profile_controller.dart
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“„ user_profile_controller.g.dart
â”‚   â”‚           â””â”€â”€ ğŸ“ screens/
â”‚   â”‚               â””â”€â”€ ğŸ“„ account_screen.dart
â”‚   â”œâ”€â”€ ğŸ“ providers/
â”‚   â”‚   â””â”€â”€ ğŸ“„ auth_provider.dart
â”‚   â””â”€â”€ ğŸ“ services/
â”‚       â”œâ”€â”€ ğŸ“„ account_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ account_service.g.dart
â”‚       â”œâ”€â”€ ğŸ“„ api_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ api_service.g.dart
â”‚       â”œâ”€â”€ ğŸ“„ auth_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ sfu_service.dart
â”‚       â””â”€â”€ ğŸ“„ sfu_service.g.dart
â””â”€â”€ ğŸ“ src/
    â”œâ”€â”€ ğŸ“ Domain/
    â”‚   â”œâ”€â”€ ğŸ“ Entity/
    â”‚   â”‚   â””â”€â”€ ğŸ“„ User.php
    â”‚   â”œâ”€â”€ ğŸ“ Repository/
    â”‚   â”‚   â””â”€â”€ ğŸ“„ UserRepositoryInterface.php
    â”‚   â””â”€â”€ ğŸ“ ValueObject/
    â”‚       â”œâ”€â”€ ğŸ“„ Email.php
    â”‚       â””â”€â”€ ğŸ“„ UserRole.php
    â”œâ”€â”€ ğŸ“ Infrastructure/
    â”‚   â”œâ”€â”€ ğŸ“ Console/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Command/
    â”‚   â”‚       â””â”€â”€ ğŸ“„ ClearExpiredRefreshTokensCommand.php
    â”‚   â”œâ”€â”€ ğŸ“ Http/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Controller/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ AccountController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ AuthController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ GenerateLiveKitController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ GeneratePromptController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ LogoutController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ PhotoController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenController.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ UsersGetJwtTokenFromFirebaseAuthAction.php
    â”‚   â”œâ”€â”€ ğŸ“ Persistence/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ Entity/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ RefreshTokenEntity.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ UserEntity.php
    â”‚   â”‚       â””â”€â”€ ğŸ“ Repository/
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ RefreshTokenRepository.php
    â”‚   â”‚           â””â”€â”€ ğŸ“„ UserRepository.php
    â”‚   â””â”€â”€ ğŸ“ Security/
    â”‚       â”œâ”€â”€ ğŸ“„ JWTLoginSuccessHandler.php
    â”‚       â”œâ”€â”€ ğŸ“„ JwtAuthenticator.php
    â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenAuthenticator.php
    â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenService.php
    â”‚       â””â”€â”€ ğŸ“„ UserProvider.php
    â”œâ”€â”€ ğŸ“ Shared/
    â”‚   â”œâ”€â”€ ğŸ“ Application/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ Command/
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CommandBusInterface.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CommandHandlerInterface.php
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ CommandInterface.php
    â”‚   â”‚   â””â”€â”€ ğŸ“ Query/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ QueryBusInterface.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ QueryHandlerInterface.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ QueryInterface.php
    â”‚   â”œâ”€â”€ ğŸ“ Domain/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Event/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ EventHandlerInterface.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ EventInterface.php
    â”‚   â””â”€â”€ ğŸ“ Infrastructure/
    â”‚       â””â”€â”€ ğŸ“ Bus/
    â”‚           â”œâ”€â”€ ğŸ“„ CommandBus.php
    â”‚           â”œâ”€â”€ ğŸ“„ EventBus.php
    â”‚           â””â”€â”€ ğŸ“„ QueryBus.php
    â”œâ”€â”€ ğŸ“ Users/
    â”‚   â”œâ”€â”€ ğŸ“ Application/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ Config/
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ UsersAppConfig.php
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ DTO/
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ UserDTO.php
    â”‚   â”‚   â””â”€â”€ ğŸ“ Query/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ GetJwtForSignup/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ GetJwtForSignupQuery.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ GetJwtForSignupQueryHandler.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ GetJwtFromUser/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ GetJwtFromUserQuery.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ GetJwtFromUserQueryHandler.php
    â”‚   â”‚       â””â”€â”€ ğŸ“ GetUserByFirebaseToken/
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ GetUserByFirebaseTokenQuery.php
    â”‚   â”‚           â””â”€â”€ ğŸ“„ GetUserByFirebaseTokenQueryHandler.php
    â”‚   â””â”€â”€ ğŸ“ Domain/
    â”‚       â””â”€â”€ ğŸ“ Repository/
    â”‚           â””â”€â”€ ğŸ“„ UserRepositoryInterface.php
    â””â”€â”€ ğŸ“„ Kernel.php


CONTENU DES FICHIERS
====================

FICHIER: flutter_lib/features/account/data/datasources/account_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../core/providers/network_providers.dart';
import '../models/account_model.dart';

part 'account_remote_data_source.g.dart';

abstract class AccountRemoteDataSource {
  Future<List<AccountModel>> fetchAccounts();
  Future<AccountModel> fetchAccount(String id);
}

@riverpod
AccountRemoteDataSource accountRemoteDataSource(Ref ref) {
  final dio = ref.watch(dioProvider);
  return AccountRemoteDataSourceImpl(dio);
}

class AccountRemoteDataSourceImpl implements AccountRemoteDataSource {
  final Dio _dio;

  AccountRemoteDataSourceImpl(this._dio);

  @override
  Future<List<AccountModel>> fetchAccounts() async {
    // final response = await _dio.get('/accounts');
    // return (response.data as List).map((e) => AccountModel.fromJson(e)).toList();
    await Future.delayed(const Duration(seconds: 1));
    return [
      const AccountModel(id: '1', name: 'Item 1'),
      const AccountModel(id: '2', name: 'Item 2'),
    ];
  }

  @override
  Future<AccountModel> fetchAccount(String id) async {
    await Future.delayed(const Duration(seconds: 1));
    return AccountModel(id: id, name: 'Item ');
  }
}



FICHIER: flutter_lib/features/account/data/datasources/account_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountRemoteDataSource)
final accountRemoteDataSourceProvider = AccountRemoteDataSourceProvider._();

final class AccountRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          AccountRemoteDataSource,
          AccountRemoteDataSource,
          AccountRemoteDataSource
        >
    with $Provider<AccountRemoteDataSource> {
  AccountRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<AccountRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  AccountRemoteDataSource create(Ref ref) {
    return accountRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountRemoteDataSource>(value),
    );
  }
}

String _$accountRemoteDataSourceHash() =>
    r'53ff15520eb0b74c67501459a5e2e8b065c3b943';



FICHIER: flutter_lib/features/account/data/datasources/user_profile_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../../services/account_service.dart';
import '../models/user_profile_model.dart';

part 'user_profile_remote_data_source.g.dart';

abstract class UserProfileRemoteDataSource {
  Future<UserProfileModel> getProfile();
  Future<String> getAboutMe();
  Future<String> getPhoto();
  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  });
  Future<void> updateAboutMe(String aboutMe);
  Future<void> updatePhoto(String photoPath);
}

@riverpod
UserProfileRemoteDataSource userProfileRemoteDataSource(Ref ref) {
  final accountService = ref.watch(accountServiceProvider);
  return UserProfileRemoteDataSourceImpl(accountService);
}

class UserProfileRemoteDataSourceImpl implements UserProfileRemoteDataSource {
  final AccountService _accountService;

  UserProfileRemoteDataSourceImpl(this._accountService);

  @override
  Future<UserProfileModel> getProfile() async {
    final response = await _accountService.getProfile();
    return UserProfileModel.fromJson(response);
  }

  @override
  Future<String> getAboutMe() async {
    final response = await _accountService.getAboutMe();
    return response['about_me'] ?? '';
  }

  @override
  Future<String> getPhoto() async {
    final response = await _accountService.getPhoto();
    return response['photo_url'] ?? '';
  }

  @override
  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    await _accountService.updateProfile(
      displayName: displayName,
      gender: gender,
      birthdate: birthdate,
    );
  }

  @override
  Future<void> updateAboutMe(String aboutMe) async {
    await _accountService.updateAboutMe(aboutMe);
  }

  @override
  Future<void> updatePhoto(String photoPath) async {
    await _accountService.updatePhoto(photoPath);
  }
}


FICHIER: flutter_lib/features/account/data/datasources/user_profile_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(userProfileRemoteDataSource)
final userProfileRemoteDataSourceProvider =
    UserProfileRemoteDataSourceProvider._();

final class UserProfileRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          UserProfileRemoteDataSource,
          UserProfileRemoteDataSource,
          UserProfileRemoteDataSource
        >
    with $Provider<UserProfileRemoteDataSource> {
  UserProfileRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'userProfileRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$userProfileRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<UserProfileRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  UserProfileRemoteDataSource create(Ref ref) {
    return userProfileRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(UserProfileRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<UserProfileRemoteDataSource>(value),
    );
  }
}

String _$userProfileRemoteDataSourceHash() =>
    r'4a53c5e6e9864d6047e571648f9820215a0204fb';



FICHIER: flutter_lib/features/account/data/models/account_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/account_entity.dart';

part 'account_model.freezed.dart';
part 'account_model.g.dart';

@freezed
abstract class AccountModel with _$AccountModel {
  const AccountModel._();

  const factory AccountModel({
    required String id,
    required String name,
  }) = _AccountModel;

  factory AccountModel.fromJson(Map<String, dynamic> json) =>
      _$AccountModelFromJson(json);

  AccountEntity toEntity() => AccountEntity(id: id, name: name);
}



FICHIER: flutter_lib/features/account/data/models/account_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$AccountModel {

 String get id; String get name;
/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AccountModelCopyWith<AccountModel> get copyWith => _$AccountModelCopyWithImpl<AccountModel>(this as AccountModel, _$identity);

  /// Serializes this AccountModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AccountModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $AccountModelCopyWith<$Res>  {
  factory $AccountModelCopyWith(AccountModel value, $Res Function(AccountModel) _then) = _$AccountModelCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$AccountModelCopyWithImpl<$Res>
    implements $AccountModelCopyWith<$Res> {
  _$AccountModelCopyWithImpl(this._self, this._then);

  final AccountModel _self;
  final $Res Function(AccountModel) _then;

/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [AccountModel].
extension AccountModelPatterns on AccountModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _AccountModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _AccountModel value)  $default,){
final _that = this;
switch (_that) {
case _AccountModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _AccountModel value)?  $default,){
final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _AccountModel():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _AccountModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _AccountModel extends AccountModel {
  const _AccountModel({required this.id, required this.name}): super._();
  factory _AccountModel.fromJson(Map<String, dynamic> json) => _$AccountModelFromJson(json);

@override final  String id;
@override final  String name;

/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AccountModelCopyWith<_AccountModel> get copyWith => __$AccountModelCopyWithImpl<_AccountModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AccountModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AccountModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$AccountModelCopyWith<$Res> implements $AccountModelCopyWith<$Res> {
  factory _$AccountModelCopyWith(_AccountModel value, $Res Function(_AccountModel) _then) = __$AccountModelCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$AccountModelCopyWithImpl<$Res>
    implements _$AccountModelCopyWith<$Res> {
  __$AccountModelCopyWithImpl(this._self, this._then);

  final _AccountModel _self;
  final $Res Function(_AccountModel) _then;

/// Create a copy of AccountModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_AccountModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/data/models/account_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_AccountModel _$AccountModelFromJson(Map<String, dynamic> json) =>
    _AccountModel(id: json['id'] as String, name: json['name'] as String);

Map<String, dynamic> _$AccountModelToJson(_AccountModel instance) =>
    <String, dynamic>{'id': instance.id, 'name': instance.name};



FICHIER: flutter_lib/features/account/data/models/user_profile_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/user_profile_entity.dart';

part 'user_profile_model.freezed.dart';
part 'user_profile_model.g.dart';

@freezed
abstract class UserProfileModel with _$UserProfileModel {
  const UserProfileModel._();

  const factory UserProfileModel({
    required String id,
    @JsonKey(name: 'displayName') String? displayName,
    int? gender,
    @JsonKey(name: 'birthdate') @DateTimeConverter() DateTime? birthdate,
    @JsonKey(name: 'about_me') String? aboutMe,
    @JsonKey(name: 'photo_url') String? photoUrl,
    @JsonKey(name: 'has_photo') @Default(false) bool hasPhoto,
  }) = _UserProfileModel;

  factory UserProfileModel.fromJson(Map<String, dynamic> json) =>
      _$UserProfileModelFromJson(json);

  UserProfileEntity toEntity() => UserProfileEntity(
    id: id,
    displayName: displayName,
    gender: gender,
    birthdate: birthdate,
    aboutMe: aboutMe,
    photoUrl: photoUrl,
    hasPhoto: hasPhoto,
  );
}

class DateTimeConverter implements JsonConverter<DateTime?, String?> {
  const DateTimeConverter();

  @override
  DateTime? fromJson(String? json) {
    if (json == null) return null;
    return DateTime.parse(json);
  }

  @override
  String? toJson(DateTime? object) {
    if (object == null) return null;
    return object.toIso8601String();
  }
}


FICHIER: flutter_lib/features/account/data/models/user_profile_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_profile_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserProfileModel {

 String get id;@JsonKey(name: 'displayName') String? get displayName; int? get gender;@JsonKey(name: 'birthdate')@DateTimeConverter() DateTime? get birthdate;@JsonKey(name: 'about_me') String? get aboutMe;@JsonKey(name: 'photo_url') String? get photoUrl;@JsonKey(name: 'has_photo') bool get hasPhoto;
/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UserProfileModelCopyWith<UserProfileModel> get copyWith => _$UserProfileModelCopyWithImpl<UserProfileModel>(this as UserProfileModel, _$identity);

  /// Serializes this UserProfileModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UserProfileModel&&(identical(other.id, id) || other.id == id)&&(identical(other.displayName, displayName) || other.displayName == displayName)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl)&&(identical(other.hasPhoto, hasPhoto) || other.hasPhoto == hasPhoto));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,displayName,gender,birthdate,aboutMe,photoUrl,hasPhoto);

@override
String toString() {
  return 'UserProfileModel(id: $id, displayName: $displayName, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl, hasPhoto: $hasPhoto)';
}


}

/// @nodoc
abstract mixin class $UserProfileModelCopyWith<$Res>  {
  factory $UserProfileModelCopyWith(UserProfileModel value, $Res Function(UserProfileModel) _then) = _$UserProfileModelCopyWithImpl;
@useResult
$Res call({
 String id,@JsonKey(name: 'displayName') String? displayName, int? gender,@JsonKey(name: 'birthdate')@DateTimeConverter() DateTime? birthdate,@JsonKey(name: 'about_me') String? aboutMe,@JsonKey(name: 'photo_url') String? photoUrl,@JsonKey(name: 'has_photo') bool hasPhoto
});




}
/// @nodoc
class _$UserProfileModelCopyWithImpl<$Res>
    implements $UserProfileModelCopyWith<$Res> {
  _$UserProfileModelCopyWithImpl(this._self, this._then);

  final UserProfileModel _self;
  final $Res Function(UserProfileModel) _then;

/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? displayName = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,Object? hasPhoto = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,displayName: freezed == displayName ? _self.displayName : displayName // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,hasPhoto: null == hasPhoto ? _self.hasPhoto : hasPhoto // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// Adds pattern-matching-related methods to [UserProfileModel].
extension UserProfileModelPatterns on UserProfileModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _UserProfileModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _UserProfileModel value)  $default,){
final _that = this;
switch (_that) {
case _UserProfileModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _UserProfileModel value)?  $default,){
final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id, @JsonKey(name: 'displayName')  String? displayName,  int? gender, @JsonKey(name: 'birthdate')@DateTimeConverter()  DateTime? birthdate, @JsonKey(name: 'about_me')  String? aboutMe, @JsonKey(name: 'photo_url')  String? photoUrl, @JsonKey(name: 'has_photo')  bool hasPhoto)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that.id,_that.displayName,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl,_that.hasPhoto);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id, @JsonKey(name: 'displayName')  String? displayName,  int? gender, @JsonKey(name: 'birthdate')@DateTimeConverter()  DateTime? birthdate, @JsonKey(name: 'about_me')  String? aboutMe, @JsonKey(name: 'photo_url')  String? photoUrl, @JsonKey(name: 'has_photo')  bool hasPhoto)  $default,) {final _that = this;
switch (_that) {
case _UserProfileModel():
return $default(_that.id,_that.displayName,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl,_that.hasPhoto);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id, @JsonKey(name: 'displayName')  String? displayName,  int? gender, @JsonKey(name: 'birthdate')@DateTimeConverter()  DateTime? birthdate, @JsonKey(name: 'about_me')  String? aboutMe, @JsonKey(name: 'photo_url')  String? photoUrl, @JsonKey(name: 'has_photo')  bool hasPhoto)?  $default,) {final _that = this;
switch (_that) {
case _UserProfileModel() when $default != null:
return $default(_that.id,_that.displayName,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl,_that.hasPhoto);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _UserProfileModel extends UserProfileModel {
  const _UserProfileModel({required this.id, @JsonKey(name: 'displayName') this.displayName, this.gender, @JsonKey(name: 'birthdate')@DateTimeConverter() this.birthdate, @JsonKey(name: 'about_me') this.aboutMe, @JsonKey(name: 'photo_url') this.photoUrl, @JsonKey(name: 'has_photo') this.hasPhoto = false}): super._();
  factory _UserProfileModel.fromJson(Map<String, dynamic> json) => _$UserProfileModelFromJson(json);

@override final  String id;
@override@JsonKey(name: 'displayName') final  String? displayName;
@override final  int? gender;
@override@JsonKey(name: 'birthdate')@DateTimeConverter() final  DateTime? birthdate;
@override@JsonKey(name: 'about_me') final  String? aboutMe;
@override@JsonKey(name: 'photo_url') final  String? photoUrl;
@override@JsonKey(name: 'has_photo') final  bool hasPhoto;

/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UserProfileModelCopyWith<_UserProfileModel> get copyWith => __$UserProfileModelCopyWithImpl<_UserProfileModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UserProfileModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UserProfileModel&&(identical(other.id, id) || other.id == id)&&(identical(other.displayName, displayName) || other.displayName == displayName)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl)&&(identical(other.hasPhoto, hasPhoto) || other.hasPhoto == hasPhoto));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,displayName,gender,birthdate,aboutMe,photoUrl,hasPhoto);

@override
String toString() {
  return 'UserProfileModel(id: $id, displayName: $displayName, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl, hasPhoto: $hasPhoto)';
}


}

/// @nodoc
abstract mixin class _$UserProfileModelCopyWith<$Res> implements $UserProfileModelCopyWith<$Res> {
  factory _$UserProfileModelCopyWith(_UserProfileModel value, $Res Function(_UserProfileModel) _then) = __$UserProfileModelCopyWithImpl;
@override @useResult
$Res call({
 String id,@JsonKey(name: 'displayName') String? displayName, int? gender,@JsonKey(name: 'birthdate')@DateTimeConverter() DateTime? birthdate,@JsonKey(name: 'about_me') String? aboutMe,@JsonKey(name: 'photo_url') String? photoUrl,@JsonKey(name: 'has_photo') bool hasPhoto
});




}
/// @nodoc
class __$UserProfileModelCopyWithImpl<$Res>
    implements _$UserProfileModelCopyWith<$Res> {
  __$UserProfileModelCopyWithImpl(this._self, this._then);

  final _UserProfileModel _self;
  final $Res Function(_UserProfileModel) _then;

/// Create a copy of UserProfileModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? displayName = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,Object? hasPhoto = null,}) {
  return _then(_UserProfileModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,displayName: freezed == displayName ? _self.displayName : displayName // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,hasPhoto: null == hasPhoto ? _self.hasPhoto : hasPhoto // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/data/models/user_profile_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_UserProfileModel _$UserProfileModelFromJson(Map<String, dynamic> json) =>
    _UserProfileModel(
      id: json['id'] as String,
      displayName: json['displayName'] as String?,
      gender: (json['gender'] as num?)?.toInt(),
      birthdate: const DateTimeConverter().fromJson(
        json['birthdate'] as String?,
      ),
      aboutMe: json['about_me'] as String?,
      photoUrl: json['photo_url'] as String?,
      hasPhoto: json['has_photo'] as bool? ?? false,
    );

Map<String, dynamic> _$UserProfileModelToJson(_UserProfileModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'displayName': instance.displayName,
      'gender': instance.gender,
      'birthdate': const DateTimeConverter().toJson(instance.birthdate),
      'about_me': instance.aboutMe,
      'photo_url': instance.photoUrl,
      'has_photo': instance.hasPhoto,
    };



FICHIER: flutter_lib/features/account/data/repositories/account_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/account_entity.dart';
import '../../domain/repositories/account_repository.dart';
import '../datasources/account_remote_data_source.dart';

part 'account_repository_impl.g.dart';

@riverpod
AccountRepository accountRepository(Ref ref) {
  final remoteDataSource = ref.watch(accountRemoteDataSourceProvider);
  return AccountRepositoryImpl(remoteDataSource);
}

class AccountRepositoryImpl implements AccountRepository {
  final AccountRemoteDataSource _remoteDataSource;

  AccountRepositoryImpl(this._remoteDataSource);

  @override
  Future<List<AccountEntity>> getAccounts() async {
    final models = await _remoteDataSource.fetchAccounts();
    return models.map((e) => e.toEntity()).toList();
  }

  @override
  Future<AccountEntity> getAccount(String id) async {
    final model = await _remoteDataSource.fetchAccount(id);
    return model.toEntity();
  }
}



FICHIER: flutter_lib/features/account/data/repositories/account_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountRepository)
final accountRepositoryProvider = AccountRepositoryProvider._();

final class AccountRepositoryProvider
    extends
        $FunctionalProvider<
          AccountRepository,
          AccountRepository,
          AccountRepository
        >
    with $Provider<AccountRepository> {
  AccountRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountRepositoryHash();

  @$internal
  @override
  $ProviderElement<AccountRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  AccountRepository create(Ref ref) {
    return accountRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountRepository>(value),
    );
  }
}

String _$accountRepositoryHash() => r'8e9b066c582c158b7615cf5520bab449a8d821ba';



FICHIER: flutter_lib/features/account/data/repositories/user_profile_repository.dart
--------------------------------------------------------------------------------
import '../../domain/entities/user_profile_entity.dart';

abstract class UserProfileRepository {
  Future<UserProfileEntity> getProfile();
  Future<String?> getAboutMe();
  Future<String?> getPhoto();
  Future<void> updateProfile({
    String? username,
    int? gender,
    DateTime? birthdate,
  });
  Future<void> updateAboutMe(String aboutMe);
  Future<void> updatePhoto(String photoPath);
}


FICHIER: flutter_lib/features/account/data/repositories/user_profile_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/user_profile_entity.dart';
import '../../domain/repositories/user_profile_repository.dart';
import '../datasources/user_profile_remote_data_source.dart';

part 'user_profile_repository_impl.g.dart';

@riverpod
UserProfileRepository userProfileRepository(Ref ref) {
  final remoteDataSource = ref.watch(userProfileRemoteDataSourceProvider);
  return UserProfileRepositoryImpl(remoteDataSource);
}

class UserProfileRepositoryImpl implements UserProfileRepository {
  final UserProfileRemoteDataSource _remoteDataSource;

  UserProfileRepositoryImpl(this._remoteDataSource);

  @override
  Future<UserProfileEntity> getProfile() async {
    final model = await _remoteDataSource.getProfile();
    return model.toEntity();
  }

  @override
  Future<String?> getAboutMe() async {
    return await _remoteDataSource.getAboutMe();
  }

  @override
  Future<String?> getPhoto() async {
    return await _remoteDataSource.getPhoto();
  }

  @override
  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    await _remoteDataSource.updateProfile(
      displayName: displayName,
      gender: gender,
      birthdate: birthdate,
    );
  }

  @override
  Future<void> updateAboutMe(String aboutMe) async {
    await _remoteDataSource.updateAboutMe(aboutMe);
  }

  @override
  Future<void> updatePhoto(String photoPath) async {
    await _remoteDataSource.updatePhoto(photoPath);
  }
}


FICHIER: flutter_lib/features/account/data/repositories/user_profile_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(userProfileRepository)
final userProfileRepositoryProvider = UserProfileRepositoryProvider._();

final class UserProfileRepositoryProvider
    extends
        $FunctionalProvider<
          UserProfileRepository,
          UserProfileRepository,
          UserProfileRepository
        >
    with $Provider<UserProfileRepository> {
  UserProfileRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'userProfileRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$userProfileRepositoryHash();

  @$internal
  @override
  $ProviderElement<UserProfileRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  UserProfileRepository create(Ref ref) {
    return userProfileRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(UserProfileRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<UserProfileRepository>(value),
    );
  }
}

String _$userProfileRepositoryHash() =>
    r'faf8aa120f7405814b9f7beec63f479707caf213';



FICHIER: flutter_lib/features/account/domain/entities/account_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'account_entity.freezed.dart';

@freezed
abstract class AccountEntity with _$AccountEntity {
  const factory AccountEntity({
    required String id,
    required String name,
  }) = _AccountEntity;
}



FICHIER: flutter_lib/features/account/domain/entities/account_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$AccountEntity {

 String get id; String get name;
/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AccountEntityCopyWith<AccountEntity> get copyWith => _$AccountEntityCopyWithImpl<AccountEntity>(this as AccountEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AccountEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $AccountEntityCopyWith<$Res>  {
  factory $AccountEntityCopyWith(AccountEntity value, $Res Function(AccountEntity) _then) = _$AccountEntityCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$AccountEntityCopyWithImpl<$Res>
    implements $AccountEntityCopyWith<$Res> {
  _$AccountEntityCopyWithImpl(this._self, this._then);

  final AccountEntity _self;
  final $Res Function(AccountEntity) _then;

/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [AccountEntity].
extension AccountEntityPatterns on AccountEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _AccountEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _AccountEntity value)  $default,){
final _that = this;
switch (_that) {
case _AccountEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _AccountEntity value)?  $default,){
final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _AccountEntity():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _AccountEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc


class _AccountEntity implements AccountEntity {
  const _AccountEntity({required this.id, required this.name});


@override final  String id;
@override final  String name;

/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AccountEntityCopyWith<_AccountEntity> get copyWith => __$AccountEntityCopyWithImpl<_AccountEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AccountEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'AccountEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$AccountEntityCopyWith<$Res> implements $AccountEntityCopyWith<$Res> {
  factory _$AccountEntityCopyWith(_AccountEntity value, $Res Function(_AccountEntity) _then) = __$AccountEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$AccountEntityCopyWithImpl<$Res>
    implements _$AccountEntityCopyWith<$Res> {
  __$AccountEntityCopyWithImpl(this._self, this._then);

  final _AccountEntity _self;
  final $Res Function(_AccountEntity) _then;

/// Create a copy of AccountEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_AccountEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/domain/entities/user_profile_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_profile_entity.freezed.dart';

@freezed
abstract class UserProfileEntity with _$UserProfileEntity {
  const factory UserProfileEntity({
    required String id,
    required String? displayName,
    required int? gender,
    required DateTime? birthdate,
    required String? aboutMe,
    required String? photoUrl,
    @Default(false) bool hasPhoto,
  }) = _UserProfileEntity;
}


FICHIER: flutter_lib/features/account/domain/entities/user_profile_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_profile_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$UserProfileEntity {

 String get id; String? get displayName; int? get gender; DateTime? get birthdate; String? get aboutMe; String? get photoUrl; bool get hasPhoto;
/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UserProfileEntityCopyWith<UserProfileEntity> get copyWith => _$UserProfileEntityCopyWithImpl<UserProfileEntity>(this as UserProfileEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UserProfileEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.displayName, displayName) || other.displayName == displayName)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl)&&(identical(other.hasPhoto, hasPhoto) || other.hasPhoto == hasPhoto));
}


@override
int get hashCode => Object.hash(runtimeType,id,displayName,gender,birthdate,aboutMe,photoUrl,hasPhoto);

@override
String toString() {
  return 'UserProfileEntity(id: $id, displayName: $displayName, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl, hasPhoto: $hasPhoto)';
}


}

/// @nodoc
abstract mixin class $UserProfileEntityCopyWith<$Res>  {
  factory $UserProfileEntityCopyWith(UserProfileEntity value, $Res Function(UserProfileEntity) _then) = _$UserProfileEntityCopyWithImpl;
@useResult
$Res call({
 String id, String? displayName, int? gender, DateTime? birthdate, String? aboutMe, String? photoUrl, bool hasPhoto
});




}
/// @nodoc
class _$UserProfileEntityCopyWithImpl<$Res>
    implements $UserProfileEntityCopyWith<$Res> {
  _$UserProfileEntityCopyWithImpl(this._self, this._then);

  final UserProfileEntity _self;
  final $Res Function(UserProfileEntity) _then;

/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? displayName = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,Object? hasPhoto = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,displayName: freezed == displayName ? _self.displayName : displayName // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,hasPhoto: null == hasPhoto ? _self.hasPhoto : hasPhoto // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}


/// Adds pattern-matching-related methods to [UserProfileEntity].
extension UserProfileEntityPatterns on UserProfileEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _UserProfileEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _UserProfileEntity value)  $default,){
final _that = this;
switch (_that) {
case _UserProfileEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _UserProfileEntity value)?  $default,){
final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String? displayName,  int? gender,  DateTime? birthdate,  String? aboutMe,  String? photoUrl,  bool hasPhoto)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that.id,_that.displayName,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl,_that.hasPhoto);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String? displayName,  int? gender,  DateTime? birthdate,  String? aboutMe,  String? photoUrl,  bool hasPhoto)  $default,) {final _that = this;
switch (_that) {
case _UserProfileEntity():
return $default(_that.id,_that.displayName,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl,_that.hasPhoto);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String? displayName,  int? gender,  DateTime? birthdate,  String? aboutMe,  String? photoUrl,  bool hasPhoto)?  $default,) {final _that = this;
switch (_that) {
case _UserProfileEntity() when $default != null:
return $default(_that.id,_that.displayName,_that.gender,_that.birthdate,_that.aboutMe,_that.photoUrl,_that.hasPhoto);case _:
  return null;

}
}

}

/// @nodoc


class _UserProfileEntity implements UserProfileEntity {
  const _UserProfileEntity({required this.id, required this.displayName, required this.gender, required this.birthdate, required this.aboutMe, required this.photoUrl, this.hasPhoto = false});


@override final  String id;
@override final  String? displayName;
@override final  int? gender;
@override final  DateTime? birthdate;
@override final  String? aboutMe;
@override final  String? photoUrl;
@override@JsonKey() final  bool hasPhoto;

/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UserProfileEntityCopyWith<_UserProfileEntity> get copyWith => __$UserProfileEntityCopyWithImpl<_UserProfileEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UserProfileEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.displayName, displayName) || other.displayName == displayName)&&(identical(other.gender, gender) || other.gender == gender)&&(identical(other.birthdate, birthdate) || other.birthdate == birthdate)&&(identical(other.aboutMe, aboutMe) || other.aboutMe == aboutMe)&&(identical(other.photoUrl, photoUrl) || other.photoUrl == photoUrl)&&(identical(other.hasPhoto, hasPhoto) || other.hasPhoto == hasPhoto));
}


@override
int get hashCode => Object.hash(runtimeType,id,displayName,gender,birthdate,aboutMe,photoUrl,hasPhoto);

@override
String toString() {
  return 'UserProfileEntity(id: $id, displayName: $displayName, gender: $gender, birthdate: $birthdate, aboutMe: $aboutMe, photoUrl: $photoUrl, hasPhoto: $hasPhoto)';
}


}

/// @nodoc
abstract mixin class _$UserProfileEntityCopyWith<$Res> implements $UserProfileEntityCopyWith<$Res> {
  factory _$UserProfileEntityCopyWith(_UserProfileEntity value, $Res Function(_UserProfileEntity) _then) = __$UserProfileEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String? displayName, int? gender, DateTime? birthdate, String? aboutMe, String? photoUrl, bool hasPhoto
});




}
/// @nodoc
class __$UserProfileEntityCopyWithImpl<$Res>
    implements _$UserProfileEntityCopyWith<$Res> {
  __$UserProfileEntityCopyWithImpl(this._self, this._then);

  final _UserProfileEntity _self;
  final $Res Function(_UserProfileEntity) _then;

/// Create a copy of UserProfileEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? displayName = freezed,Object? gender = freezed,Object? birthdate = freezed,Object? aboutMe = freezed,Object? photoUrl = freezed,Object? hasPhoto = null,}) {
  return _then(_UserProfileEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,displayName: freezed == displayName ? _self.displayName : displayName // ignore: cast_nullable_to_non_nullable
as String?,gender: freezed == gender ? _self.gender : gender // ignore: cast_nullable_to_non_nullable
as int?,birthdate: freezed == birthdate ? _self.birthdate : birthdate // ignore: cast_nullable_to_non_nullable
as DateTime?,aboutMe: freezed == aboutMe ? _self.aboutMe : aboutMe // ignore: cast_nullable_to_non_nullable
as String?,photoUrl: freezed == photoUrl ? _self.photoUrl : photoUrl // ignore: cast_nullable_to_non_nullable
as String?,hasPhoto: null == hasPhoto ? _self.hasPhoto : hasPhoto // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/account/domain/repositories/account_repository.dart
--------------------------------------------------------------------------------
import '../entities/account_entity.dart';

abstract class AccountRepository {
  Future<List<AccountEntity>> getAccounts();
  Future<AccountEntity> getAccount(String id);
}



FICHIER: flutter_lib/features/account/domain/repositories/user_profile_repository.dart
--------------------------------------------------------------------------------
import '../../domain/entities/user_profile_entity.dart';

abstract class UserProfileRepository {
  Future<UserProfileEntity> getProfile();
  Future<String?> getAboutMe();
  Future<String?> getPhoto();
  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  });
  Future<void> updateAboutMe(String aboutMe);
  Future<void> updatePhoto(String photoPath);
}


FICHIER: flutter_lib/features/account/domain/usecases/get_accounts_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/account_entity.dart';
import '../repositories/account_repository.dart';
import '../../data/repositories/account_repository_impl.dart';

part 'get_accounts_usecase.g.dart';

@riverpod
Future<List<AccountEntity>> getAccounts(Ref ref) {
  return ref.watch(accountRepositoryProvider).getAccounts();
}



FICHIER: flutter_lib/features/account/domain/usecases/get_accounts_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_accounts_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getAccounts)
final getAccountsProvider = GetAccountsProvider._();

final class GetAccountsProvider
    extends
        $FunctionalProvider<
          AsyncValue<List<AccountEntity>>,
          List<AccountEntity>,
          FutureOr<List<AccountEntity>>
        >
    with
        $FutureModifier<List<AccountEntity>>,
        $FutureProvider<List<AccountEntity>> {
  GetAccountsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getAccountsProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getAccountsHash();

  @$internal
  @override
  $FutureProviderElement<List<AccountEntity>> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<List<AccountEntity>> create(Ref ref) {
    return getAccounts(ref);
  }
}

String _$getAccountsHash() => r'c6cdda7c5e10644ce00d526909fb606832565b54';



FICHIER: flutter_lib/features/account/domain/usecases/get_user_profile_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/user_profile_entity.dart';
import '../repositories/user_profile_repository.dart';
import '../../data/repositories/user_profile_repository_impl.dart';

part 'get_user_profile_usecase.g.dart';

@riverpod
Future<UserProfileEntity> getUserProfile(Ref ref) {
  return ref.watch(userProfileRepositoryProvider).getProfile();
}


FICHIER: flutter_lib/features/account/domain/usecases/get_user_profile_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_user_profile_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getUserProfile)
final getUserProfileProvider = GetUserProfileProvider._();

final class GetUserProfileProvider
    extends
        $FunctionalProvider<
          AsyncValue<UserProfileEntity>,
          UserProfileEntity,
          FutureOr<UserProfileEntity>
        >
    with
        $FutureModifier<UserProfileEntity>,
        $FutureProvider<UserProfileEntity> {
  GetUserProfileProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getUserProfileProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getUserProfileHash();

  @$internal
  @override
  $FutureProviderElement<UserProfileEntity> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<UserProfileEntity> create(Ref ref) {
    return getUserProfile(ref);
  }
}

String _$getUserProfileHash() => r'7ccad3731031f4a0ef5233cbe58b660b3e7e4a3f';



FICHIER: flutter_lib/features/account/presentation/controllers/account_controller.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/account_entity.dart';
import '../../domain/usecases/get_accounts_usecase.dart';

part 'account_controller.g.dart';

@riverpod
class AccountController extends _$AccountController {
  @override
  FutureOr<List<AccountEntity>> build() {
    return ref.watch(getAccountsProvider.future);
  }

  Future<void> refresh() async {
     state = const AsyncValue.loading();
     state = await AsyncValue.guard(() => ref.refresh(getAccountsProvider.future));
  }
}



FICHIER: flutter_lib/features/account/presentation/controllers/account_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(AccountController)
final accountControllerProvider = AccountControllerProvider._();

final class AccountControllerProvider
    extends $AsyncNotifierProvider<AccountController, List<AccountEntity>> {
  AccountControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountControllerHash();

  @$internal
  @override
  AccountController create() => AccountController();
}

String _$accountControllerHash() => r'3d07a8cbbec8f9136c4aead37215e4922845c2c4';

abstract class _$AccountController extends $AsyncNotifier<List<AccountEntity>> {
  FutureOr<List<AccountEntity>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<List<AccountEntity>>, List<AccountEntity>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<AccountEntity>>, List<AccountEntity>>,
              AsyncValue<List<AccountEntity>>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/account/presentation/controllers/user_profile_controller.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../../providers/auth_provider.dart';
import '../../data/repositories/user_profile_repository_impl.dart';
import '../../domain/entities/user_profile_entity.dart';
import '../../domain/usecases/get_user_profile_usecase.dart';
import '../../domain/repositories/user_profile_repository.dart';
import '../../../../services/account_service.dart'; // NOUVEAU

part 'user_profile_controller.g.dart';

@riverpod
class UserProfileController extends _$UserProfileController {
  late AccountService _accountService; // NOUVEAU

  @override
  FutureOr<UserProfileEntity> build() {
    _accountService = ref.watch(accountServiceProvider); // NOUVEAU
    return ref.watch(getUserProfileProvider.future);
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(
            () => ref.refresh(getUserProfileProvider.future));
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(userProfileRepositoryProvider);
      await repository.updateProfile(
        displayName: displayName,
        gender: gender,
        birthdate: birthdate,
      );
      return ref.refresh(getUserProfileProvider.future);
    });
  }

  Future<void> updateAboutMe(String aboutMe) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(userProfileRepositoryProvider);
      await repository.updateAboutMe(aboutMe);
      return ref.refresh(getUserProfileProvider.future);
    });
  }

  Future<void> updatePhoto(String photoPath) async {
    print('ğŸ”„ [Controller] DÃ©but upload photo: $photoPath');
    state = const AsyncValue.loading();

    try {
      // Tentative d'upload
      await _accountService.updatePhoto(photoPath);

      // Si succÃ¨s, rafraÃ®chir le profil
      state = await AsyncValue.guard(() async {
        return ref.refresh(getUserProfileProvider.future);
      });

      print('âœ… [Controller] Upload rÃ©ussi');
    } catch (e) {
      print('âŒ [Controller] Erreur upload: $e');

      // VÃ©rifier si c'est une erreur 401 (token expirÃ©)
      if (e.toString().contains('401') || e.toString().contains('Expired JWT Token')) {
        print('ğŸ”„ [Controller] Token expirÃ©, tentative de refresh...');

        try {
          // RÃ©cupÃ©rer le refresh token
          final authService = ref.read(authServiceProvider);
          final newToken = await authService.refreshJwtToken(); // Ã€ implÃ©menter

          if (newToken != null) {
            print('âœ… [Controller] Token rafraÃ®chi, nouvelle tentative...');
            // RÃ©essayer l'upload avec le nouveau token
            await _accountService.updatePhoto(photoPath);

            // RafraÃ®chir le profil
            state = await AsyncValue.guard(() async {
              return ref.refresh(getUserProfileProvider.future);
            });

            print('âœ… [Controller] Upload rÃ©ussi aprÃ¨s refresh');
            return;
          }
        } catch (refreshError) {
          print('âŒ [Controller] Ã‰chec du refresh: $refreshError');
          // En cas d'Ã©chec, dÃ©connecter l'utilisateur
          await ref.read(authStateNotifierProvider.notifier).signOut();
        }
      }

      // Si on arrive ici, c'est que toutes les tentatives ont Ã©chouÃ©
      state = AsyncValue.error(e, StackTrace.current);
    }
  }


}


FICHIER: flutter_lib/features/account/presentation/controllers/user_profile_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_profile_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(UserProfileController)
final userProfileControllerProvider = UserProfileControllerProvider._();

final class UserProfileControllerProvider
    extends $AsyncNotifierProvider<UserProfileController, UserProfileEntity> {
  UserProfileControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'userProfileControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$userProfileControllerHash();

  @$internal
  @override
  UserProfileController create() => UserProfileController();
}

String _$userProfileControllerHash() =>
    r'c24754cc155347f7d2fa200f8f3a552820dce78f';

abstract class _$UserProfileController
    extends $AsyncNotifier<UserProfileEntity> {
  FutureOr<UserProfileEntity> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<UserProfileEntity>, UserProfileEntity>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<UserProfileEntity>, UserProfileEntity>,
              AsyncValue<UserProfileEntity>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/account/presentation/screens/account_screen.dart
--------------------------------------------------------------------------------
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import 'package:cached_network_image/cached_network_image.dart'; // NOUVEAU
import '../../../../providers/auth_provider.dart';
import '../../domain/entities/user_profile_entity.dart';
import '../controllers/user_profile_controller.dart';
import 'package:flutter/foundation.dart';

class AccountScreen extends ConsumerStatefulWidget {
  const AccountScreen({super.key});

  @override
  ConsumerState<AccountScreen> createState() => _AccountScreenState();
}

class _AccountScreenState extends ConsumerState<AccountScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _formKey = GlobalKey<FormState>();
  final _aboutMeController = TextEditingController();

  // Champs pour le premier onglet
  final _displayNameController = TextEditingController();
  int? _selectedGender;
  DateTime? _selectedDate;

  // Champs pour la photo
  XFile? _selectedImage;
  final ImagePicker _picker = ImagePicker();

  // Ã‰tat de chargement pour la photo
  bool _isPhotoLoading = false;

  // Variable pour suivre si des changements ont Ã©tÃ© faits (UNIQUEMENT pour les champs texte)
  bool _hasChanges = false;

  // Flag pour Ã©viter les Ã©crasements pendant l'Ã©dition
  bool _isEditing = false;

  // Stocker les donnÃ©es originales pour comparaison
  UserProfileEntity? _originalProfile;

  // Stocker les modifications en cours pour les prÃ©server pendant le refresh
  Map<String, dynamic> _pendingChanges = {};

  // Ã‰tats de validation
  bool _isDisplayNameValid = true;
  bool _isGenderValid = true;
  bool _isAgeValid = true;
  String? _displayNameError;
  String? _genderError;
  String? _ageError;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);

    // Ajouter un listener pour valider en temps rÃ©el
    _displayNameController.addListener(_validateDisplayName);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _displayNameController.dispose();
    _aboutMeController.dispose();
    super.dispose();
  }

  // MÃ©thodes de validation
  void _validateDisplayName() {
    final displayName = _displayNameController.text;

    if (displayName.isEmpty) {
      _isDisplayNameValid = true;
      _displayNameError = null;
    } else {
      final nameRegex = RegExp(r"^[a-zA-Z0-9\s\-']+$");

      if (!nameRegex.hasMatch(displayName)) {
        _isDisplayNameValid = false;
        _displayNameError =
        'CaractÃ¨res autorisÃ©s: lettres, chiffres, espaces, tirets et apostrophes';
      } else if (displayName.length < 2) {
        _isDisplayNameValid = false;
        _displayNameError = 'Le nom doit faire au moins 2 caractÃ¨res';
      } else if (displayName.length > 50) {
        _isDisplayNameValid = false;
        _displayNameError = 'Le nom ne doit pas dÃ©passer 50 caractÃ¨res';
      } else {
        _isDisplayNameValid = true;
        _displayNameError = null;
      }
    }

    setState(() {});
  }

  void _validateGender() {
    if (_selectedGender == null) {
      _isGenderValid = true;
      _genderError = null;
    } else if (_selectedGender != 1 && _selectedGender != 2 && _selectedGender != 3) {
      _isGenderValid = false;
      _genderError = 'Genre invalide';
    } else {
      _isGenderValid = true;
      _genderError = null;
    }
  }

  void _validateAge() {
    if (_selectedDate == null) {
      _isAgeValid = true;
      _ageError = null;
    } else {
      final now = DateTime.now();
      final age = now.year - _selectedDate!.year;
      final hasHadBirthdayThisYear =
          now.month > _selectedDate!.month ||
              (now.month == _selectedDate!.month && now.day >= _selectedDate!.day);

      final actualAge = hasHadBirthdayThisYear ? age : age - 1;

      if (actualAge < 18) {
        _isAgeValid = false;
        _ageError = 'Vous devez avoir au moins 18 ans';
      } else {
        _isAgeValid = true;
        _ageError = null;
      }
    }
  }

  void _validateAll() {
    _validateDisplayName();
    _validateGender();
    _validateAge();
  }

  bool get _isFormValid {
    _validateAll();
    return _isDisplayNameValid && _isGenderValid && _isAgeValid;
  }

  void _loadProfileData(UserProfileEntity profile) {
    // Stocker les donnÃ©es originales une seule fois
    if (_originalProfile == null) {
      _originalProfile = profile;
    }

    // Ne pas Ã©craser s'il y a des modifications en cours
    if (_isEditing || _pendingChanges.isNotEmpty) return;

    // Charger les donnÃ©es uniquement si c'est le premier chargement
    if (_displayNameController.text.isEmpty) {
      _displayNameController.text = profile.displayName ?? '';
    }

    if (_selectedGender == null) {
      _selectedGender = profile.gender;
    }

    if (_selectedDate == null) {
      _selectedDate = profile.birthdate;
    }

    if (_aboutMeController.text.isEmpty) {
      _aboutMeController.text = profile.aboutMe ?? '';
    }

    _validateAll();
  }

  // Sauvegarder les modifications en cours
  void _savePendingChanges() {
    _pendingChanges = {
      'displayName': _displayNameController.text,
      'gender': _selectedGender,
      'birthdate': _selectedDate,
      'aboutMe': _aboutMeController.text,
      'hasChanges': _hasChanges,
    };
  }

  // Restaurer les modifications en cours
  void _restorePendingChanges() {
    if (_pendingChanges.containsKey('displayName')) {
      _displayNameController.text = _pendingChanges['displayName'] as String;
    }
    if (_pendingChanges.containsKey('gender')) {
      _selectedGender = _pendingChanges['gender'] as int?;
    }
    if (_pendingChanges.containsKey('birthdate')) {
      _selectedDate = _pendingChanges['birthdate'] as DateTime?;
    }
    if (_pendingChanges.containsKey('aboutMe')) {
      _aboutMeController.text = _pendingChanges['aboutMe'] as String;
    }
    if (_pendingChanges.containsKey('hasChanges')) {
      _hasChanges = _pendingChanges['hasChanges'] as bool;
    }

    _validateAll();
  }

  // MÃ©thode pour dÃ©tecter les changements (UNIQUEMENT pour les champs texte)
  void _onFieldChanged() {
    _validateAll();
    if (!_hasChanges) {
      setState(() {
        _hasChanges = true;
      });
    }
    _savePendingChanges();
  }

  Future<void> _pickImage(ImageSource source) async {
    final XFile? image = await _picker.pickImage(source: source);
    if (image != null) {
      setState(() {
        _selectedImage = image;
        _isPhotoLoading = true;
        // NE PAS mettre _hasChanges Ã  true
      });
      _savePendingChanges();

      try {
        await ref
            .read(userProfileControllerProvider.notifier)
            .updatePhoto(image.path);

        if (mounted) {
          setState(() {
            _isPhotoLoading = false;
          });

          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Photo tÃ©lÃ©chargÃ©e avec succÃ¨s'),
              backgroundColor: Color(0xFF6366F1),
            ),
          );
        }
      } catch (e) {
        if (mounted) {
          setState(() {
            _isPhotoLoading = false;
          });

          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Erreur: $e'),
              backgroundColor: Colors.red,
            ),
          );
        }
      }
    }
  }

  void _showImageSourceDialog() {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF1E1E3F),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.photo_library, color: Color(0xFF6366F1)),
              title: const Text('Galerie', style: TextStyle(color: Colors.white)),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.gallery);
              },
            ),
            ListTile(
              leading: const Icon(Icons.photo_camera, color: Color(0xFF6366F1)),
              title: const Text('Appareil photo', style: TextStyle(color: Colors.white)),
              onTap: () {
                Navigator.pop(context);
                _pickImage(ImageSource.camera);
              },
            ),
            if (_originalProfile?.hasPhoto == true)
              ListTile(
                leading: const Icon(Icons.delete, color: Colors.red),
                title: const Text('Supprimer la photo', style: TextStyle(color: Colors.red)),
                onTap: () async {
                  Navigator.pop(context);
                  await _deletePhoto();
                },
              ),
          ],
        ),
      ),
    );
  }

  Future<void> _deletePhoto() async {
    try {
      setState(() {
        _selectedImage = null;
        _isPhotoLoading = true;
      });

      // TODO: Appeler l'API de suppression
      await _refreshProfile();

      if (mounted) {
        setState(() {
          _isPhotoLoading = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Photo supprimÃ©e'),
            backgroundColor: Color(0xFF6366F1),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isPhotoLoading = false;
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erreur lors de la suppression: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _selectDate(BuildContext context) async {
    final currentDisplayName = _displayNameController.text;
    final currentGender = _selectedGender;
    final currentDate = _selectedDate;

    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Color(0xFF6366F1),
              onPrimary: Colors.white,
              surface: Color(0xFF1E1E3F),
              onSurface: Colors.white,
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      setState(() {
        _selectedDate = picked;
        _validateAge();
        _hasChanges = true;
        _isEditing = true;
        _displayNameController.text = currentDisplayName;
        _selectedGender = currentGender;
      });
    } else {
      setState(() {
        _displayNameController.text = currentDisplayName;
        _selectedGender = currentGender;
        _selectedDate = currentDate;
        _validateAge();
      });
    }
    _savePendingChanges();
  }

  Future<bool> _onWillPop() async {
    if (!_hasChanges) {
      return true;
    }

    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E3F),
        title: const Text(
          'Modifications non enregistrÃ©es',
          style: TextStyle(color: Colors.white),
        ),
        content: const Text(
          'Vous avez des modifications non enregistrÃ©es. Voulez-vous vraiment quitter ?',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text(
              'Rester',
              style: TextStyle(color: Colors.white70),
            ),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF6366F1),
            ),
            child: const Text('Quitter', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );

    return confirm ?? false;
  }

  Future<void> _refreshProfile() async {
    _savePendingChanges();

    try {
      await ref.refresh(userProfileControllerProvider.notifier).refresh();
      _restorePendingChanges();
    } catch (e) {
      _restorePendingChanges();
      rethrow;
    }
  }

  @override
  Widget build(BuildContext context) {
    final profileState = ref.watch(userProfileControllerProvider);

    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        backgroundColor: const Color(0xFF0F0F23),
        appBar: AppBar(
          backgroundColor: Colors.transparent,
          elevation: 0,
          leading: IconButton(
            icon: const Icon(Icons.arrow_back, color: Colors.white),
            onPressed: () async {
              if (await _onWillPop()) {
                context.go('/venues');
              }
            },
            tooltip: 'Retour aux bars',
          ),
          title: const Text(
            'Mon Compte',
            style: TextStyle(
              color: Colors.white,
              fontSize: 24,
              fontWeight: FontWeight.bold,
            ),
          ),
          centerTitle: true,
          actions: [
            if (!_isFormValid && _hasChanges)
              Padding(
                padding: const EdgeInsets.only(right: 16),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.red,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Row(
                    children: [
                      Icon(Icons.error, color: Colors.white, size: 16),
                      SizedBox(width: 4),
                      Text(
                        'Champs invalides',
                        style: TextStyle(color: Colors.white, fontSize: 12),
                      ),
                    ],
                  ),
                ),
              ),
          ],
          bottom: TabBar(
            controller: _tabController,
            indicatorColor: const Color(0xFF6366F1),
            labelColor: Colors.white,
            unselectedLabelColor: Colors.white60,
            tabs: const [
              Tab(icon: Icon(Icons.person), text: 'Profil'),
              Tab(icon: Icon(Icons.description), text: 'Ã€ propos'),
              Tab(icon: Icon(Icons.photo), text: 'Photo'),
            ],
          ),
        ),
        body: profileState.when(
          data: (profile) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (mounted) {
                _loadProfileData(profile);
              }
            });

            return TabBarView(
              controller: _tabController,
              children: [
                _buildProfileTab(profile),
                _buildAboutMeTab(profile),
                _buildPhotoTab(profile),
              ],
            );
          },
          loading: () => const Center(child: CircularProgressIndicator(color: Color(0xFF6366F1))),
          error: (err, stack) => Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text(
                  'Erreur: $err',
                  style: const TextStyle(color: Colors.white),
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 16),
                ElevatedButton(
                  onPressed: _refreshProfile,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color(0xFF6366F1),
                  ),
                  child: const Text('RÃ©essayer'),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildProfileTab(UserProfileEntity profile) {
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      behavior: HitTestBehavior.translucent,
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(20),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Informations personnelles',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 20),

              // Email (lecture seule)
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                decoration: BoxDecoration(
                  color: const Color(0xFF1E1E3F),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Row(
                  children: [
                    const Icon(Icons.email, color: Color(0xFF6366F1), size: 20),
                    const SizedBox(width: 12),
                    Expanded(
                      child: Text(
                        profile.id,
                        style: const TextStyle(color: Colors.white70),
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),

              // DisplayName avec validation
              Focus(
                onFocusChange: (hasFocus) {
                  setState(() {
                    _isEditing = hasFocus;
                  });
                },
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: TextFormField(
                            controller: _displayNameController,
                            style: const TextStyle(color: Colors.white),
                            onChanged: (value) {
                              _isEditing = true;
                              _onFieldChanged();
                            },
                            decoration: InputDecoration(
                              labelText: "Nom d'affichage",
                              labelStyle: TextStyle(
                                color: _isDisplayNameValid ? Colors.white70 : Colors.red,
                              ),
                              prefixIcon: Icon(
                                Icons.person,
                                color: _isDisplayNameValid ? Color(0xFF6366F1) : Colors.red,
                              ),
                              suffixIcon: _displayNameController.text.isNotEmpty
                                  ? Icon(
                                _isDisplayNameValid ? Icons.check_circle : Icons.error,
                                color: _isDisplayNameValid ? Colors.green : Colors.red,
                              )
                                  : null,
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              errorText: _isDisplayNameValid ? null : _displayNameError,
                              errorStyle: const TextStyle(color: Colors.red),
                              filled: true,
                              fillColor: const Color(0xFF1E1E3F),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 16),

              // Genre avec validation
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        'Genre',
                        style: TextStyle(
                          color: _isGenderValid ? Colors.white70 : Colors.red,
                          fontSize: 16,
                        ),
                      ),
                      if (_selectedGender != null && !_isGenderValid)
                        Padding(
                          padding: const EdgeInsets.only(left: 8),
                          child: Icon(Icons.error, color: Colors.red, size: 16),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Column(
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: _buildGenderOption('Masculin', 1),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: _buildGenderOption('FÃ©minin', 2),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      _buildGenderOption('Ne se prononce pas', 3, fullWidth: true),
                    ],
                  ),
                  if (!_isGenderValid && _genderError != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: Text(
                        _genderError!,
                        style: const TextStyle(color: Colors.red, fontSize: 12),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 16),

              // Date de naissance avec validation
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        'Date de naissance',
                        style: TextStyle(
                          color: _isAgeValid ? Colors.white70 : Colors.red,
                          fontSize: 16,
                        ),
                      ),
                      if (_selectedDate != null && !_isAgeValid)
                        Padding(
                          padding: const EdgeInsets.only(left: 8),
                          child: Icon(Icons.error, color: Colors.red, size: 16),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  InkWell(
                    onTap: () => _selectDate(context),
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
                      decoration: BoxDecoration(
                        color: const Color(0xFF1E1E3F),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                          color: _isAgeValid ? Colors.transparent : Colors.red,
                          width: 1,
                        ),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.cake,
                            color: _isAgeValid ? Color(0xFF6366F1) : Colors.red,
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Text(
                              _selectedDate != null
                                  ? 'Date de naissance: ${_selectedDate!.day}/${_selectedDate!.month}/${_selectedDate!.year}'
                                  : 'SÃ©lectionner votre date de naissance',
                              style: TextStyle(
                                color: _selectedDate != null ? Colors.white : Colors.white60,
                              ),
                            ),
                          ),
                          Icon(
                            Icons.arrow_drop_down,
                            color: _isAgeValid ? Color(0xFF6366F1) : Colors.red,
                          ),
                        ],
                      ),
                    ),
                  ),
                  if (!_isAgeValid && _ageError != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8),
                      child: Text(
                        _ageError!,
                        style: const TextStyle(color: Colors.red, fontSize: 12),
                      ),
                    ),
                ],
              ),
              const SizedBox(height: 24),

              // Bouton de sauvegarde
              SizedBox(
                width: double.infinity,
                height: 50,
                child: ElevatedButton(
                  onPressed: _isFormValid
                      ? () async {
                    if (_formKey.currentState!.validate()) {
                      setState(() {
                        _isEditing = false;
                      });

                      await ref
                          .read(userProfileControllerProvider.notifier)
                          .updateProfile(
                        displayName: _displayNameController.text.isNotEmpty
                            ? _displayNameController.text
                            : null,
                        gender: _selectedGender,
                        birthdate: _selectedDate,
                      );

                      setState(() {
                        _hasChanges = false;
                        _pendingChanges.clear();
                      });

                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(
                            content: Text('Profil mis Ã  jour'),
                            backgroundColor: Color(0xFF6366F1),
                          ),
                        );
                      }
                    }
                  }
                      : null,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _isFormValid ? const Color(0xFF6366F1) : Colors.grey,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  child: const Text(
                    'Enregistrer les modifications',
                    style: TextStyle(fontSize: 16, color: Colors.white),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGenderOption(String label, int value, {bool fullWidth = false}) {
    final isSelected = _selectedGender == value;
    final hasError = !_isGenderValid && _selectedGender != null;

    return GestureDetector(
      onTap: () {
        setState(() {
          _selectedGender = value;
          _validateGender();
          _hasChanges = true;
          _isEditing = true;
        });
        _savePendingChanges();
      },
      child: Container(
        width: fullWidth ? double.infinity : null,
        padding: const EdgeInsets.symmetric(vertical: 12),
        decoration: BoxDecoration(
          color: isSelected
              ? (hasError ? Colors.red : const Color(0xFF6366F1))
              : const Color(0xFF1E1E3F),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected
                ? (hasError ? Colors.red : const Color(0xFF6366F1))
                : (hasError ? Colors.red : Colors.transparent),
            width: 1,
          ),
        ),
        child: Center(
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                label,
                style: const TextStyle(color: Colors.white),
              ),
              if (isSelected && hasError)
                const Padding(
                  padding: EdgeInsets.only(left: 4),
                  child: Icon(Icons.error, color: Colors.white, size: 14),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildAboutMeTab(UserProfileEntity profile) {
    return GestureDetector(
      onTap: () => FocusScope.of(context).unfocus(),
      behavior: HitTestBehavior.translucent,
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Ã€ propos de moi',
              style: TextStyle(
                color: Colors.white,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 20),
            Expanded(
              child: Focus(
                onFocusChange: (hasFocus) {
                  setState(() {
                    _isEditing = hasFocus;
                  });
                },
                child: TextField(
                  controller: _aboutMeController,
                  maxLines: null,
                  expands: true,
                  style: const TextStyle(color: Colors.white),
                  onChanged: (value) {
                    _isEditing = true;
                    _onFieldChanged();
                  },
                  decoration: InputDecoration(
                    hintText: 'Parle-nous un peu de toi...',
                    hintStyle: const TextStyle(color: Colors.white38),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide.none,
                    ),
                    filled: true,
                    fillColor: const Color(0xFF1E1E3F),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 20),
            SizedBox(
              width: double.infinity,
              height: 50,
              child: ElevatedButton(
                onPressed: () async {
                  setState(() {
                    _isEditing = false;
                  });

                  await ref
                      .read(userProfileControllerProvider.notifier)
                      .updateAboutMe(_aboutMeController.text);

                  setState(() {
                    _hasChanges = false;
                    _pendingChanges.clear();
                  });

                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Ã€ propos mis Ã  jour'),
                        backgroundColor: Color(0xFF6366F1),
                      ),
                    );
                  }
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF6366F1),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                child: const Text(
                  'Enregistrer',
                  style: TextStyle(fontSize: 16, color: Colors.white),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }



  // ============================================================
// MÃ‰THODE PRINCIPALE - Photo Tab
// ============================================================
  Widget _buildPhotoTab(UserProfileEntity profile) {
    final String? imageUrl = profile.photoUrl != null && profile.hasPhoto
        ? 'http://192.168.1.56:8101' + profile.photoUrl!
        : null;

    return Padding(
      padding: const EdgeInsets.all(20),
      child: Column(
        children: [
          const SizedBox(height: 20),

          // Affichage de la photo avec loader
          _buildPhotoWithLoader(profile, imageUrl),

          const SizedBox(height: 30),

          // Boutons Galerie et Appareil photo
          _buildPhotoActionButtons(),

          const SizedBox(height: 20),

          // Bouton de suppression
          _buildDeleteButton(profile),

          // Affichage debug de l'URL
          _buildDebugInfo(imageUrl),
        ],
      ),
    );
  }

// ============================================================
// SOUS-MÃ‰THODES
// ============================================================

  /// Construit le conteneur de la photo avec le loader et le badge
  Widget _buildPhotoWithLoader(UserProfileEntity profile, String? imageUrl) {
    return Stack(
      children: [
        // La photo elle-mÃªme
        _buildPhotoContainer(profile, imageUrl),

        // Loader pendant l'upload/suppression
        if (_isPhotoLoading) _buildPhotoLoader(),

        // Badge de confirmation (check)
        if ((profile.hasPhoto || _selectedImage != null) && !_isPhotoLoading)
          _buildPhotoBadge(),
      ],
    );
  }

  /// Construit le conteneur circulaire de la photo
  Widget _buildPhotoContainer(UserProfileEntity profile, String? imageUrl) {
    return Container(
      width: 200,
      height: 200,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: const Color(0xFF6366F1), width: 3),
      ),
      child: ClipOval(
        child: _getPhotoContent(profile, imageUrl),
      ),
    );
  }

  /// Retourne le contenu de la photo (image locale, rÃ©seau ou icÃ´ne par dÃ©faut)
  Widget _getPhotoContent(UserProfileEntity profile, String? imageUrl) {
    // Cas 1: Image sÃ©lectionnÃ©e localement (avant upload)
    if (_selectedImage != null) {
      return Image.file(
        File(_selectedImage!.path),
        fit: BoxFit.cover,
      );
    }

    // Cas 2: Image distante (dÃ©jÃ  uploadÃ©e)
    if (imageUrl != null) {
      return _buildNetworkImage(imageUrl);
    }

    // Cas 3: Pas de photo, icÃ´ne par dÃ©faut
    return _buildDefaultAvatar();
  }

  /// Construit une image rÃ©seau avec CachedNetworkImage
  Widget _buildNetworkImage(String imageUrl) {
    return CachedNetworkImage(
      imageUrl: imageUrl,
      fit: BoxFit.cover,
      placeholder: (context, url) => _buildImagePlaceholder(),
      errorWidget: (context, url, error) {
        print('Erreur chargement photo: $error');
        return _buildErrorImage();
      },
    );
  }

  /// Placeholder pendant le chargement de l'image rÃ©seau
  Widget _buildImagePlaceholder() {
    return Container(
      color: const Color(0xFF1E1E3F),
      child: const Center(
        child: CircularProgressIndicator(
          color: Color(0xFF6366F1),
          strokeWidth: 2,
        ),
      ),
    );
  }

  /// Affichage en cas d'erreur de chargement
  Widget _buildErrorImage() {
    return Container(
      color: const Color(0xFF1E1E3F),
      child: const Center(
        child: Icon(
          Icons.broken_image,
          size: 50,
          color: Colors.white54,
        ),
      ),
    );
  }

  /// Avatar par dÃ©faut (quand pas de photo)
  Widget _buildDefaultAvatar() {
    return Container(
      color: const Color(0xFF1E1E3F),
      child: const Center(
        child: Icon(
          Icons.person,
          size: 80,
          color: Color(0xFF6366F1),
        ),
      ),
    );
  }

  /// Loader superposÃ© pendant l'upload ou la suppression
  Widget _buildPhotoLoader() {
    return Positioned.fill(
      child: Container(
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: Colors.black54,
        ),
        child: const Center(
          child: CircularProgressIndicator(
            color: Color(0xFF6366F1),
          ),
        ),
      ),
    );
  }

  /// Badge de confirmation (check) quand une photo est prÃ©sente
  Widget _buildPhotoBadge() {
    return Positioned(
      bottom: 10,
      right: 10,
      child: Container(
        padding: const EdgeInsets.all(6),
        decoration: const BoxDecoration(
          color: Color(0xFF6366F1),
          shape: BoxShape.circle,
        ),
        child: const Icon(
          Icons.check,
          color: Colors.white,
          size: 16,
        ),
      ),
    );
  }

  /// Boutons pour choisir la source de l'image (galerie ou appareil photo)
  Widget _buildPhotoActionButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _buildPhotoButton(
          icon: Icons.photo_library,
          label: 'Galerie',
          onTap: _isPhotoLoading ? null : () => _pickImage(ImageSource.gallery),
        ),
        _buildPhotoButton(
          icon: Icons.photo_camera,
          label: 'Appareil photo',
          onTap: _isPhotoLoading ? null : () => _pickImage(ImageSource.camera),
        ),
      ],
    );
  }

  /// Bouton de suppression de la photo
  Widget _buildDeleteButton(UserProfileEntity profile) {
    if (!(profile.hasPhoto || _selectedImage != null) || _isPhotoLoading) {
      return const SizedBox.shrink(); // Rien Ã  afficher
    }

    return TextButton(
      onPressed: _deletePhoto,
      style: TextButton.styleFrom(
        foregroundColor: Colors.red,
      ),
      child: const Text('Supprimer la photo'),
    );
  }

  /// Informations de debug (URL de la photo)
  Widget _buildDebugInfo(String? imageUrl) {
    if (imageUrl == null || !kDebugMode || _isPhotoLoading) {
      return const SizedBox.shrink();
    }

    return Padding(
      padding: const EdgeInsets.only(top: 20),
      child: Text(
        'URL: $imageUrl',
        style: const TextStyle(color: Colors.white54, fontSize: 10),
        textAlign: TextAlign.center,
      ),
    );
  }

  /// Bouton individuel pour les actions photo
  Widget _buildPhotoButton({
    required IconData icon,
    required String label,
    required VoidCallback? onTap,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Opacity(
        opacity: onTap == null ? 0.5 : 1.0,
        child: Column(
          children: [
            Container(
              width: 60,
              height: 60,
              decoration: BoxDecoration(
                color: const Color(0xFF1E1E3F),
                shape: BoxShape.circle,
              ),
              child: Icon(icon, color: const Color(0xFF6366F1), size: 30),
            ),
            const SizedBox(height: 8),
            Text(
              label,
              style: const TextStyle(color: Colors.white70),
            ),
          ],
        ),
      ),
    );
  }


}


FICHIER: flutter_lib/providers/auth_provider.dart
--------------------------------------------------------------------------------
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../services/api_service.dart';
import '../services/auth_service.dart';

// Provider pour FlutterSecureStorage (sÃ©parÃ© pour Ã©viter les dÃ©pendances circulaires)
final secureStorageProvider = Provider<FlutterSecureStorage>((ref) {
  return const FlutterSecureStorage();
});

// Provider pour Dio
final dioProvider = Provider<Dio>((ref) {
  return Dio();
});

// Provider pour ApiService (sans rÃ©fÃ©rence Ã  authStateNotifierProvider)
final apiServiceProvider = Provider<ApiService>((ref) {
  final dio = ref.watch(dioProvider);
  final storage = ref.watch(secureStorageProvider);
  return ApiService(dio: dio, storage: storage);
});

// Provider pour AuthService
final authServiceProvider = Provider<AuthService>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthService(
    onAuthenticationEvent: (event) async {
      print('Authentication event: $event');
    },
    onAuthenticationError: (error) async {
      print('Authentication error: $error');
    },
    apiService: apiService,
  );
});

// Stream provider pour les changements d'Ã©tat Firebase
final authStateProvider = StreamProvider<User?>((ref) {
  final authService = ref.watch(authServiceProvider);
  return authService.authStateChanges;
});

// Provider pour l'utilisateur courant Firebase
final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authServiceProvider).currentUser;
});

// Provider pour rÃ©cupÃ©rer le JWT applicatif (version FutureProvider)
final appJwtProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getAppJwt();
});

// Provider pour rÃ©cupÃ©rer le refresh token
final refreshTokenProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getRefreshToken();
});

// ============================================================
// GESTION COMPLÃˆTE DE L'AUTH
// ============================================================

// Enum pour les diffÃ©rents statuts d'authentification
enum AuthStatus {
  initial,           // Non connectÃ©
  authenticated,     // Firebase OK mais JWT en cours
  fullyAuthenticated, // Firebase + JWT OK
  error,             // Erreur
}

// Classe reprÃ©sentant l'Ã©tat d'authentification complet
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? jwtToken;
  final String? refreshToken;
  final Object? error;

  const AuthState({
    required this.status,
    this.user,
    this.jwtToken,
    this.refreshToken,
    this.error,
  });

  static const AuthState initial = AuthState(status: AuthStatus.initial);

  const AuthState.authenticated(User user) : this(
    status: AuthStatus.authenticated,
    user: user,
  );

  const AuthState.fullyAuthenticated({
    required User user,
    required String jwtToken,
    String? refreshToken,
  }) : this(
    status: AuthStatus.fullyAuthenticated,
    user: user,
    jwtToken: jwtToken,
    refreshToken: refreshToken,
  );

  const AuthState.error(Object error) : this(
    status: AuthStatus.error,
    error: error,
  );

  // MÃ©thodes utilitaires
  bool get isFullyAuthenticated => status == AuthStatus.fullyAuthenticated;
  bool get isAuthenticated => status == AuthStatus.authenticated || status == AuthStatus.fullyAuthenticated;
  bool get isInitial => status == AuthStatus.initial;
  bool get hasError => status == AuthStatus.error;

  // MÃ©thode copyWith
  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? jwtToken,
    String? refreshToken,
    Object? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      jwtToken: jwtToken ?? this.jwtToken,
      refreshToken: refreshToken ?? this.refreshToken,
      error: error ?? this.error,
    );
  }

  @override
  String toString() {
    return 'AuthState(status: $status, user: ${user?.uid ?? 'null'}, hasJwt: ${jwtToken != null}, hasRefresh: ${refreshToken != null})';
  }
}

// StateNotifier pour gÃ©rer l'Ã©tat d'authentification complet
class AuthStateNotifier extends StateNotifier<AuthState> {
  final AuthService _authService;
  final Ref _ref;
  StreamSubscription<User?>? _authSubscription;

  AuthStateNotifier({
    required AuthService authService,
    required Ref ref,
  }) : _authService = authService,
        _ref = ref,
        super(AuthState.initial) {
    _init();
  }

  Future<void> _init() async {
    print('ğŸŸ¡ [NOTIFIER] Initialisation...');

    // Configurer le callback unauthorized dans ApiService APRÃˆS la crÃ©ation
    // Mais on ne peut pas le faire ici car Ã§a crÃ©erait une dÃ©pendance circulaire
    // On va plutÃ´t le faire depuis le main ou depuis un provider sÃ©parÃ©

    // Ã‰couter DIRECTEMENT le stream Firebase Auth (plus fiable)
    _authSubscription = _authService.authStateChanges.listen(
          (user) {
        print('ğŸ”µ [NOTIFIER] Firebase Auth State Change: ${user?.uid ?? 'null'}');

        if (user != null) {
          print('âœ… [NOTIFIER] Utilisateur Firebase connectÃ©');
          state = AuthState.authenticated(user);
          _checkTokens(user);
        } else {
          print('âŒ [NOTIFIER] Utilisateur Firebase DÃ‰CONNECTÃ‰ - RÃ©initialisation');
          state = AuthState.initial;
        }
      },
      onError: (error) {
        print('âŒ [NOTIFIER] Erreur auth stream: $error');
        state = AuthState.error(error);
      },
    );

    // Garder le listener du provider pour compatibilitÃ©
    _ref.listen(authStateProvider, (previous, next) {
      next.whenData((user) {
        print('ğŸŸ¡ [PROVIDER] authStateProvider: ${user?.uid ?? 'null'}');
      });
    });

    // Ã‰couter les Ã©vÃ©nements d'authentification
    _authService.onAuthenticationEvent = (event) async {
      if (event is GoogleSignInAuthenticationEventSignIn) {
        print('ğŸ“¡ [NOTIFIER] Ã‰vÃ©nement d\'authentification reÃ§u');

        const maxAttempts = 10;
        var attempts = 0;
        String? jwt;
        String? refreshToken;

        while (attempts < maxAttempts) {
          await Future.delayed(const Duration(milliseconds: 300));
          jwt = await _authService.getAppJwt();
          refreshToken = await _authService.getRefreshToken();
          if (jwt != null && jwt.isNotEmpty) {
            break;
          }
          attempts++;
        }

        final user = _authService.currentUser;

        if (jwt != null && jwt.isNotEmpty && user != null) {
          state = AuthState.fullyAuthenticated(
            user: user,
            jwtToken: jwt,
            refreshToken: refreshToken,
          );
          print('âœ… [NOTIFIER] Authentification complÃ¨te (Firebase + JWT)');
        } else if (user != null) {
          state = AuthState.authenticated(user);
          print('âš ï¸ [NOTIFIER] Firebase authentifiÃ© mais JWT manquant');
        }
      }
    };

    // Ã‰couter les erreurs d'authentification
    _authService.onAuthenticationError = (error) async {
      state = AuthState.error(error);
      print('âŒ [NOTIFIER] Erreur d\'authentification: $error');
    };
  }

  Future<void> _checkTokens(User user) async {
    try {
      final existingJwt = await _authService.getAppJwt();
      final existingRefresh = await _authService.getRefreshToken();

      if (existingJwt != null && existingJwt.isNotEmpty) {
        state = AuthState.fullyAuthenticated(
          user: user,
          jwtToken: existingJwt,
          refreshToken: existingRefresh,
        );
        print('âœ… [NOTIFIER] Tokens dÃ©jÃ  prÃ©sents');
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur vÃ©rification tokens: $e');
    }
  }

  /*
  // Nouvelle mÃ©thode pour gÃ©rer les erreurs 401
  Future<void> handleUnauthorized() async {
    print('âš ï¸ [NOTIFIER] Erreur 401 - Tentative de refresh token...');

    try {
      final newToken = await _authService.refreshJwtToken();

      if (newToken != null && state.user != null) {
        final refreshToken = await _authService.getRefreshToken();
        state = AuthState.fullyAuthenticated(
          user: state.user!,
          jwtToken: newToken,
          refreshToken: refreshToken,
        );
        print('âœ… [NOTIFIER] Token rafraÃ®chi avec succÃ¨s');
      } else {
        // Impossible de rafraÃ®chir, dÃ©connexion
        print('âŒ [NOTIFIER] Ã‰chec du refresh - DÃ©connexion');
        await signOut();
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur handleUnauthorized: $e');
      await signOut();
    }
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ [NOTIFIER] signOut() appelÃ©');

    try {
      state = AuthState.initial;
      await _authService.signOut();

      final userAfter = _authService.currentUser;
      print('ğŸ‘¤ [NOTIFIER] Utilisateur aprÃ¨s service.signOut(): ${userAfter?.uid ?? 'null'}');

      await Future.delayed(const Duration(milliseconds: 200));

      if (_authService.currentUser != null) {
        print('âš ï¸ [NOTIFIER] Utilisateur toujours connectÃ© - tentative de force');
        await _authService.forceSignOut();
        state = AuthState.initial;
      }

      print('âœ… [NOTIFIER] signOut() terminÃ©');
    } catch (e, stack) {
      print('âŒ [NOTIFIER] Erreur signOut: $e');
      print('ğŸ“š [NOTIFIER] Stack: $stack');
      state = AuthState.initial;
      rethrow;
    }
  }

  // MÃ©thode pour rÃ©initialiser manuellement l'Ã©tat
  void reset() {
    print('ğŸŸ¡ [NOTIFIER] reset() appelÃ©');
    state = AuthState.initial;
  }

  // MÃ©thode pour forcer une erreur
  void setError(Object error) {
    print('âŒ [NOTIFIER] setError(): $error');
    state = AuthState.error(error);
  }

  @override
  void dispose() {
    _authSubscription?.cancel();
    super.dispose();
  }
}

// StateNotifierProvider
final authStateNotifierProvider = StateNotifierProvider<AuthStateNotifier, AuthState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return AuthStateNotifier(
    authService: authService,
    ref: ref,
  );
});

// Providers utilitaires
final isFullyAuthenticatedProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.isFullyAuthenticated;
});

final appJwtSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.jwtToken;
});

final refreshTokenSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.refreshToken;
});

final currentUserSyncProvider = Provider<User?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.user;
});

final isAuthenticatingProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.status == AuthStatus.authenticated;
});

final authErrorProvider = Provider<Object?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.error;
});

/*
// Provider sÃ©parÃ© pour configurer le callback unauthorized (Ã  utiliser dans main.dart)
final unauthorizedCallbackProvider = Provider<void Function()>((ref) {
  return () {
    // Cette fonction sera appelÃ©e quand une erreur 401 non rÃ©cupÃ©rable survient
    ref.read(authStateNotifierProvider.notifier).handleUnauthorized();
  };
});

 */


FICHIER: flutter_lib/services/account_service.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'api_service.dart';

part 'account_service.g.dart';

class AccountService {
  final ApiService _apiService;

  AccountService({required ApiService apiService}) : _apiService = apiService;

  // Profile
  Future<Map<String, dynamic>> getProfile() async {
    return _apiService.getProfile();
  }

  Future<Map<String, dynamic>> getAboutMe() async {
    return _apiService.getAboutMe();
  }

  Future<Map<String, dynamic>> getPhoto() async {
    return _apiService.getPhoto();
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    await _apiService.updateProfile(
      displayName: displayName,
      gender: gender,
      birthdate: birthdate,
    );
  }

  Future<void> updateAboutMe(String aboutMe) async {
    await _apiService.updateAboutMe(aboutMe);
  }

  Future<void> updatePhoto(String photoPath) async {
    await _apiService.updatePhoto(photoPath);
  }
}

@riverpod
AccountService accountService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AccountService(apiService: apiService);
}


FICHIER: flutter_lib/services/account_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountService)
final accountServiceProvider = AccountServiceProvider._();

final class AccountServiceProvider
    extends $FunctionalProvider<AccountService, AccountService, AccountService>
    with $Provider<AccountService> {
  AccountServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountServiceHash();

  @$internal
  @override
  $ProviderElement<AccountService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  AccountService create(Ref ref) {
    return accountService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountService>(value),
    );
  }
}

String _$accountServiceHash() => r'b1473d081de813201df44ed2b261f6b3f8538fee';



FICHIER: flutter_lib/services/api_service.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:developer';
import 'dart:ui';

import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'api_service.g.dart';

class ApiException implements Exception {
  final String message;
  final int? statusCode;
  final dynamic originalError;

  ApiException({
    required this.message,
    this.statusCode,
    this.originalError,
  });

  @override
  String toString() => 'ApiException: $message (Status: $statusCode)';
}

class ApiService {
  final Dio _dio;
  final FlutterSecureStorage _storage;
  static const _baseUrl = 'http://192.168.1.56:8101/api';

  // Callback pour la dÃ©connexion en cas d'Ã©chec de refresh
  VoidCallback? onUnauthorized;

  ApiService({
    required Dio dio,
    required FlutterSecureStorage storage,
  })  : _dio = dio,
        _storage = storage {
    _dio.options.baseUrl = _baseUrl;
    _dio.options.headers['accept'] = 'application/json';
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.connectTimeout = const Duration(seconds: 10);
    _dio.options.receiveTimeout = const Duration(seconds: 10);

    _dio.interceptors.add(LogInterceptor(requestBody: true, responseBody: true));

    // Ajouter l'intercepteur pour le refresh token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {
          // Ne pas ajouter le token pour les endpoints d'auth
          if (!options.path.contains('/auth/refresh') &&
              !options.path.contains('/auth/login') &&
              !options.path.contains('/users/jwt-by-firebase-token')) {

            final token = await _storage.read(key: 'app_jwt_token');

            if (token != null) {
              options.headers['Authorization'] = 'Bearer $token';
            }
          }

          return handler.next(options);
        },
        onError: (error, handler) async {
          // Si erreur 401 et que ce n'est pas dÃ©jÃ  une tentative de refresh
          if (error.response?.statusCode == 401 &&
              !error.requestOptions.path.contains('/auth/refresh')) {

            try {
              // Tenter de rafraÃ®chir le token
              final newToken = await _refreshToken();

              if (newToken != null) {
                // Rejouer la requÃªte originale avec le nouveau token
                final options = error.requestOptions;
                options.headers['Authorization'] = 'Bearer $newToken';

                final response = await _dio.fetch(options);
                return handler.resolve(response);
              }
            } catch (refreshError) {
              print('âŒ Erreur lors du refresh: $refreshError');
            }

            // Si le refresh Ã©choue, notifier pour dÃ©connecter l'utilisateur
            if (onUnauthorized != null) {
              onUnauthorized!();
            }
          }

          return handler.next(error);
        },
      ),
    );
  }

  bool _isRefreshing = false;
  final List<Completer<String?>> _refreshCompleters = [];

  Future<String?> _refreshToken() async {
    if (_isRefreshing) {
      // Si un refresh est dÃ©jÃ  en cours, attendre son rÃ©sultat
      final completer = Completer<String?>();
      _refreshCompleters.add(completer);
      return completer.future;
    }

    _isRefreshing = true;
    final completer = Completer<String?>();
    _refreshCompleters.add(completer);

    try {
      final refreshToken = await _storage.read(key: 'refresh_token');

      if (refreshToken == null) {
        throw Exception('No refresh token');
      }

      final appJwtToken = await _storage.read(key: 'app_jwt_token');

      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
            extra: {'noToken': true},
            headers: {'Authorization': 'Bearer $appJwtToken'}
        ),
      );

      if (response.statusCode == 200) {
        final newToken = response.data['token'];
        final newRefreshToken = response.data['refresh_token'];

        await _storage.write(key: 'app_jwt_token', value: newToken);
        if (newRefreshToken != null) {
          await _storage.write(key: 'refresh_token', value: newRefreshToken);
        }

        // RÃ©soudre tous les completer en attente
        for (final c in _refreshCompleters) {
          c.complete(newToken);
        }

        return newToken;
      }
    } catch (e) {
      print('âŒ Erreur refresh token: $e');
      // En cas d'erreur, Ã©chouer tous les completer
      for (final c in _refreshCompleters) {
        c.completeError(e);
      }
    } finally {
      _isRefreshing = false;
      _refreshCompleters.clear();
    }

    return null;
  }

  // MÃ©thode gÃ©nÃ©rique pour gÃ©rer les requÃªtes avec gestion d'erreur centralisÃ©e
  Future<T> safeApiCall<T>({
    required Future<T> Function() apiCall,
    String? errorMessage,
  }) async {
    try {
      return await apiCall();
    } on DioException catch (e) {
      throw _handleDioError(e, errorMessage);
    } catch (e) {
      throw ApiException(
        message: errorMessage ?? 'Une erreur inattendue est survenue',
        originalError: e,
      );
    }
  }

  ApiException _handleDioError(DioException e, String? customMessage) {
    String message;
    int? statusCode = e.response?.statusCode;

    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        message = 'DÃ©lai de connexion dÃ©passÃ©';
        break;
      case DioExceptionType.badResponse:
        message = _parseErrorResponse(e.response);
        break;
      case DioExceptionType.cancel:
        message = 'RequÃªte annulÃ©e';
        break;
      case DioExceptionType.connectionError:
        message = 'Erreur de connexion rÃ©seau';
        break;
      default:
        message = customMessage ?? 'Erreur rÃ©seau inconnue';
    }

    return ApiException(
      message: message,
      statusCode: statusCode,
      originalError: e,
    );
  }

  String _parseErrorResponse(Response? response) {
    try {
      if (response?.data != null && response!.data is Map) {
        return response.data['message'] ??
            response.data['error'] ??
            'Erreur serveur (${response.statusCode})';
      }
      return 'Erreur serveur (${response?.statusCode ?? 'inconnue'})';
    } catch (_) {
      return 'Erreur serveur inconnue';
    }
  }

  // MÃ©thodes API spÃ©cifiques
  Future<Map<String, dynamic>> getJwtFromFirebaseToken(String firebaseToken) async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.post(
          '/users/jwt-by-firebase-token',
          data: {'token': firebaseToken},
          options: Options(extra: {'noToken': true}),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la rÃ©cupÃ©ration du JWT',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le token JWT',
    );
  }

  // Nouvelle mÃ©thode pour rÃ©voquer le refresh token (logout)
  Future<void> revokeRefreshToken(String refreshToken) async {
    try {
      final token = await _storage.read(key: 'app_jwt_token');
      await _dio.post(
        '/auth/logout',
        data: {'refresh_token': refreshToken},
        options: Options(
          headers: token != null ? {'Authorization': 'Bearer $token'} : {},
          extra: {'noToken': true},
        ),
      );
    } catch (e) {
      print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
    }
  }

  Future<Map<String, dynamic>> generateLiveKitToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return safeApiCall(
      apiCall: () async {
        final payload = {
          "participant_identity": participantIdentity,
          "participant_name": participantName,
          "participant_metadata": participantMetadata,
          "participant_attributes": participantAttributes,
          "room_name": roomName,
          "room_config": roomConfig
        };

        final appJwt = await _storage.read(key: 'app_jwt_token');

        if (appJwt == null) {
          throw ApiException(message: 'JWT token non disponible');
        }

        final response = await _dio.post(
          '/sfu/generate-token',
          data: payload,
          options: Options(
            headers: {
              'Authorization': 'Bearer $appJwt',
            },
          ),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la gÃ©nÃ©ration du token LiveKit',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de gÃ©nÃ©rer le token LiveKit',
    );
  }

  // Profile methods
  Future<Map<String, dynamic>> getProfile() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/me');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le profil',
    );
  }

  Future<Map<String, dynamic>> getAboutMe() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/about-me');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer "Ã  propos"',
    );
  }

  Future<Map<String, dynamic>> getPhoto() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/photo');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer la photo',
    );
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    return safeApiCall(
      apiCall: () async {
        final data = <String, dynamic>{};
        if (displayName != null) data['displayName'] = displayName;
        if (gender != null) data['gender'] = gender;
        if (birthdate != null) data['birthdate'] = birthdate.toIso8601String();

        await _dio.put('/account/me', data: data);
      },
      errorMessage: 'Impossible de mettre Ã  jour le profil',
    );
  }

  Future<void> updateAboutMe(String aboutMe) async {
    return safeApiCall(
      apiCall: () async {
        await _dio.put('/account/about-me', data: {'about_me': aboutMe});
      },
      errorMessage: 'Impossible de mettre Ã  jour "Ã  propos"',
    );
  }

  Future<void> updatePhoto(String photoPath) async {
    return safeApiCall(
      apiCall: () async {
        final formData = FormData.fromMap({
          'photo': await MultipartFile.fromFile(photoPath),
        });
        await _dio.put('/account/photo', data: formData);
      },
      errorMessage: 'Impossible de mettre Ã  jour la photo',
    );
  }


// Dans flutter_lib/services/api_service.dart

  Future<Map<String, dynamic>?> refreshJwtToken(String refreshToken) async {
    try {
      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
          extra: {'noToken': true},
        ),
      );

      if (response.statusCode == 200) {
        return response.data as Map<String, dynamic>;
      }
    } catch (e) {
      print('âŒ Erreur refresh token API: $e');
    }

    return null;
  }


}

@riverpod
ApiService apiService(Ref ref) {
  final dio = Dio();
  final storage = const FlutterSecureStorage();
  return ApiService(dio: dio, storage: storage);
}


FICHIER: flutter_lib/services/api_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'api_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(apiService)
final apiServiceProvider = ApiServiceProvider._();

final class ApiServiceProvider
    extends $FunctionalProvider<ApiService, ApiService, ApiService>
    with $Provider<ApiService> {
  ApiServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'apiServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$apiServiceHash();

  @$internal
  @override
  $ProviderElement<ApiService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  ApiService create(Ref ref) {
    return apiService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ApiService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ApiService>(value),
    );
  }
}

String _$apiServiceHash() => r'eb9a66cc54e1c15d5870b8da260d4ea1f6b053ac';



FICHIER: flutter_lib/services/auth_service.dart
--------------------------------------------------------------------------------
import 'dart:developer';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'api_service.dart';

class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final ApiService _apiService;

  final _storage = const FlutterSecureStorage();

  static const _tokenKey = 'firebase_id_token';
  static const _appJwtKey = 'app_jwt_token';
  static const _refreshTokenKey = 'refresh_token';
  static const _userIdentityKey = 'connected_user_identity';
  static const _userDisplayNameKey = 'connected_user_displayname';

  Future<void> Function(GoogleSignInAuthenticationEvent)? onAuthenticationEvent;
  Future<void> Function(Object)? onAuthenticationError;

  AuthService({
    this.onAuthenticationEvent,
    this.onAuthenticationError,
    required ApiService apiService,
  }) : _apiService = apiService;

  User? get currentUser => _firebaseAuth.currentUser;

  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

  bool _isSignInInitialized = false;

  String? clientId;
  String? serverClientId = '1084343369802-36565dmgarm2gkos54eb6j9q6so0s9bf.apps.googleusercontent.com';
  List<String> scopes = <String>[
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
  ];
  final GoogleSignIn signIn = GoogleSignIn.instance;

  Future<void> _handleAuthenticationEvent(GoogleSignInAuthenticationEvent event) async {
    final GoogleSignInAccount? user = switch (event) {
      GoogleSignInAuthenticationEventSignIn() => event.user,
      GoogleSignInAuthenticationEventSignOut() => null,
    };

    final GoogleSignInClientAuthorization? authorization = await user?.authorizationClient.authorizationForScopes(scopes);

    if (user != null && authorization != null) {
      print(user);
      print("===== user =======");

      try {
        final OAuthCredential googleCredential = GoogleAuthProvider.credential(
          accessToken: authorization.accessToken,
          idToken: user.authentication.idToken,
        );

        final UserCredential googleUserCredential = await FirebaseAuth.instance.signInWithCredential(googleCredential);

        IdTokenResult tokenResult = await FirebaseAuth.instance.currentUser!.getIdTokenResult();

        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        log(tokenResult.token.toString());

        if (tokenResult.token != null) {
          await _storage.write(key: _tokenKey, value: tokenResult.token);
          await _storage.write(key: _userIdentityKey, value: user.displayName);
          await _storage.write(key: _userDisplayNameKey, value: user.displayName);

          try {
            print('ğŸ”„ RÃ©cupÃ©ration du JWT applicatif... =======================================');
            final response = await _apiService.getJwtFromFirebaseToken(tokenResult.token!);

            // La rÃ©ponse contient maintenant jwt ET refresh_token
            if (response is Map<String, dynamic>) {
              print('TOKEN ==============');
              log('***** from firebase token : ' + response['token'].toString());
              await _storage.write(key: _appJwtKey, value: response['token']);
              if (response['refresh_token'] != null) {
                print('REFRESH TOKEN ==============');
                print(response['refresh_token']);
                await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
              }
            } else {
              // Pour compatibilitÃ© avec l'ancien format
              await _storage.write(key: _appJwtKey, value: response.toString());
            }

            print('âœ… JWT applicatif rÃ©cupÃ©rÃ© et stockÃ©');
          } catch (e) {
            print('âŒ Erreur lors de la rÃ©cupÃ©ration du JWT applicatif: $e');
          }

          if (onAuthenticationEvent != null) {
            await onAuthenticationEvent!(event);
          }

          print(tokenResult.token);
          print("====== tokenResult.token =======");
        }
      } catch (error) {
        print(error);
        print('error');

        if (onAuthenticationError != null) {
          await onAuthenticationError!(error);
        }
      }
    }
  }

  Future<void> _handleAuthenticationError(Object e) async {
    print(e);
    if (onAuthenticationError != null) {
      await onAuthenticationError!(e);
    }
  }

  Future<void> initGoogleSignIn() async {
    if (_isSignInInitialized) return;

    _isSignInInitialized = true;

    await signIn.initialize(clientId: clientId, serverClientId: serverClientId).then((_) async {
      signIn.authenticationEvents.listen(_handleAuthenticationEvent).onError(_handleAuthenticationError);
    });
  }

  Future<User?> signInWithGoogle() async {
    await initGoogleSignIn();

    if (GoogleSignIn.instance.supportsAuthenticate()) {
      try {
        await GoogleSignIn.instance.authenticate();
      } catch (e) {
        print("Erreur Google Sign-In : $e");
      }
    }
  }

  Future<String?> getAppJwt() async {
    return await _storage.read(key: _appJwtKey);
  }

  Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }

  /*
  // Nouvelle mÃ©thode pour rafraÃ®chir le token
  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ DÃ‰BUT DÃ‰CONNEXION - Utilisateur avant: ${_firebaseAuth.currentUser?.uid}');

    try {
      // 1. RÃ©voquer le refresh token cÃ´tÃ© serveur
      final refreshToken = await getRefreshToken();
      if (refreshToken != null) {
        try {
          await _apiService.revokeRefreshToken(refreshToken);
          print('âœ… Refresh token rÃ©voquÃ© cÃ´tÃ© serveur');
        } catch (e) {
          print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
        }
      }

      // 2. DÃ©connexion Google
      await GoogleSignIn.instance.signOut();

      // 3. DÃ©connexion Firebase
      print('ğŸŸ¡ DÃ©connexion Firebase...');
      await _firebaseAuth.signOut();
      print('âœ… Firebase signOut() exÃ©cutÃ©');

      // 4. VÃ©rification post-dÃ©connexion
      final userAfter = _firebaseAuth.currentUser;
      print('ğŸ‘¤ Utilisateur aprÃ¨s Firebase.signOut(): $userAfter');

      // 5. Attendre un cycle d'event loop pour propager le changement
      await Future.delayed(const Duration(milliseconds: 100));

      // 6. Nettoyer le stockage
      print('ğŸŸ¡ Nettoyage du stockage...');
      await _storage.delete(key: _tokenKey);
      await _storage.delete(key: _appJwtKey);
      await _storage.delete(key: _refreshTokenKey);
      await _storage.delete(key: _userIdentityKey);
      await _storage.delete(key: _userDisplayNameKey);
      print('âœ… Stockage nettoyÃ©');

      // 7. VÃ©rification finale
      final finalUser = _firebaseAuth.currentUser;
      if (finalUser != null) {
        print('âš ï¸ ATTENTION: Utilisateur toujours prÃ©sent aprÃ¨s dÃ©connexion!');
        await forceSignOut();
      } else {
        print('âœ… Utilisateur bien null aprÃ¨s dÃ©connexion');
      }

      print('âœ… DÃ‰CONNEXION TERMINÃ‰E');
    } catch (e, stack) {
      print('âŒ ERREUR DÃ‰CONNEXION: $e');
      print('ğŸ“š Stack: $stack');
      rethrow;
    }
  }

  // MÃ©thode utilitaire pour forcer une dÃ©connexion radicale
  Future<void> forceSignOut() async {
    print('ğŸ”´ FORCE SIGN OUT - MÃ©thode radicale');

    try {
      await _firebaseAuth.signOut();
      await GoogleSignIn.instance.signOut();
      await _storage.deleteAll();
      await Future.delayed(const Duration(milliseconds: 200));
      print('âœ… Force sign out exÃ©cutÃ©');
      print('ğŸ‘¤ Utilisateur aprÃ¨s force: ${_firebaseAuth.currentUser?.uid ?? 'null'}');
    } catch (e) {
      print('âŒ Erreur force sign out: $e');
    }
  }

  bool isLoggedIn() {
    return _firebaseAuth.currentUser != null;
  }

  Future<bool> isUserLoggedIn() async {
    return _firebaseAuth.currentUser != null;
  }


  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }
}


FICHIER: flutter_lib/services/sfu_service.dart
--------------------------------------------------------------------------------
// CrÃ©er un nouveau fichier: flutter_lib/features/tables/services/sfu_service.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../services/api_service.dart';

part 'sfu_service.g.dart';

class SfuService {
  final ApiService _apiService;

  SfuService({required ApiService apiService}) : _apiService = apiService;

  Future<Map<String, dynamic>> generateToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return _apiService.generateLiveKitToken(
      participantIdentity: participantIdentity,
      participantName: participantName,
      participantAttributes: participantAttributes,
      participantMetadata: participantMetadata,
      roomName: roomName,
      roomConfig: roomConfig,
    );
  }
}

@riverpod
SfuService sfuService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return SfuService(apiService: apiService);
}


FICHIER: flutter_lib/services/sfu_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sfu_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(sfuService)
final sfuServiceProvider = SfuServiceProvider._();

final class SfuServiceProvider
    extends $FunctionalProvider<SfuService, SfuService, SfuService>
    with $Provider<SfuService> {
  SfuServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'sfuServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$sfuServiceHash();

  @$internal
  @override
  $ProviderElement<SfuService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  SfuService create(Ref ref) {
    return sfuService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(SfuService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<SfuService>(value),
    );
  }
}

String _$sfuServiceHash() => r'eec97a26458eb6027d15e5c5845938b8e56f520d';



FICHIER: src/Domain/Entity/User.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\Entity;

use App\Domain\ValueObject\Email;
use App\Domain\ValueObject\UserRole;

/**
 * Domain Entity - Aucune dÃ©pendance vers Doctrine ou Symfony
 */
class User
{
    private ?int $id = null;
    private Email $email;
    private array $roles = [];
    private string $password;
    private ?string $firstname = null;
    private ?string $lastname = null;
    private bool $isActive = true;
    private \DateTimeInterface $createdAt;
    private ?\DateTimeInterface $updatedAt = null;

    public function __construct(
        Email $email,
        string $hashedPassword,
        ?string $firstname = null,
        ?string $lastname = null
    ) {
        $this->email = $email;
        $this->password = $hashedPassword;
        $this->firstname = $firstname;
        $this->lastname = $lastname;
        $this->roles = [UserRole::ROLE_USER];
        $this->createdAt = new \DateTime();
    }

    public static function create(
        string $email,
        string $hashedPassword,
        ?string $firstname = null,
        ?string $lastname = null
    ): self {
        return new self(
            new Email($email),
            $hashedPassword,
            $firstname,
            $lastname
        );
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function getEmail(): Email
    {
        return $this->email;
    }

    public function changeEmail(Email $email): void
    {
        $this->email = $email;
        $this->markAsUpdated();
    }

    public function getRoles(): array
    {
        return array_unique($this->roles);
    }

    public function addRole(string $role): void
    {
        if (!in_array($role, $this->roles)) {
            $this->roles[] = $role;
            $this->markAsUpdated();
        }
    }

    public function removeRole(string $role): void
    {
        $this->roles = array_filter($this->roles, fn($r) => $r !== $role);
        $this->markAsUpdated();
    }

    public function hasRole(string $role): bool
    {
        return in_array($role, $this->roles);
    }

    public function getPassword(): string
    {
        return $this->password;
    }

    public function changePassword(string $hashedPassword): void
    {
        $this->password = $hashedPassword;
        $this->markAsUpdated();
    }

    public function getFirstname(): ?string
    {
        return $this->firstname;
    }

    public function setFirstname(?string $firstname): void
    {
        $this->firstname = $firstname;
        $this->markAsUpdated();
    }

    public function getLastname(): ?string
    {
        return $this->lastname;
    }

    public function setLastname(?string $lastname): void
    {
        $this->lastname = $lastname;
        $this->markAsUpdated();
    }

    public function getFullName(): string
    {
        return trim(($this->firstname ?? '') . ' ' . ($this->lastname ?? ''));
    }

    public function isActive(): bool
    {
        return $this->isActive;
    }

    public function activate(): void
    {
        $this->isActive = true;
        $this->markAsUpdated();
    }

    public function deactivate(): void
    {
        $this->isActive = false;
        $this->markAsUpdated();
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    private function markAsUpdated(): void
    {
        $this->updatedAt = new \DateTime();
    }
}


FICHIER: src/Domain/Repository/UserRepositoryInterface.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\Repository;

use App\Domain\ValueObject\Email;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;

/**
 * Repository Interface (Port) - Contrat du domaine
 */
interface UserRepositoryInterface
{
    public function save(UserEntity $user): void;

    public function delete(UserEntity $user): void;

    public function findById(int $id): ?UserEntity;

    public function findByEmail(Email $email): ?UserEntity;

    /**
     * @return UserEntity[]
     */
    public function findAll(): array;

    /**
     * @return UserEntity[]
     */
    public function findActiveUsers(): array;

    /**
     * @return UserEntity[]
     */
    public function findByRole(string $role): array;

    /**
     * @return UserEntity[]
     */
    public function search(string $searchTerm): array;

    public function countActiveUsers(): int;

    public function existsByEmail(Email $email): bool;
}



FICHIER: src/Domain/ValueObject/Email.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\ValueObject;

/**
 * Value Object Email
 */
class Email
{
    private string $value;

    public function __construct(string $email)
    {
        $this->validate($email);
        $this->value = strtolower($email);
    }

    private function validate(string $email): void
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \InvalidArgumentException(sprintf('"%s" is not a valid email', $email));
        }
    }

    public function getValue(): string
    {
        return $this->value;
    }

    public function __toString(): string
    {
        return $this->value;
    }

    public function equals(Email $other): bool
    {
        return $this->value === $other->value;
    }
}


FICHIER: src/Domain/ValueObject/UserRole.php
--------------------------------------------------------------------------------
<?php
namespace App\Domain\ValueObject;

class UserRole
{
    public const ROLE_USER = 'ROLE_USER';
    public const ROLE_ADMIN = 'ROLE_ADMIN';
    public const ROLE_MODERATOR = 'ROLE_MODERATOR';

    private const VALID_ROLES = [
        self::ROLE_USER,
        self::ROLE_ADMIN,
        self::ROLE_MODERATOR,
    ];

    public static function isValid(string $role): bool
    {
        return in_array($role, self::VALID_ROLES);
    }

    public static function validate(string $role): void
    {
        if (!self::isValid($role)) {
            throw new \InvalidArgumentException(sprintf('Invalid role: %s', $role));
        }
    }
}


FICHIER: src/Infrastructure/Console/Command/ClearExpiredRefreshTokensCommand.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Console/Command/ClearExpiredRefreshTokensCommand.php

namespace App\Infrastructure\Console\Command;

use App\Infrastructure\Persistence\Doctrine\Repository\RefreshTokenRepository;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

#[AsCommand(
    name: 'app:clear-expired-refresh-tokens',
    description: 'Supprime les refresh tokens expirÃ©s'
)]
class ClearExpiredRefreshTokensCommand extends Command
{
    public function __construct(
        private readonly RefreshTokenRepository $refreshTokenRepository
    ) {
        parent::__construct();
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $deleted = $this->refreshTokenRepository->deleteExpired();
        $output->writeln(sprintf('%d refresh tokens expirÃ©s supprimÃ©s.', $deleted));

        return Command::SUCCESS;
    }
}



FICHIER: src/Infrastructure/Http/Controller/AccountController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Security\Http\Attribute\CurrentUser;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;

#[Route('/api/account')]
#[OA\Tag(name: 'account')]
class AccountController extends AbstractController
{
    private const PHOTO_UPLOAD_DIR = '/upload/photos';
    private const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    private const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    public function __construct(
        private readonly UserRepository $userRepository,
        private readonly SerializerInterface $serializer,
        private readonly ValidatorInterface $validator,
        private readonly string $projectDir,
    ) {}



    #[Route('/me', name: 'account_get_me', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les informations du compte',
        responses: [
            new OA\Response(
                response: 200,
                description: 'Informations du compte',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'string'),
                        new OA\Property(property: 'displayName', type: 'string', nullable: true),
                        new OA\Property(property: 'gender', type: 'integer', nullable: true),
                        new OA\Property(property: 'birthdate', type: 'string', format: 'date', nullable: true),
                        new OA\Property(property: 'about_me', type: 'string', nullable: true),
                        new OA\Property(property: 'has_photo', type: 'boolean'),
                        new OA\Property(property: 'photo_url', type: 'string', nullable: true),
                    ]
                )
            )
        ]
    )]
    public function getMe(#[CurrentUser] UserEntity $user): JsonResponse
    {
        // SÃ©curitÃ© : s'assurer que hasPhoto est initialisÃ©
        $hasPhoto = false;
        try {
            $hasPhoto = $user->hasPhoto();
        } catch (\Error $e) {
            $hasPhoto = false;
        }

        $firstAccess = false;
        try {
            $firstAccess = $user->isFirstAccess();
        } catch (\Error $e) {
            $firstAccess = false;
        }


        // Construire l'URL de la photo si elle existe
        $photoUrl = null;
        if ($hasPhoto) {
            // On suppose que la photo est en jpg, mais on pourrait dÃ©tecter l'extension rÃ©elle
            $photoUrl = '/api/photo/' . $user->getAuthUid() . '.jpg';
        }

        return $this->json([
            'id' => $user->getEmail() ?? $user->getAuthUid(),
            'displayName' => $user->getDisplayName() ?? $user->getUsername(),
            'gender' => $user->getGender(),
            'birthdate' => $user->getBirthdate()?->format('Y-m-d'),
            'about_me' => $user->getAboutMe(),
            'has_photo' => $hasPhoto,
            'first_access' => $firstAccess,
            'photo_url' => $photoUrl, // NOUVEAU
        ]);
    }



    #[Route('/me', name: 'account_update_me', methods: ['PUT'])]
    #[OA\Put(
        summary: 'Met Ã  jour les informations du compte',
        requestBody: new OA\RequestBody(
            content: new OA\JsonContent(
                properties: [
                    new OA\Property(property: 'displayName', type: 'string', nullable: true),
                    new OA\Property(property: 'gender', type: 'integer', nullable: true),
                    new OA\Property(property: 'birthdate', type: 'string', format: 'date', nullable: true),
                ]
            )
        )
    )]
    public function updateMe(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (isset($data['displayName'])) {
            $user->setDisplayName($data['displayName']);
        }

        if (isset($data['gender'])) {
            $user->setGender((int) $data['gender']);
        }

        if (isset($data['birthdate'])) {
            try {
                $user->setBirthdate(new \DateTime($data['birthdate']));
            } catch (\Exception $e) {
                return $this->json(['error' => 'Format de date invalide'], Response::HTTP_BAD_REQUEST);
            }
        }

        $errors = $this->validator->validate($user);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->userRepository->save($user);

        return $this->json(['success' => true]);
    }

    #[Route('/about-me', name: 'account_get_about_me', methods: ['GET'])]
    public function getAboutMe(#[CurrentUser] UserEntity $user): JsonResponse
    {
        return $this->json([
            'about_me' => $user->getAboutMe(),
        ]);
    }

    #[Route('/about-me', name: 'account_update_about_me', methods: ['PUT'])]
    public function updateAboutMe(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (isset($data['about_me'])) {
            $user->setAboutMe($data['about_me']);
            $this->userRepository->save($user);
        }

        return $this->json(['success' => true]);
    }

    #[Route('/photo', name: 'account_get_photo', methods: ['GET'])]
    public function getPhoto(#[CurrentUser] UserEntity $user): JsonResponse
    {
        $photoUrl = null;

        if ($user->hasPhoto()) {
            // Construire l'URL de la photo
            $photoUrl = '/uploads/photos/' . $user->getAuthUid() . '.jpg';
        }

        return $this->json([
            'photo_url' => $photoUrl,
            'has_photo' => $user->hasPhoto(),
        ]);
    }


    #[Route('/photo', name: 'account_delete_photo', methods: ['DELETE'])]
    public function deletePhoto(#[CurrentUser] UserEntity $user): JsonResponse
    {
        if (!$user->hasPhoto()) {
            return $this->json(['error' => 'Aucune photo Ã  supprimer'], Response::HTTP_BAD_REQUEST);
        }

        try {
            $this->deleteOldPhoto($user);
            $user->updatePhotoStatus(false);
            $this->userRepository->save($user);

            return $this->json([
                'success' => true,
                'message' => 'Photo supprimÃ©e avec succÃ¨s'
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Erreur lors de la suppression: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Valide le fichier photo
     */
    private function validatePhoto(UploadedFile $file): bool
    {
        // VÃ©rifier la taille
        if ($file->getSize() > self::MAX_FILE_SIZE) {
            return false;
        }

        // VÃ©rifier le type MIME
        $mimeType = $file->getMimeType();
        if (!in_array($mimeType, self::ALLOWED_MIME_TYPES)) {
            return false;
        }

        return true;
    }

    /**
     * Supprime l'ancienne photo
     */
    private function deleteOldPhoto(UserEntity $user): void
    {
        $uploadDir = $this->projectDir . self::PHOTO_UPLOAD_DIR;

        // Chercher tous les fichiers commenÃ§ant par l'auth_uid
        $pattern = $uploadDir . '/' . $user->getAuthUid() . '.*';
        $oldFiles = glob($pattern);

        foreach ($oldFiles as $file) {
            if (is_file($file)) {
                unlink($file);
            }
        }
    }

    #[Route('/photo', name: 'account_update_photo', methods: ['PUT'])]
    public function updatePhoto(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        /** @var UploadedFile|null $photo */
        $photo = $request->files->get('photo');

        if (!$photo) {
            return $this->json(['error' => 'Aucune photo fournie'], Response::HTTP_BAD_REQUEST);
        }

        // Validation du fichier
        if (!$this->validatePhoto($photo)) {
            return $this->json([
                'error' => 'Format de fichier invalide. Types acceptÃ©s: JPEG, PNG, GIF, WEBP. Taille max: 5MB'
            ], Response::HTTP_BAD_REQUEST);
        }

        try {
            // CrÃ©er le dossier d'upload s'il n'existe pas
            $uploadDir = $this->projectDir . self::PHOTO_UPLOAD_DIR;
            if (!is_dir($uploadDir)) {
                mkdir($uploadDir, 0755, true);
            }

            // GÃ©nÃ©rer un nom de fichier basÃ© sur l'auth_uid
            $extension = $photo->guessExtension() ?? 'jpg';
            $filename = $user->getAuthUid() . '.' . $extension;
            $filepath = $uploadDir . '/' . $filename;

            // Supprimer l'ancienne photo si elle existe
            if ($user->hasPhoto()) {
                $this->deleteOldPhoto($user);
            }

            // DÃ©placer le fichier
            $photo->move($uploadDir, $filename);

            // Mettre Ã  jour le statut has_photo
            $user->updatePhotoStatus(true);
            $this->userRepository->save($user);

            // Construire l'URL de la photo via notre nouveau controller
            $photoUrl = '/api/photo/' . $filename;

            return $this->json([
                'success' => true,
                'photo_url' => $photoUrl,
                'has_photo' => true,
                'message' => 'Photo tÃ©lÃ©chargÃ©e avec succÃ¨s'
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Erreur lors du tÃ©lÃ©chargement: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

}



FICHIER: src/Infrastructure/Http/Controller/AuthController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use OpenApi\Attributes as OA;

#[OA\Tag(name: 'auth')]
class AuthController extends AbstractController
{
    public function __construct(
        private UserPasswordHasherInterface $passwordHasher
    ) {}

    #[Route('/api/auth/login', name: 'api_auth_login', methods: ['POST'])]
    #[OA\Post(
        summary: 'Authentifie un utilisateur et renvoie un JWT',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                type: 'object',
                required: ['email', 'password'],
                properties: [
                    new OA\Property(property: 'email', type: 'string', example: 'user@example.com'),
                    new OA\Property(property: 'password', type: 'string', example: 'MonMotDePasse123!')
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Token JWT renvoyÃ©',
                content: new OA\JsonContent(
                    type: 'object',
                    properties: [
                        new OA\Property(property: 'token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIsInR5...')
                    ]
                )
            ),
            new OA\Response(response: 401, description: 'Identifiants invalides')
        ]
    )]
    public function login(): void
    {
        // Lexik gÃ¨re la logique, on ne met rien ici
    }

    #[Route('/api/auth/generate-password', name: 'api_auth_generate_password', methods: ['POST'])]
    #[OA\Post(
        summary: 'Hash un mot de passe en clair (utile pour tests ou crÃ©ation manuelle dâ€™utilisateurs).',
        requestBody: new OA\RequestBody(
            required: true,
            description: 'Mot de passe Ã  chiffrer',
            content: new OA\JsonContent(
                type: 'object',
                required: ['password'],
                properties: [
                    new OA\Property(property: 'password', type: 'string', example: 'MonMotDePasse123!')
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Mot de passe chiffrÃ© renvoyÃ© avec succÃ¨s',
                content: new OA\JsonContent(
                    type: 'object',
                    properties: [
                        new OA\Property(property: 'hash', type: 'string', example: '$2y$13$abc123...')
                    ]
                )
            )
        ]
    )]
    public function generatePassword(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        if (!isset($data['password']) || !is_string($data['password']) || $data['password'] === '') {
            return $this->json(['error' => 'Le champ "password" est requis.'], 400);
        }

        $plain = $data['password'];

        if (strlen($plain) < 8) {
            return $this->json(['error' => 'Le mot de passe doit faire au moins 8 caractÃ¨res.'], 400);
        }

        // Fake user conforme Ã  lâ€™interface PasswordAuthenticatedUserInterface
        $user = new class implements PasswordAuthenticatedUserInterface {
            public function getPassword(): ?string { return null; }
        };

        $hash = $this->passwordHasher->hashPassword($user, $plain);

        return $this->json(['hash' => $hash]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/GenerateLiveKitController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Agence104\LiveKit\AccessToken;
use Agence104\LiveKit\AccessTokenOptions;
use Agence104\LiveKit\VideoGrant;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/sfu/generate-token')]
#[OA\Tag(name: 'sfu')]
class GenerateLiveKitController extends AbstractController
{
    public function __construct(
        private readonly string $livekitApiKey,
        private readonly string $livekitApiSecret,
        private readonly string $livekitUrl,
    ) {
    }

    #[Route('', name: 'sfu_generate_token', methods: ['POST'])]
    #[OA\Post(
        description: 'GÃ©nÃ¨re un token JWT pour LiveKit SFU',
        summary: 'GÃ©nÃ©rer un token d\'accÃ¨s LiveKit',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['participant_identity', 'room_name'],
                properties: [
                    new OA\Property(property: 'participant_identity', type: 'string', description: 'Identifiant unique du participant'),
                    new OA\Property(property: 'participant_name', type: 'string', description: 'Nom du participant'),
                    new OA\Property(property: 'participant_metadata', type: 'string', description: 'MÃ©tadonnÃ©es du participant'),
                    new OA\Property(property: 'participant_attributes', type: 'object', description: 'Attributs du participant'),
                    new OA\Property(property: 'room_name', type: 'string', description: 'Nom de la salle'),
                    new OA\Property(property: 'room_config', type: 'object', description: 'Configuration de la salle'),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Token gÃ©nÃ©rÃ© avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'server_url', type: 'string', example: 'wss://livekit.example.com'),
                        new OA\Property(property: 'participant_token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIs...'),
                    ]
                )
            ),
            new OA\Response(
                response: 400,
                description: 'RequÃªte invalide'
            )
        ]
    )]
    public function generateSfuToken(Request $request): JsonResponse
    {
        try {
            // DÃ©coder le corps de la requÃªte JSON
            $body = json_decode($request->getContent(), true);

            // Valider que nous avons du JSON valide
            if (json_last_error() !== JSON_ERROR_NONE) {
                return $this->json([
                    'error' => 'Invalid JSON in request body'
                ], Response::HTTP_BAD_REQUEST);
            }

            // Valider les champs requis
            if (!isset($body['participant_identity']) || !isset($body['room_name'])) {
                return $this->json([
                    'error' => 'Missing required fields: participant_identity and room_name are required'
                ], Response::HTTP_BAD_REQUEST);
            }

            // DÃ©finir les options du token
            $tokenOptions = (new AccessTokenOptions())
                ->setIdentity($body['participant_identity'])
                ->setName($body['participant_name'] ?? $body['participant_identity']);

            // Ajouter les mÃ©tadonnÃ©es si prÃ©sentes
            if (!empty($body['participant_metadata'])) {
                $tokenOptions = $tokenOptions->setMetadata($body['participant_metadata']);
            }

            // Ajouter les attributs si prÃ©sents
            if (!empty($body['participant_attributes']) && is_array($body['participant_attributes'])) {
                $tokenOptions = $tokenOptions->setAttributes($body['participant_attributes']);
            }

            // DÃ©finir les grants vidÃ©o
            $roomName = $body['room_name'];
            $videoGrant = (new VideoGrant())
                ->setRoomJoin()
                ->setRoomName($roomName);

            // CrÃ©er le token
            $token = (new AccessToken($this->livekitApiKey, $this->livekitApiSecret))
                ->init($tokenOptions)
                ->setGrant($videoGrant);

            // Ajouter la configuration de la salle si prÃ©sente
            if (!empty($body['room_config']) && is_array($body['room_config'])) {
                $token = $token->setRoomConfig($body['room_config']);
            }

            // Retourner la rÃ©ponse JSON
            return $this->json([
                'server_url' => $this->livekitUrl,
                'participant_token' => $token->toJwt(),
                'participant_identity' => $body['participant_identity'],
                'participant_name' => $body['participant_name'],
                'room_name' => $body['room_name'],
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Failed to generate token: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}



FICHIER: src/Infrastructure/Http/Controller/GeneratePromptController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Finder\Finder;

#[Route('/api/generate-prompt')]
#[OA\Tag(name: 'ia assistant', description: 'GÃ©nÃ©ration de prompts pour l\'IA')]
class GeneratePromptController extends AbstractController
{
    #[Route('', name: 'generate_prompt', methods: ['GET'])]
    #[OA\Get(
        description: 'Exporte des fichiers et dossiers au format texte brut pour analyse par IA',
        summary: 'GÃ©nÃ¨re un prompt texte contenant l\'arborescence et le code source',
        parameters: [
            new OA\Parameter(
                name: 'paths',
                description: 'Chemin des dossiers Ã  analyser (sÃ©parÃ©s par des virgules) - absolus ou relatifs Ã  la racine du projet',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    example: 'src,config,templates'
                )
            ),
            new OA\Parameter(
                name: 'files',
                description: 'Chemin des fichiers individuels Ã  analyser (sÃ©parÃ©s par des virgules) - absolus ou relatifs Ã  la racine du projet',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    example: 'src/Controller/GeneratePromptController.php,config/routes.yaml'
                )
            ),
            new OA\Parameter(
                name: 'extensions',
                description: 'Liste des extensions de fichiers Ã  inclure (sÃ©parÃ©es par des virgules)',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    default: 'php,dart,html,twig,js,css',
                    example: 'php,twig,yaml'
                )
            ),
        ]
    )]
    public function generatePrompt(Request $request): Response
    {
        $pathsParam = $request->query->get('paths');
        $filesParam = $request->query->get('files');
        $extensions = $request->query->get('extensions', 'php,dart,html,twig,js,css');

        // VÃ©rifier qu'au moins un paramÃ¨tre est fourni
        if (!$pathsParam && !$filesParam) {
            return new Response(
                "ERREUR: Vous devez fournir au moins un dossier (paths) ou un fichier (files) Ã  analyser.\n",
                Response::HTTP_BAD_REQUEST,
                ['Content-Type' => 'text/plain']
            );
        }

        $allowedExtensions = array_map('trim', explode(',', $extensions));
        $warningMessages = [];
        $allFiles = [];
        $allDirs = [];

        // Traitement des dossiers (paths)
        $resolvedPaths = [];
        if ($pathsParam) {
            $pathsParam = str_replace(" ", "", $pathsParam);
            $pathsParam = str_replace("\n", "", $pathsParam);
            $pathsParam = trim($pathsParam);
            $pathsParam = rtrim($pathsParam, ',');


            $rawPaths = array_map('trim', explode(',', $pathsParam));

            foreach ($rawPaths as $path) {
                // RÃ©soudre le chemin absolu
                if (!str_starts_with($path, '/')) {
                    $path = $this->getParameter('kernel.project_dir') . '/' . $path;
                }

                $realPath = realpath($path);

                if ($realPath && is_dir($realPath)) {
                    $resolvedPaths[] = $realPath;
                } else {
                    $warningMessages[] = "Dossier ignorÃ© (invalide): " . $path;
                }
            }

            // Collecter les fichiers des dossiers valides
            foreach ($resolvedPaths as $rootPath) {
                $finder = new Finder();
                $finder->files()
                    ->in($rootPath)
                    ->ignoreDotFiles(false)
                    ->ignoreVCS(false);

                foreach ($finder as $file) {
                    $ext = $file->getExtension();
                    if (in_array($ext, $allowedExtensions)) {
                        $allFiles[] = $file;

                        // Collecter tous les dossiers parents
                        $relativePath = $file->getRelativePath();
                        if (!empty($relativePath)) {
                            $parts = explode(DIRECTORY_SEPARATOR, $relativePath);
                            $currentPath = '';
                            foreach ($parts as $part) {
                                $currentPath = empty($currentPath) ? $part : $currentPath . DIRECTORY_SEPARATOR . $part;
                                $allDirs[$currentPath] = true;
                            }
                        }
                    }
                }
            }
        }

        // Traitement des fichiers individuels (files)
        $resolvedFiles = [];
        if ($filesParam) {

            $rawFiles = array_map('trim', explode(',', $filesParam));

            foreach ($rawFiles as $file) {
                // RÃ©soudre le chemin absolu
                if (!str_starts_with($file, '/')) {
                    $file = $this->getParameter('kernel.project_dir') . '/' . $file;
                }

                $realPath = realpath($file);

                if ($realPath && is_file($realPath)) {
                    $ext = pathinfo($realPath, PATHINFO_EXTENSION);
                    if (in_array($ext, $allowedExtensions)) {
                        $resolvedFiles[] = $realPath;

                        // CrÃ©er un objet fichier virtuel pour le traitement
                        $virtualFile = new \SplFileInfo($realPath);
                        $allFiles[] = $virtualFile;

                        // Collecter le dossier parent
                        $relativePath = str_replace($this->getParameter('kernel.project_dir') . '/', '', dirname($realPath));
                        if ($relativePath !== '.' && !empty($relativePath)) {
                            $parts = explode(DIRECTORY_SEPARATOR, $relativePath);
                            $currentPath = '';
                            foreach ($parts as $part) {
                                $currentPath = empty($currentPath) ? $part : $currentPath . DIRECTORY_SEPARATOR . $part;
                                $allDirs[$currentPath] = true;
                            }
                        }
                    } else {
                        $warningMessages[] = "Fichier ignorÃ© (extension non autorisÃ©e): " . $file;
                    }
                } else {
                    $warningMessages[] = "Fichier ignorÃ© (invalide): " . $file;
                }
            }
        }

        // VÃ©rifier qu'on a au moins un fichier Ã  analyser
        if (empty($allFiles)) {
            $errorMsg = "ERREUR: Aucun fichier valide trouvÃ©.\n";
            if (!empty($warningMessages)) {
                $errorMsg .= implode("\n", $warningMessages) . "\n";
            }
            return new Response(
                $errorMsg,
                Response::HTTP_NOT_FOUND,
                ['Content-Type' => 'text/plain']
            );
        }

        try {
            $content = $this->generateExport($allFiles, $allDirs, $resolvedPaths, $allowedExtensions);

            // Ajouter les avertissements au dÃ©but si nÃ©cessaire
            if (!empty($warningMessages)) {
                $warnings = "ATTENTIONS:\n" . implode("\n", $warningMessages) . "\n\n";
                $content = $warnings . $content;
            }

            return new Response(
                $content,
                Response::HTTP_OK,
                ['Content-Type' => 'text/plain']
            );

        } catch (\Exception $e) {
            return new Response(
                "ERREUR: " . $e->getMessage() . "\n",
                Response::HTTP_INTERNAL_SERVER_ERROR,
                ['Content-Type' => 'text/plain']
            );
        }
    }

    private function generateExport(array $allFiles, array $allDirs, array $rootPaths, array $allowedExtensions): string
    {
        $output = [];
        $projectRoot = $this->getParameter('kernel.project_dir');

        // En-tÃªte
        $output[] = "FICHIERS POUR ANALYSE";
        $output[] = "=====================";

        if (!empty($rootPaths)) {
            $output[] = "Dossiers analysÃ©s:";
            foreach ($rootPaths as $path) {
                $relativePath = str_replace($projectRoot . '/', '', $path);
                $output[] = "  - " . $relativePath;
            }
        }

        $output[] = "Extensions: " . implode(', ', $allowedExtensions);
        $output[] = "Date: " . date('Y-m-d H:i:s');
        $output[] = "";

        // Trier les fichiers par chemin
        usort($allFiles, function($a, $b) {
            return strcmp($a->getRealPath(), $b->getRealPath());
        });

        // Trier les dossiers
        $dirs = array_keys($allDirs);
        sort($dirs);

        // GÃ©nÃ©rer l'arborescence complÃ¨te
        $output[] = "ARBORESCENCE:";
        $output[] = "-------------";

        if (empty($allFiles)) {
            $output[] = "  (aucun fichier trouvÃ©)";
        } else {
            // Construire l'arbre global
            $globalTree = [];

            foreach ($allFiles as $file) {
                $fullPath = $file->getRealPath();
                $relativePath = str_replace($projectRoot . '/', '', $fullPath);
                $parts = explode('/', $relativePath);

                $current = &$globalTree;
                $lastIndex = count($parts) - 1;

                foreach ($parts as $index => $part) {
                    if ($index === $lastIndex) {
                        // C'est un fichier
                        $current[$part] = null;
                    } else {
                        // C'est un dossier
                        if (!isset($current[$part])) {
                            $current[$part] = [];
                        }
                        $current = &$current[$part];
                    }
                }
            }

            $output[] = $this->renderTree($globalTree);
        }

        $output[] = "";
        $output[] = "CONTENU DES FICHIERS";
        $output[] = "====================";
        $output[] = "";

        // Contenu de chaque fichier
        foreach ($allFiles as $file) {
            $fullPath = $file->getRealPath();
            $relativeToProject = str_replace($projectRoot . '/', '', $fullPath);

            $output[] = "FICHIER: " . $relativeToProject;
            $output[] = str_repeat("-", 80);

            $content = file_get_contents($fullPath);
            if ($content === false) {
                $output[] = "[ERREUR LECTURE]";
            } else {
                $output[] = $content;
            }

            $output[] = ""; // Ligne vide entre les fichiers
            $output[] = ""; // Une de plus pour la sÃ©paration
        }

        $output[] = "FIN";
        $output[] = "============";
        $output[] = "Total fichiers: " . count($allFiles);

        return implode("\n", $output);
    }

    private function renderTree(array $tree, string $prefix = ''): string
    {
        $output = '';
        $items = $this->sortTreeItems($tree);
        $count = count($items);
        $i = 0;

        foreach ($items as $key => $value) {
            $i++;
            $isLast = ($i === $count);
            $isDir = is_array($value);

            // Choisir le marqueur
            if ($isDir) {
                $marker = $isLast ? 'â””â”€â”€ ğŸ“ ' : 'â”œâ”€â”€ ğŸ“ ';
            } else {
                $marker = $isLast ? 'â””â”€â”€ ğŸ“„ ' : 'â”œâ”€â”€ ğŸ“„ ';
            }

            // Ajouter l'Ã©lÃ©ment courant
            $output .= $prefix . $marker . $key . ($isDir ? '/' : '') . "\n";

            // Si c'est un dossier, rendre son contenu
            if ($isDir) {
                $newPrefix = $prefix . ($isLast ? '    ' : 'â”‚   ');
                $output .= $this->renderTree($value, $newPrefix);
            }
        }

        return $output;
    }

    private function sortTreeItems(array $tree): array
    {
        // SÃ©parer les dossiers et les fichiers
        $dirs = [];
        $files = [];

        foreach ($tree as $key => $value) {
            if (is_array($value)) {
                $dirs[$key] = $value;
            } else {
                $files[$key] = $value;
            }
        }

        // Trier alphabÃ©tiquement
        ksort($dirs);
        ksort($files);

        // Fusionner (dossiers d'abord, puis fichiers)
        return array_merge($dirs, $files);
    }
}



FICHIER: src/Infrastructure/Http/Controller/LogoutController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/LogoutController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Security\RefreshTokenService;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/auth/logout', name: 'api_auth_logout', methods: ['POST'])]
#[OA\Tag(name: 'auth')]
class LogoutController extends AbstractController
{
    public function __construct(
        private readonly RefreshTokenService $refreshTokenService
    ) {}

    #[OA\Post(
        summary: 'DÃ©connecte l\'utilisateur',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                type: 'object',
                required: ['refresh_token'],
                properties: [
                    new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                ]
            )
        ),
        responses: [
            new OA\Response(response: 200, description: 'DÃ©connexion rÃ©ussie')
        ]
    )]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $refreshTokenString = $data['refresh_token'] ?? null;

        if ($refreshTokenString) {
            $this->refreshTokenService->revokeRefreshToken($refreshTokenString);
        }

        return $this->json(['message' => 'DÃ©connexion rÃ©ussie']);
    }
}



FICHIER: src/Infrastructure/Http/Controller/PhotoController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\ResponseHeaderBag;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/photo')]
class PhotoController extends AbstractController
{
    private string $uploadDir;

    public function __construct(string $projectDir)
    {
        $this->uploadDir = $projectDir . '/upload/photos';
    }

    #[Route('/{filename}', name: 'photo_get', methods: ['GET'])]
    public function getPhoto(string $filename): Response
    {
        // SÃ©curitÃ© : empÃªcher les traversÃ©es de rÃ©pertoire
        if (str_contains($filename, '..') || str_contains($filename, '/') || str_contains($filename, '\\')) {
            return new JsonResponse(['error' => 'Nom de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        // Validation du format de fichier - CORRIGÃ‰E
        // Accepte: lettres (maj/min), chiffres, tirets, underscore, points
        if (!preg_match('/^[a-zA-Z0-9_-]+\.(jpg|jpeg|png|gif|webp)$/i', $filename)) {
            return new JsonResponse([
                'error' => 'Format de fichier invalide',
                'filename' => $filename,
                'expected_format' => 'auth_uid.extension (ex: AtJbLX0UgIcpiaWCZNnc9JdLzff1.jpg)'
            ], Response::HTTP_BAD_REQUEST);
        }

        $filePath = $this->uploadDir . '/' . $filename;

        if (!file_exists($filePath)) {
            return new JsonResponse(['error' => 'Photo non trouvÃ©e'], Response::HTTP_NOT_FOUND);
        }

        // DÃ©tecter le type MIME
        $mimeType = mime_content_type($filePath);
        if (!$mimeType) {
            $extension = pathinfo($filename, PATHINFO_EXTENSION);
            $mimeType = match(strtolower($extension)) {
                'jpg', 'jpeg' => 'image/jpeg',
                'png' => 'image/png',
                'gif' => 'image/gif',
                'webp' => 'image/webp',
                default => 'application/octet-stream',
            };
        }

        // Retourner le fichier avec des en-tÃªtes de cache
        return new BinaryFileResponse($filePath, 200, [
            'Content-Type' => $mimeType,
            'Cache-Control' => 'public, max-age=31536000', // Cache d'un an
            'Access-Control-Allow-Origin' => '*', // Permettre l'accÃ¨s depuis n'importe quelle origine
        ]);
    }

    #[Route('/{filename}/download', name: 'photo_download', methods: ['GET'])]
    public function downloadPhoto(string $filename): Response
    {
        // MÃªme logique de sÃ©curitÃ©
        if (str_contains($filename, '..') || str_contains($filename, '/') || str_contains($filename, '\\')) {
            return new JsonResponse(['error' => 'Nom de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        if (!preg_match('/^[a-f0-9-]+\.(jpg|jpeg|png|gif|webp)$/i', $filename)) {
            return new JsonResponse(['error' => 'Format de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        $filePath = $this->uploadDir . '/' . $filename;

        if (!file_exists($filePath)) {
            return new JsonResponse(['error' => 'Photo non trouvÃ©e'], Response::HTTP_NOT_FOUND);
        }

        $response = new BinaryFileResponse($filePath);
        $response->setContentDisposition(
            ResponseHeaderBag::DISPOSITION_ATTACHMENT,
            $filename
        );
        $response->headers->set('Access-Control-Allow-Origin', '*');

        return $response;
    }
}



FICHIER: src/Infrastructure/Http/Controller/RefreshTokenController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/RefreshTokenController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Security\RefreshTokenService;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/auth/refresh', name: 'api_auth_refresh', methods: ['POST'])]
#[OA\Tag(name: 'auth')]
class RefreshTokenController extends AbstractController
{
    public function __construct(
        private readonly RefreshTokenService $refreshTokenService,
        private readonly JWTTokenManagerInterface $jwtManager
    ) {}

    #[OA\Post(
        summary: 'RafraÃ®chit un token JWT expirÃ©',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['refresh_token'],
                properties: [
                    new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                ],
                type: 'object'
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Nouveau token JWT et nouveau refresh token',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIsInR5...'),
                        new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                    ],
                    type: 'object'
                )
            ),
            new OA\Response(response: 401, description: 'Refresh token invalide')
        ]
    )]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

//        echo "popipopipopipopipopipopipopipopi\n";
//        print_r($data);
//        exit;

        $refreshTokenString = $data['refresh_token'] ?? null;

        if (!$refreshTokenString) {
            return $this->json(['error' => 'Refresh token requis'], Response::HTTP_BAD_REQUEST);
        }

        // Rotation du refresh token (single use)
        $newRefreshToken = $this->refreshTokenService->rotateRefreshToken($refreshTokenString);

        if (!$newRefreshToken) {
            return $this->json(['error' => 'Refresh token invalide ou expirÃ©'], Response::HTTP_UNAUTHORIZED);
        }

        // GÃ©nÃ©rer un nouveau JWT
        $user = $newRefreshToken->getUser();
        $newJwt = $this->jwtManager->create($user);

        return $this->json([
            'token' => $newJwt,
            'refresh_token' => $newRefreshToken->getRefreshToken()
        ]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/UsersGetJwtTokenFromFirebaseAuthAction.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Infrastructure\Security\RefreshTokenService;
use App\Shared\Application\Query\QueryBusInterface;
use App\Users\Application\Config\UsersAppConfig;
use App\Users\Application\DTO\UserDTO;
use App\Users\Application\Query\GetJwtForSignup\GetJwtForSignupQuery;
use App\Users\Application\Query\GetJwtFromUser\GetJwtFromUserQuery;
use App\Users\Application\Query\GetUserByFirebaseToken\GetUserByFirebaseTokenQuery;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Token\Parser;
use Lcobucci\JWT\Token\Plain;
use OpenApi\Attributes as OA;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Uid\Uuid;

#[Route('/api/users/jwt-by-firebase-token', name: 'UsersGetJwtTokenFromFirebaseAuth', methods: ['POST'])]
class UsersGetJwtTokenFromFirebaseAuthAction
{
    public function __construct(
        private readonly QueryBusInterface $queryBus,
        private readonly RefreshTokenService $refreshTokenService,
        private readonly UserRepository $userRepository,
        private readonly UserPasswordHasherInterface $passwordHasher
    ) {
    }

    #[OA\Tag(name: 'users')]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $token = $data['token'];

        /** @var UserDTO $userDTO */
        $userDTO = $this->queryBus->execute(new GetUserByFirebaseTokenQuery($token));

        if ($userDTO->status >= 20) {
            $message = '';
            switch($userDTO->status) {
                case UsersAppConfig::$USER_UNSUBSCRIBED:
                    $message = 'Vous Ãªtes dÃ©sinscrit(e).';
                    break;
                case UsersAppConfig::$USER_BANNED:
                    $message = 'Vous avez Ã©tÃ© banni(e).';
                    break;
                case UsersAppConfig::$USER_BLOCKED:
                    $message = 'Vous avez Ã©tÃ© bloquÃ©(e).';
                    break;
            }

            return new JsonResponse(['message' => json_encode([
                "code" => UsersAppConfig::$ERREUR_USER,
                "title" => "Erreur",
                "message" => $message."\n\nSupport: contact@playwinher.com",
            ])], Response::HTTP_FORBIDDEN);
        } else {
            $refreshToken = null;
            $userEntity = null;

            if ('' == $userDTO->email) {
                // Nouvel utilisateur - le crÃ©er Ã  partir du token Firebase
                $userEntity = $this->createUserFromFirebaseToken($token);

                // Sauvegarder l'utilisateur
                $this->userRepository->getEntityManager()->persist($userEntity);
                $this->userRepository->getEntityManager()->flush();

                // Re-crÃ©er le UserDTO avec les nouvelles informations
                $userDTO = UserDTO::fromEntity($userEntity);

                // GÃ©nÃ©rer le JWT pour le nouvel utilisateur
                $jwtToken = $this->queryBus->execute(new GetJwtFromUserQuery($userDTO));
            } else {
                // Utilisateur existant - gÃ©nÃ©rer JWT normal
                $jwtToken = $this->queryBus->execute(new GetJwtFromUserQuery($userDTO));

                // RÃ©cupÃ©rer l'entitÃ© utilisateur pour gÃ©nÃ©rer le refresh token
                $userEntity = $this->getUserEntityByAuthUid($userDTO->authUid);
            }

            // GÃ©nÃ©rer le refresh token si on a une entitÃ© utilisateur
            if ($userEntity) {
                // RÃ©voquer tous les anciens refresh tokens (single session)
                $this->refreshTokenService->revokeAllUserTokens($userEntity);

                // CrÃ©er un nouveau refresh token
                $refreshTokenEntity = $this->refreshTokenService->createRefreshToken($userEntity);
                $refreshToken = $refreshTokenEntity->getRefreshToken();
            }

            $response = [
                'token' => $jwtToken,
                'found' => ('' != $userDTO->email),
                'auth_uid' => $userDTO->authUid,
            ];

            // Ajouter le refresh token
            if ($refreshToken) {
                $response['refresh_token'] = $refreshToken;
            }

            return new JsonResponse($response);
        }
    }

    /**
     * CrÃ©e un nouvel utilisateur Ã  partir du token Firebase
     */
    private function createUserFromFirebaseToken(string $firebaseToken): UserEntity
    {
        // Parser le token Firebase pour extraire les informations
        $parser = new Parser(new JoseEncoder());
        /** @var Plain $token */
        $token = $parser->parse($firebaseToken);

        // RÃ©cupÃ©rer les claims
        $claims = $token->claims();

        // Extraire l'email et le sub (auth_uid)
        $email = $claims->get('email');
        $authUid = $claims->get('sub');

        // Essayer de rÃ©cupÃ©rer le nom depuis Firebase
        $name = $claims->get('name', null); // Firebase peut fournir un champ 'name'

        if (!$email || !$authUid) {
            throw new \Exception('Email ou sub manquant dans le token Firebase');
        }

        // CrÃ©er la nouvelle entitÃ©
        $userEntity = new UserEntity();

        // GÃ©nÃ©rer un UID unique pour l'utilisateur
        $userEntity->setUid(Uuid::v4()->toString());
        $userEntity->setAuthUid($authUid);
        $userEntity->setEmail($email);
        $userEntity->setUsername($email); // Garder username pour compatibilitÃ©
        $userEntity->setDisplayName($name ?? $email); // Utiliser le nom Firebase ou fallback sur email
        $userEntity->setAboutMe('');
        $userEntity->setGender(0);
        $userEntity->setBirthdate(new \DateTime('today'));
        $userEntity->setStatus(0);
        $userEntity->setRoles(['ROLE_USER']);

        // Hasher le mot de passe alÃ©atoire
        $randomPassword = bin2hex(random_bytes(16));
        $hashedPassword = $this->passwordHasher->hashPassword($userEntity, $randomPassword);
        $userEntity->setPassword($hashedPassword);

        // DÃ©finir la date de crÃ©ation (sera aussi gÃ©rÃ©e par le PrePersist)
        $userEntity->setCreatedAt(new \DateTime());

        return $userEntity;
    }

    /**
     * MÃ©thode utilitaire pour rÃ©cupÃ©rer l'entitÃ© User Ã  partir de l'authUid
     */
    private function getUserEntityByAuthUid(string $authUid): ?UserEntity
    {
        return $this->userRepository->findOneBy(['authUid' => $authUid]);
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/RefreshTokenEntity.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Entity/RefreshTokenEntity.php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
#[ORM\Table(name: 'refresh_tokens')]
#[ORM\HasLifecycleCallbacks]
class RefreshTokenEntity
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 128, unique: true)]
    private string $refreshToken;

    #[ORM\ManyToOne(targetEntity: UserEntity::class)]
    #[ORM\JoinColumn(nullable: false)]
    private UserEntity $user;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $valid;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(type: 'boolean')]
    private bool $revoked = false;

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        $this->createdAt = new \DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getRefreshToken(): string
    {
        return $this->refreshToken;
    }

    public function setRefreshToken(string $refreshToken): self
    {
        $this->refreshToken = $refreshToken;
        return $this;
    }

    public function getUser(): UserEntity
    {
        return $this->user;
    }

    public function setUser(UserEntity $user): self
    {
        $this->user = $user;
        return $this;
    }

    public function getValid(): \DateTimeInterface
    {
        return $this->valid;
    }

    public function setValid(\DateTimeInterface $valid): self
    {
        $this->valid = $valid;
        return $this;
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function isRevoked(): bool
    {
        return $this->revoked;
    }

    public function setRevoked(bool $revoked): self
    {
        $this->revoked = $revoked;
        return $this;
    }

    public function isValid(): bool
    {
        return !$this->revoked && $this->valid > new \DateTime();
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/UserEntity.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;

/**
 * Infrastructure Entity - Mapping Doctrine uniquement
 * Sert d'adapter entre le domaine et la base de donnÃ©es
 */
#[ORM\Entity]
#[ORM\Table(name: '`user`')]
#[ORM\HasLifecycleCallbacks]
class UserEntity implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $uid = null;

    #[ORM\Column(name: 'auth_uid', type: 'string', length: 100, nullable: true)]
    private ?string $authUid = null;

    #[ORM\Column(type: 'json')]
    private array $roles = [];

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $email = null;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $username = null;

    // Champ displayName
    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $displayName = null;

    #[ORM\Column(type: 'string', length: 255)]
    private string $password;

    #[ORM\Column(name: 'about_me', type: 'text', nullable: true)]
    private ?string $aboutMe = null;

    #[ORM\Column(type: 'integer', nullable: true)]
    private ?int $gender = null;

    #[ORM\Column(type: 'date', nullable: true)]
    private ?\DateTime $birthdate = null;

    #[ORM\Column(type: 'integer', options: ['default' => 1])]
    private int $status = 1;

    #[ORM\Column(name: 'has_photo', type: 'boolean', options: ['default' => false])]
    private bool $hasPhoto = false;
    #[ORM\Column(name: 'first_access', type: 'boolean', options: ['default' => true])]
    private bool $firstAccess = true;

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime', nullable: true)]
    private ?\DateTimeInterface $updatedAt = null;

    /**
     * Constructeur avec initialisation de toutes les propriÃ©tÃ©s
     */
    public function __construct()
    {
        $this->hasPhoto = false;
        $this->createdAt = new \DateTime();
    }

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        if ($this->createdAt === null) {
            $this->createdAt = new \DateTime();
        }
    }

    #[ORM\PreUpdate]
    public function setUpdatedAtValue(): void
    {
        $this->updatedAt = new \DateTime();
    }

    // Getters and Setters
    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(?int $id): void
    {
        $this->id = $id;
    }

    public function getUid(): ?string
    {
        return $this->uid;
    }

    public function setUid(?string $uid): void
    {
        $this->uid = $uid;
    }

    public function getAuthUid(): ?string
    {
        return $this->authUid;
    }

    public function setAuthUid(?string $authUid): void
    {
        $this->authUid = $authUid;
    }

    public function getEmail(): ?string
    {
        return $this->email;
    }

    public function setEmail(?string $email): void
    {
        $this->email = $email;
    }

    public function getUsername(): ?string
    {
        return $this->username;
    }

    public function setUsername(?string $username): void
    {
        $this->username = $username;
    }

    public function getDisplayName(): ?string
    {
        return $this->displayName;
    }

    public function setDisplayName(?string $displayName): void
    {
        $this->displayName = $displayName;
    }

    public function getAboutMe(): ?string
    {
        return $this->aboutMe;
    }

    public function setAboutMe(?string $aboutMe): void
    {
        $this->aboutMe = $aboutMe;
    }

    public function getGender(): ?int
    {
        return $this->gender;
    }

    public function setGender(?int $gender): void
    {
        $this->gender = $gender;
    }

    public function getBirthdate(): ?\DateTime
    {
        return $this->birthdate;
    }

    public function setBirthdate(?\DateTime $birthdate): void
    {
        $this->birthdate = $birthdate;
    }

    public function getStatus(): int
    {
        return $this->status;
    }

    public function setStatus(int $status): void
    {
        $this->status = $status;
    }

    // Getter/Setter pour hasPhoto
    public function hasPhoto(): bool
    {
        return $this->hasPhoto;
    }

    public function setHasPhoto(bool $hasPhoto): self
    {
        $this->hasPhoto = $hasPhoto;
        return $this;
    }

    public function isFirstAccess(): bool
    {
        return $this->firstAccess;
    }

    public function setFirstAccess(bool $firstAccess): void
    {
        $this->firstAccess = $firstAccess;
    }


    // MÃ©thode utilitaire pour mettre Ã  jour le statut photo
    public function updatePhotoStatus(bool $hasPhoto): void
    {
        $this->hasPhoto = $hasPhoto;
        $this->updatedAt = new \DateTime();
    }

    public function getUserIdentifier(): string
    {
        return $this->email ?? '';
    }

    public function getRoles(): array
    {
        $roles = $this->roles;
        $roles[] = 'ROLE_USER';
        return array_unique($roles);
    }

    public function setRoles(array $roles): void
    {
        $this->roles = $roles;
    }

    public function getPassword(): string
    {
        return $this->password;
    }

    public function setPassword(string $password): void
    {
        $this->password = $password;
    }

    public function eraseCredentials(): void
    {
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTimeInterface $createdAt): void
    {
        $this->createdAt = $createdAt;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    public function setUpdatedAt(?\DateTimeInterface $updatedAt): void
    {
        $this->updatedAt = $updatedAt;
    }

    /**
     * MÃ©thodes d'aide pour la compatibilitÃ© avec l'ancien nommage
     */
    public function isActive(): bool
    {
        return $this->status === 1;
    }

    public function setIsActive(bool $isActive): void
    {
        $this->status = $isActive ? 1 : 0;
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/RefreshTokenRepository.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Repository/RefreshTokenRepository.php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Infrastructure\Persistence\Doctrine\Entity\RefreshTokenEntity;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class RefreshTokenRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, RefreshTokenEntity::class);
    }

    public function save(RefreshTokenEntity $refreshToken): void
    {
        $this->getEntityManager()->persist($refreshToken);
        $this->getEntityManager()->flush();
    }

    public function delete(RefreshTokenEntity $refreshToken): void
    {
        $this->getEntityManager()->remove($refreshToken);
        $this->getEntityManager()->flush();
    }

    public function findByToken(string $refreshToken): ?RefreshTokenEntity
    {
        return $this->findOneBy(['refreshToken' => $refreshToken]);
    }

    public function revokeAllForUser(UserEntity $user): void
    {
        $this->createQueryBuilder('rt')
            ->update()
            ->set('rt.revoked', ':revoked')
            ->where('rt.user = :user')
            ->setParameter('revoked', true)
            ->setParameter('user', $user)
            ->getQuery()
            ->execute();
    }

    public function deleteExpired(): int
    {
        return $this->createQueryBuilder('rt')
            ->delete()
            ->where('rt.valid < :now')
            ->setParameter('now', new \DateTime())
            ->getQuery()
            ->execute();
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/UserRepository.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Domain\Entity\User;
use App\Domain\Repository\UserRepositoryInterface;
use App\Domain\ValueObject\Email;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * Doctrine Repository (Adapter) - ImplÃ©mente le port du domaine
 */
class UserRepository extends ServiceEntityRepository implements UserRepositoryInterface
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, UserEntity::class);
    }

    public function save(UserEntity $user): void
    {
        $userEntity = $this->toDoctrineEntity($user);

        $this->getEntityManager()->persist($userEntity);
        $this->getEntityManager()->flush();

        // Sync l'ID gÃ©nÃ©rÃ© vers l'entitÃ© domain
        if ($user->getId() === null && $userEntity->getId() !== null) {
            $user->setId($userEntity->getId());
        }
    }

    public function delete(UserEntity $user): void
    {
        $userEntity = $this->find($user->getId());
        if ($userEntity) {
            $this->getEntityManager()->remove($userEntity);
            $this->getEntityManager()->flush();
        }
    }

    public function findById(int $id): ?UserEntity
    {
        $userEntity = $this->find($id);
        return $userEntity ? $this->toDomainEntity($userEntity) : null;
    }

    public function findByEmail(Email $email): ?UserEntity
    {
        $userEntity = $this->findOneBy(['email' => $email->getValue()]);
        return $userEntity ? $this->toDomainEntity($userEntity) : null;
    }

    public function findAll(): array
    {
        $entities = $this->findBy([], ['createdAt' => 'DESC']);
        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function findActiveUsers(): array
    {
        $entities = $this->createQueryBuilder('u')
            ->where('u.isActive = :active')
            ->setParameter('active', true)
            ->orderBy('u.createdAt', 'DESC')
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function findByRole(string $role): array
    {
        $entities = $this->createQueryBuilder('u')
            ->andWhere('JSON_CONTAINS(u.roles, :role) = 1')
            ->setParameter('role', json_encode($role))
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function search(string $searchTerm): array
    {
        $entities = $this->createQueryBuilder('u')
            ->where('u.email LIKE :search OR u.firstname LIKE :search OR u.lastname LIKE :search')
            ->setParameter('search', '%' . $searchTerm . '%')
            ->orderBy('u.lastname', 'ASC')
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function countActiveUsers(): int
    {
        return (int) $this->createQueryBuilder('u')
            ->select('COUNT(u.id)')
            ->where('u.isActive = :active')
            ->setParameter('active', true)
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function existsByEmail(Email $email): bool
    {
        return $this->count(['email' => $email->getValue()]) > 0;
    }

    /**
     * Convertit une entitÃ© Domain en entitÃ© Doctrine
     */
    private function toDoctrineEntity(UserEntity $domainUser): UserEntity
    {
        $userEntity = new UserEntity();

        if ($domainUser->getId() !== null) {
            $existing = $this->find($domainUser->getId());
            if ($existing) {
                $userEntity = $existing;
            } else {
                $userEntity->setId($domainUser->getId());
            }
        }

        $userEntity->setEmail($domainUser->getEmail());
        $userEntity->setRoles($domainUser->getRoles());
        $userEntity->setPassword($domainUser->getPassword());
//        $userEntity->setFirstname($domainUser->getFirstname());
//        $userEntity->setLastname($domainUser->getLastname());
        $userEntity->setIsActive($domainUser->isActive());
        $userEntity->setCreatedAt($domainUser->getCreatedAt());

        if ($domainUser->getUpdatedAt()) {
            $userEntity->setUpdatedAt($domainUser->getUpdatedAt());
        }

        return $userEntity;
    }

    /**
     * Convertit une entitÃ© Doctrine en entitÃ© Domain
     */
    private function toDomainEntity(UserEntity $userEntity): UserEntity
    {
        $user = new UserEntity(
            new Email($userEntity->getEmail()),
            $userEntity->getPassword(),
//            $userEntity->getFirstname(),
//            $userEntity->getLastname()
        );

        $user->setId($userEntity->getId());

        // Restaurer les rÃ´les (sans ROLE_USER par dÃ©faut qui sera ajoutÃ© automatiquement)
        $roles = array_filter($userEntity->getRoles(), fn($r) => $r !== 'ROLE_USER');
//        foreach ($roles as $role) {
//            $user->addRole($role);
//        }
        $user->setRoles($roles);

//        if (!$userEntity->isActive()) {
//            $user->deactivate();
//        }

        return $user;
    }

    public function getUserByAuthUid(string $firebaseAuthId): ?UserEntity
    {
        return $this->findOneBy(['authUid' => $firebaseAuthId]);
    }
}



FICHIER: src/Infrastructure/Security/JWTLoginSuccessHandler.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/JWTLoginSuccessHandler.php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Lexik\Bundle\JWTAuthenticationBundle\Event\AuthenticationSuccessEvent;
use Lexik\Bundle\JWTAuthenticationBundle\Events;
use Lexik\Bundle\JWTAuthenticationBundle\Response\JWTAuthenticationSuccessResponse;
use Lexik\Bundle\JWTAuthenticationBundle\Security\Http\Cookie\JWTCookieProvider;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationSuccessHandlerInterface;
use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;

class JWTLoginSuccessHandler implements AuthenticationSuccessHandlerInterface
{
    public function __construct(
        protected JWTTokenManagerInterface $jwtManager,
        protected EventDispatcherInterface $dispatcher,
        protected RefreshTokenService $refreshTokenService,
        iterable $cookieProviders = [],
        bool $removeTokenFromBodyWhenCookiesUsed = true
    ) {
        $this->jwtManager = $jwtManager;
        $this->dispatcher = $dispatcher;
        $this->refreshTokenService = $refreshTokenService;
        $this->cookieProviders = $cookieProviders;
        $this->removeTokenFromBodyWhenCookiesUsed = $removeTokenFromBodyWhenCookiesUsed;
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token): Response
    {
        return $this->handleAuthenticationSuccess($token->getUser());
    }

    public function handleAuthenticationSuccess(UserInterface $user, $jwt = null)
    {
        if (null === $jwt) {
            $jwt = $this->jwtManager->create($user);
        }

        // GÃ©nÃ©rer un refresh token si l'utilisateur est une instance de UserEntity
        $refreshToken = null;
        if ($user instanceof UserEntity) {
            $refreshTokenEntity = $this->refreshTokenService->createRefreshToken($user);
            $refreshToken = $refreshTokenEntity->getRefreshToken();
        }

        $jwtCookies = [];
        foreach ($this->cookieProviders as $cookieProvider) {
            $jwtCookies[] = $cookieProvider->createCookie($jwt);
        }

        $responseData = [
            'token' => $jwt,
            'refresh_token' => $refreshToken,
            'user' => [
                'email' => $user->getUserIdentifier(),
                'roles' => $user->getRoles(),
                'firstname' => method_exists($user, 'getFirstname') ? $user->getFirstname() : null,
                'lastname' => method_exists($user, 'getLastname') ? $user->getLastname() : null,
            ],
        ];

        $event = new AuthenticationSuccessEvent($responseData, $user, new JWTAuthenticationSuccessResponse($jwt, [], $jwtCookies));
        $this->dispatcher->dispatch($event, Events::AUTHENTICATION_SUCCESS);

        $response = new JWTAuthenticationSuccessResponse($jwt, [], $jwtCookies);
        $response->setData($event->getData());

        if ($jwtCookies && $this->removeTokenFromBodyWhenCookiesUsed) {
            unset($responseData['token']);
        }

        return $response;
    }
}



FICHIER: src/Infrastructure/Security/JwtAuthenticator.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;

class JwtAuthenticator extends AbstractAuthenticator
{
    private JWTTokenManagerInterface $jwtManager;
    private UserProviderInterface $userProvider;

    public function __construct(JWTTokenManagerInterface $jwtManager, UserProviderInterface $userProvider)
    {
        $this->jwtManager = $jwtManager;
        $this->userProvider = $userProvider;
    }

    public function supports(Request $request): ?bool
    {
        return $request->headers->has('Authorization');
    }

    public function authenticate(Request $request): SelfValidatingPassport
    {
        $authHeader = $request->headers->get('Authorization');
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            throw new AuthenticationException('JWT Token not found');
        }

        $jwt = substr($authHeader, 7);

        try {
            $payload = $this->jwtManager->decodeFromJsonWebToken($jwt);
        } catch (\Exception $e) {
            throw new AuthenticationException('Invalid JWT Token');
        }

        $username = $payload['username'] ?? null;
        if (!$username) {
            throw new AuthenticationException('JWT Token invalid: username missing');
        }

        return new SelfValidatingPassport(
            new UserBadge($username, fn($userIdentifier) => $this->userProvider->loadUserByUsername($userIdentifier))
        );
    }

    public function onAuthenticationSuccess(Request $request, $token, string $firewallName): ?JsonResponse
    {
        // Laisser continuer la requÃªte
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?JsonResponse
    {
        return new JsonResponse([
            'code' => 401,
            'message' => $exception->getMessage(),
        ], 401);
    }
}



FICHIER: src/Infrastructure/Security/RefreshTokenAuthenticator.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/RefreshTokenAuthenticator.php

namespace App\Infrastructure\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

class RefreshTokenAuthenticator extends AbstractAuthenticator
{
    public function __construct(
        private RefreshTokenService $refreshTokenService,
        private UserProviderInterface $userProvider
    ) {}

    public function supports(Request $request): ?bool
    {
        return $request->getPathInfo() === '/api/auth/refresh' && $request->isMethod('POST');
    }

    public function authenticate(Request $request): SelfValidatingPassport
    {
        $data = json_decode($request->getContent(), true);
        $refreshTokenString = $data['refresh_token'] ?? null;

        if (!$refreshTokenString) {
            throw new AuthenticationException('Refresh token missing');
        }

        $refreshToken = $this->refreshTokenService->validateRefreshToken($refreshTokenString);

        if (!$refreshToken) {
            throw new AuthenticationException('Invalid refresh token');
        }

        $user = $refreshToken->getUser();

        return new SelfValidatingPassport(
            new UserBadge($user->getUserIdentifier(), fn() => $user)
        );
    }

    public function onAuthenticationSuccess(Request $request, $token, string $firewallName): ?JsonResponse
    {
        return null; // Continue la requÃªte
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?JsonResponse
    {
        return new JsonResponse([
            'error' => 'Refresh token invalide'
        ], 401);
    }
}



FICHIER: src/Infrastructure/Security/RefreshTokenService.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/RefreshTokenService.php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Entity\RefreshTokenEntity;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\RefreshTokenRepository;
use Symfony\Component\Security\Csrf\TokenGenerator\TokenGeneratorInterface;

class RefreshTokenService
{
    public function __construct(
        private readonly RefreshTokenRepository $refreshTokenRepository,
        private readonly TokenGeneratorInterface $tokenGenerator,
        private readonly int $ttl = 2592000 // 30 jours en secondes
    ) {}

    public function createRefreshToken(UserEntity $user): RefreshTokenEntity
    {
        // Optionnel: rÃ©voquer tous les anciens tokens pour cet utilisateur
        // $this->refreshTokenRepository->revokeAllForUser($user);

        $refreshToken = new RefreshTokenEntity();
        $refreshToken->setRefreshToken($this->tokenGenerator->generateToken());
        $refreshToken->setUser($user);
        $refreshToken->setValid(new \DateTime('+' . $this->ttl . ' seconds'));
        $refreshToken->setRevoked(false);

        $this->refreshTokenRepository->save($refreshToken);

        return $refreshToken;
    }

    public function validateRefreshToken(string $tokenString): ?RefreshTokenEntity
    {
        $refreshToken = $this->refreshTokenRepository->findByToken($tokenString);

        if (!$refreshToken || !$refreshToken->isValid()) {
            return null;
        }

        return $refreshToken;
    }

    public function revokeRefreshToken(string $tokenString): void
    {
        $refreshToken = $this->refreshTokenRepository->findByToken($tokenString);
        if ($refreshToken) {
            $refreshToken->setRevoked(true);
            $this->refreshTokenRepository->save($refreshToken);
        }
    }

    public function revokeAllUserTokens(UserEntity $user): void
    {
        $this->refreshTokenRepository->revokeAllForUser($user);
    }

    public function rotateRefreshToken(string $oldTokenString): ?RefreshTokenEntity
    {
        $oldToken = $this->validateRefreshToken($oldTokenString);
        if (!$oldToken) {
            return null;
        }

        // RÃ©voquer l'ancien token
        $oldToken->setRevoked(true);
        $this->refreshTokenRepository->save($oldToken);

        // CrÃ©er un nouveau token
        return $this->createRefreshToken($oldToken->getUser());
    }
}



FICHIER: src/Infrastructure/Security/UserProvider.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Symfony\Component\Security\Core\Exception\UserNotFoundException;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Core\User\UserProviderInterface;

/**
 * UserProvider adaptÃ© Ã  l'architecture hexagonale
 */
class UserProvider implements UserProviderInterface, PasswordUpgraderInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {}

    public function refreshUser(UserInterface $user): UserInterface
    {
        if (!$user instanceof \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity) {
            throw new UnsupportedUserException(sprintf('Invalid user class "%s".', $user::class));
        }

        $freshUser = $this->userRepository->find($user->getId());

        if (!$freshUser) {
            throw new UserNotFoundException();
        }

        return $freshUser;
    }

    public function supportsClass(string $class): bool
    {
        return \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity::class === $class
            || is_subclass_of($class, \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity::class);
    }

    public function loadUserByIdentifier(string $identifier): UserInterface
    {
        $user = $this->userRepository->findOneBy(['email' => $identifier]);

        if (!$user) {
            throw new UserNotFoundException(sprintf('User "%s" not found.', $identifier));
        }

        return $user;
    }

    public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
    {
        if (!$user instanceof \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity) {
            throw new UnsupportedUserException(sprintf('Invalid user class "%s".', $user::class));
        }

        $user->setPassword($newHashedPassword);
        $this->userRepository->getEntityManager()->persist($user);
        $this->userRepository->getEntityManager()->flush();
    }
}


FICHIER: src/Kernel.php
--------------------------------------------------------------------------------
<?php

namespace App;

use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
}



FICHIER: src/Shared/Application/Command/CommandBusInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandBusInterface
{
    public function execute(CommandInterface $command): mixed;
}



FICHIER: src/Shared/Application/Command/CommandHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandHandlerInterface
{
}



FICHIER: src/Shared/Application/Command/CommandInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandInterface
{
}



FICHIER: src/Shared/Application/Query/QueryBusInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryBusInterface
{
    public function execute(QueryInterface $query): mixed;
}



FICHIER: src/Shared/Application/Query/QueryHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryHandlerInterface
{
}



FICHIER: src/Shared/Application/Query/QueryInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryInterface
{
}



FICHIER: src/Shared/Domain/Event/EventHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Domain\Event;

interface EventHandlerInterface
{
}



FICHIER: src/Shared/Domain/Event/EventInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Domain\Event;

interface EventInterface
{
}



FICHIER: src/Shared/Infrastructure/Bus/CommandBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Command\CommandBusInterface;
use App\Shared\Application\Command\CommandInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class CommandBus implements CommandBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $commandBus)
    {
        $this->messageBus = $commandBus;
    }

    public function execute(CommandInterface $command): mixed
    {
        return $this->handle($command);
    }
}



FICHIER: src/Shared/Infrastructure/Bus/EventBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Event\EventBusInterface;
use App\Shared\Domain\Event\EventInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class EventBus implements EventBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $queryBus)
    {
        $this->messageBus = $queryBus;
    }

    public function execute(EventInterface $event): mixed
    {
        return $this->handle($event);
    }
}



FICHIER: src/Shared/Infrastructure/Bus/QueryBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Query\QueryBusInterface;
use App\Shared\Application\Query\QueryInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class QueryBus implements QueryBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $queryBus)
    {
        $this->messageBus = $queryBus;
    }

    public function execute(QueryInterface $query): mixed
    {
        return $this->handle($query);
    }
}



FICHIER: src/Users/Application/Config/UsersAppConfig.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Config;

class UsersAppConfig
{
    static int $ERREUR_FATAL = 1;
    static int $ERREUR_SYSTEM_INFO = 2;
    static int $ERREUR_USER = 3;
    static int $USER_NEED_RESTART = 10; // temporaire
    static int $USER_BANNED = 20; // dÃ©finitif
    static int $USER_BLOCKED = 30; // temporaire
    static int $USER_UNSUBSCRIBED = 50; // dÃ©finitif


    static int $RANDOM_LIMIT = 10;
    static int $RANDOM_TIME_LIMIT = 5;
    static int $RANDOM_HISTORY_TIME_LIMIT = 604800;
    static string $SLOT_SECRET = "Nu31Xc8em6X76UKGJxqAOTClh6egRT8vAMQYbQdSqVBuToYcFN";
    static int $LINK_SUGGESTED = 1;
    static int $LINK_ACCEPTED = 2;
    static int $LINK_DECLINED = 3;
    static int $LINK_SLOT_WIN = 4;
    static int $NOTIFICATION_STATE_NEW = 0;
    static int $NOTIFICATION_STATE_READ = 1;
    static int $FOLLOW_TYPE_VISIT = 01;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_SUGGEST = 11;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_ACCEPT = 12;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_DECLINE = 13;
    static int $FOLLOW_TYPE_SLOT_WIN = 21;


    static int $NOTIFICATION_TYPE_CONTACT = 1;
    static int $NOTIFICATION_TYPE_SLOT_WIN = 3;
    static int $NOTIFICATION_TYPE_MESSAGE = 10;

    static int $CREDITS_BY_NB_WON = 5;
    static int $FREE_DAY_CREDITS = 50;


    static int $CREDIT_LOG_REASON_DAY_FREE = 1;
    static int $CREDIT_LOG_REASON_SLOT_WIN_CONFIRM = 2;
}


FICHIER: src/Users/Application/DTO/UserDTO.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Users\Application\DTO;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Users\Domain\Entity\User;

class UserDTO
{
    public function __construct(
        public readonly ?int $id,
        public readonly string $uid,
        public readonly string $authUid,
        public readonly string $email,
        public readonly string $username = '',
        public readonly string $aboutMe = '',
        public readonly int $gender = 0,
        public readonly \DateTime $birthdate = new \DateTime(),
        public readonly int $status = 0,
    ) {
    }

    public static function fromEntity(UserEntity $user): self
    {
        return new self(
            $user->getId(),
            $user->getUid(),
            $user->getAuthUid(),
            $user->getEmail(),
            $user->getUsername(),
            $user->getAboutMe(),
            $user->getGender(),
            $user->getBirthdate(),
            $user->getStatus(),
        );
    }
    public static function fromArray(array $user): self
    {
        $birthdate = \DateTime::createFromFormat("Y-m-d", $user['birthdate']);

        return new self(
            $user['id'],
            $user['uid'],
            $user['auth_uid'],
            $user['email'],
            $user['username'],
            $user['about_me'],
            $user['gender'],
            $birthdate,
            $user['status'],
        );
    }

    public static function forSignupProcess(string $authUid): self
    {
        return new self(null, '', $authUid, '');
    }
}



FICHIER: src/Users/Application/Query/GetJwtForSignup/GetJwtForSignupQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtForSignup;

use App\Shared\Application\Query\QueryInterface;
use App\Users\Application\DTO\UserDTO;

class GetJwtForSignupQuery implements QueryInterface
{
    public function __construct(
        public readonly UserDTO $userDto
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetJwtForSignup/GetJwtForSignupQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtForSignup;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Shared\Application\Query\QueryHandlerInterface;
use App\Users\Application\DTO\UserDTO;
//use App\Users\Domain\Repository\UserRepositoryInterface;
use Lcobucci\JWT\Encoding\ChainedFormatter;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Signer\Key\InMemory;
use Lcobucci\JWT\Signer\Hmac\Sha512;
use Lcobucci\JWT\Token\Builder;

class GetJwtForSignupQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {
    }

    public function __invoke(GetJwtForSignupQuery $query): string
    {
        $userDto = $query->userDto;

        $authUid = $userDto->authUid;
        $email = $userDto->email;

        $tokenBuilder = (new Builder(new JoseEncoder(), ChainedFormatter::default()));
        $algorithm = new Sha512();
        $signinKey = InMemory::file(__DIR__.'/../../../../../config/jwt/private.pem');

        $now = new \DateTimeImmutable();

        $token = $tokenBuilder
//            ->issuedBy('http://example.com')
//            ->permittedFor('http://example.org')
//            ->relatedTo('component1')
//            ->identifiedBy('4f1g23a12aa')
//            ->issuedAt($now)
//            ->canOnlyBeUsedAfter($now->modify('+1 minute'))
            ->expiresAt($now->modify('+1 hour'))
            ->withClaim('authUid', $authUid)
            ->withClaim('email', $email)
            ->withClaim('username', $email)
            ->getToken($algorithm, $signinKey);

        return $token->toString();
    }
}



FICHIER: src/Users/Application/Query/GetJwtFromUser/GetJwtFromUserQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtFromUser;

use App\Shared\Application\Query\QueryInterface;
use App\Users\Application\DTO\UserDTO;

class GetJwtFromUserQuery implements QueryInterface
{
    public function __construct(
        public readonly UserDTO $user
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetJwtFromUser/GetJwtFromUserQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtFromUser;

use App\Shared\Application\Query\QueryHandlerInterface;
use Lexik\Bundle\JWTAuthenticationBundle\Encoder\JWTEncoderInterface;

class GetJwtFromUserQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly JWTEncoderInterface $encoder
    ) {
    }

    public function __invoke(GetJwtFromUserQuery $query): string
    {
        return $this->encoder->encode(
            [
                'roles' => [
                    'ROLE_USER',
                ],
                'email' => $query->user->email,
                'username' => $query->user->email,
                'uid' => $query->user->authUid,
            ]
        );
    }
}



FICHIER: src/Users/Application/Query/GetUserByFirebaseToken/GetUserByFirebaseTokenQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetUserByFirebaseToken;

use App\Shared\Application\Query\QueryInterface;

class GetUserByFirebaseTokenQuery implements QueryInterface
{
    public function __construct(
        public readonly string $token,
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetUserByFirebaseToken/GetUserByFirebaseTokenQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetUserByFirebaseToken;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Shared\Application\Query\QueryHandlerInterface;
use App\Users\Application\DTO\UserDTO;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Signer;
use Lcobucci\JWT\Signer\Rsa\Sha256;
use Lcobucci\JWT\Token\Parser;
use Lcobucci\JWT\Token\Plain;
use Lcobucci\JWT\Validation\Constraint\SignedWith;
use Lcobucci\JWT\Validation\Validator;

class GetUserByFirebaseTokenQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {
    }

    public function __invoke(GetUserByFirebaseTokenQuery $query): UserDTO
    {
        $firebaseToken = $query->token;

        $parser = new Parser(new JoseEncoder());

        /** @var Plain $token */
        $token = $parser->parse($firebaseToken);

        $kid = $token->headers()->get('kid');

        $googleJson = file_get_contents('https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com');

        $jsonParsed = json_decode($googleJson, true);

        $privateKey = $jsonParsed[$kid];

        $signer = new Sha256();

        $validator = new Validator();

        $validator->assert($token, new SignedWith($signer, Signer\Key\InMemory::plainText($privateKey)));

        $firebaseAuthId = $token->claims()->get('user_id');

        $user = $this->userRepository->getUserByAuthUid($firebaseAuthId);

        if (null == $user) {
            return UserDTO::forSignupProcess($firebaseAuthId);
        }

        return UserDTO::fromEntity($user);
    }
}



FICHIER: src/Users/Domain/Repository/UserRepositoryInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Users\Domain\Repository;

use App\Users\Domain\Entity\User;

interface UserRepositoryInterface
{
    public function add(User $user): void;
    public function update(User $user): void;
    public function findByAuthUid(string $authUid): ?User;
    public function findByUid(string $uid): ?User;
    public function findDetailedByUid(string $uid, float $myLatitude, float $myLongitude): array;
    public function findByEmail(string $email): ?User;
    public function getUserByAuthUid(string $firebaseAuthId): ?User;
    public function getFilteredList(bool $totally, int $myIdUser, int $skip, int $genderWanted, int $minAge, int $maxAge, int $maxDistance, bool $onlyWithPhoto, bool $onlyInFavorites, float $myLatitude, float $myLongitude): array;
    public function getRandomList(int $myIdUser, array $excludedUsers, int $genderWanted, int $minAge, int $maxAge, int $maxDistance, bool $onlyWithPhoto, bool $onlyInFavorites, float $myLatitude, float $myLongitude, int $nbMax = -1, bool $excludeFake = false): array;
    public function getAllPhotosByUsers(array $listIdUsers): array;
    public function findManyByUids(array $contactsUids);
    public function getContactsFilteredList(int $idUser): array;
    public function findByUsername(string $username): ?User;

    public function getListFromIds(int $myIdUser, array $usersIds, float $myLatitude, float $myLongitude): array;

}



FIN
============
Total fichiers: 81

