Je voudrais maintenant modifier VenueScreen, en rapport avec l'ajout de l'entity VenueEntity.

Au chargement de cette page, il faut appeller l'api /api/venue/list

Voici la rÃ©ponse de l'api :
{
    "items": [
        {
            "id": 50,
            "uuid": "9e43c34e-125a-11f1-bbbb-0242ac1a0002",
            "name": "La Casa",
            "description": "Ambiance latina et cocktails tequila",
            "type": 6,
            "rank": 50
        },
        {
            "id": 49,
            "uuid": "9e43c322-125a-11f1-bbbb-0242ac1a0002",
            "name": "Le Montmartre",
            "description": "Ambiance bohÃ¨me et artists",
            "type": 6,
            "rank": 49
        },
        {
            "id": 48,
            "uuid": "9e43c2fc-125a-11f1-bbbb-0242ac1a0002",
            "name": "Le Lodge",
            "description": "Ambiance safari et cocktails exotiques",
            "type": 6,
            "rank": 48
        },

Ne tenir compte dans les models de l'app (flutter) que de l'uuid, name, description, type.

Il faut passer par apiService pour profiter du refresh de l'interceptor.

Modifier VenuesScreen pour prendre en charge la pagination.
Le type correspond Ã  une images.
1 : 'assets/images/venues/lounge.png'
2 : ...


Voici l'Ã©tat du projet en cours


FICHIERS POUR ANALYSE
=====================
Dossiers analysÃ©s:
  - flutter_lib/features/venues
  - flutter_lib/providers
  - flutter_lib/services
  - src
Extensions: dart, php, yaml, yml
Date: 2026-02-25 15:28:43

ARBORESCENCE:
-------------
â”œâ”€â”€ ğŸ“ flutter_lib/
â”‚   â”œâ”€â”€ ğŸ“ features/
â”‚   â”‚   â””â”€â”€ ğŸ“ venues/
â”‚   â”‚       â”œâ”€â”€ ğŸ“ data/
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ datasources/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_remote_data_source.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_remote_data_source.g.dart
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ models/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_model.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_model.freezed.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_model.g.dart
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ repositories/
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ venues_repository_impl.dart
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“„ venues_repository_impl.g.dart
â”‚   â”‚       â”œâ”€â”€ ğŸ“ domain/
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ entities/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_entity.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_entity.freezed.dart
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ repositories/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_repository.dart
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ usecases/
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ get_venuess_usecase.dart
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“„ get_venuess_usecase.g.dart
â”‚   â”‚       â””â”€â”€ ğŸ“ presentation/
â”‚   â”‚           â”œâ”€â”€ ğŸ“ controllers/
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“„ venues_controller.dart
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“„ venues_controller.g.dart
â”‚   â”‚           â””â”€â”€ ğŸ“ screens/
â”‚   â”‚               â””â”€â”€ ğŸ“„ venues_screen.dart
â”‚   â”œâ”€â”€ ğŸ“ providers/
â”‚   â”‚   â””â”€â”€ ğŸ“„ auth_provider.dart
â”‚   â””â”€â”€ ğŸ“ services/
â”‚       â”œâ”€â”€ ğŸ“„ account_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ account_service.g.dart
â”‚       â”œâ”€â”€ ğŸ“„ api_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ api_service.g.dart
â”‚       â”œâ”€â”€ ğŸ“„ auth_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ sfu_service.dart
â”‚       â””â”€â”€ ğŸ“„ sfu_service.g.dart
â””â”€â”€ ğŸ“ src/
    â”œâ”€â”€ ğŸ“ Domain/
    â”‚   â”œâ”€â”€ ğŸ“ Entity/
    â”‚   â”‚   â””â”€â”€ ğŸ“„ User.php
    â”‚   â”œâ”€â”€ ğŸ“ Repository/
    â”‚   â”‚   â””â”€â”€ ğŸ“„ UserRepositoryInterface.php
    â”‚   â””â”€â”€ ğŸ“ ValueObject/
    â”‚       â”œâ”€â”€ ğŸ“„ Email.php
    â”‚       â””â”€â”€ ğŸ“„ UserRole.php
    â”œâ”€â”€ ğŸ“ Infrastructure/
    â”‚   â”œâ”€â”€ ğŸ“ Console/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Command/
    â”‚   â”‚       â””â”€â”€ ğŸ“„ ClearExpiredRefreshTokensCommand.php
    â”‚   â”œâ”€â”€ ğŸ“ Http/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Controller/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ AccountController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ AuthController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ GenerateLiveKitController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ GeneratePromptController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ LogoutController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ PhotoController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ UsersGetJwtTokenFromFirebaseAuthAction.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ VenueController.php
    â”‚   â”œâ”€â”€ ğŸ“ Persistence/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ Entity/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ RefreshTokenEntity.php
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ UserEntity.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ VenueEntity.php
    â”‚   â”‚       â””â”€â”€ ğŸ“ Repository/
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ RefreshTokenRepository.php
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ UserRepository.php
    â”‚   â”‚           â””â”€â”€ ğŸ“„ VenueRepository.php
    â”‚   â””â”€â”€ ğŸ“ Security/
    â”‚       â”œâ”€â”€ ğŸ“„ JWTLoginSuccessHandler.php
    â”‚       â”œâ”€â”€ ğŸ“„ JwtAuthenticator.php
    â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenAuthenticator.php
    â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenService.php
    â”‚       â””â”€â”€ ğŸ“„ UserProvider.php
    â”œâ”€â”€ ğŸ“ Shared/
    â”‚   â”œâ”€â”€ ğŸ“ Application/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ Command/
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CommandBusInterface.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CommandHandlerInterface.php
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ CommandInterface.php
    â”‚   â”‚   â””â”€â”€ ğŸ“ Query/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ QueryBusInterface.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ QueryHandlerInterface.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ QueryInterface.php
    â”‚   â”œâ”€â”€ ğŸ“ Domain/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Event/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ EventHandlerInterface.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ EventInterface.php
    â”‚   â””â”€â”€ ğŸ“ Infrastructure/
    â”‚       â””â”€â”€ ğŸ“ Bus/
    â”‚           â”œâ”€â”€ ğŸ“„ CommandBus.php
    â”‚           â”œâ”€â”€ ğŸ“„ EventBus.php
    â”‚           â””â”€â”€ ğŸ“„ QueryBus.php
    â”œâ”€â”€ ğŸ“ Users/
    â”‚   â”œâ”€â”€ ğŸ“ Application/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ Config/
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ UsersAppConfig.php
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ DTO/
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ UserDTO.php
    â”‚   â”‚   â””â”€â”€ ğŸ“ Query/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ GetJwtForSignup/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ GetJwtForSignupQuery.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ GetJwtForSignupQueryHandler.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ GetJwtFromUser/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ GetJwtFromUserQuery.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ GetJwtFromUserQueryHandler.php
    â”‚   â”‚       â””â”€â”€ ğŸ“ GetUserByFirebaseToken/
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ GetUserByFirebaseTokenQuery.php
    â”‚   â”‚           â””â”€â”€ ğŸ“„ GetUserByFirebaseTokenQueryHandler.php
    â”‚   â””â”€â”€ ğŸ“ Domain/
    â”‚       â””â”€â”€ ğŸ“ Repository/
    â”‚           â””â”€â”€ ğŸ“„ UserRepositoryInterface.php
    â””â”€â”€ ğŸ“„ Kernel.php


CONTENU DES FICHIERS
====================

FICHIER: flutter_lib/features/venues/data/datasources/venues_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../core/providers/network_providers.dart';
import '../models/venues_model.dart';

part 'venues_remote_data_source.g.dart';

abstract class VenuesRemoteDataSource {
  Future<List<VenuesModel>> fetchVenuess();
  Future<VenuesModel> fetchVenues(String id);
}

@riverpod
VenuesRemoteDataSource venuesRemoteDataSource(Ref ref) {
  final dio = ref.watch(dioProvider);
  return VenuesRemoteDataSourceImpl(dio);
}

class VenuesRemoteDataSourceImpl implements VenuesRemoteDataSource {
  final Dio _dio;

  VenuesRemoteDataSourceImpl(this._dio);

  @override
  Future<List<VenuesModel>> fetchVenuess() async {
    // final response = await _dio.get('/venuess');
    // return (response.data as List).map((e) => VenuesModel.fromJson(e)).toList();
    await Future.delayed(const Duration(seconds: 1));
    return [
      const VenuesModel(id: '1', name: 'Item 1'),
      const VenuesModel(id: '2', name: 'Item 2'),
    ];
  }

  @override
  Future<VenuesModel> fetchVenues(String id) async {
    await Future.delayed(const Duration(seconds: 1));
    return VenuesModel(id: id, name: 'Item ');
  }
}



FICHIER: flutter_lib/features/venues/data/datasources/venues_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(venuesRemoteDataSource)
final venuesRemoteDataSourceProvider = VenuesRemoteDataSourceProvider._();

final class VenuesRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          VenuesRemoteDataSource,
          VenuesRemoteDataSource,
          VenuesRemoteDataSource
        >
    with $Provider<VenuesRemoteDataSource> {
  VenuesRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'venuesRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$venuesRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<VenuesRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  VenuesRemoteDataSource create(Ref ref) {
    return venuesRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(VenuesRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<VenuesRemoteDataSource>(value),
    );
  }
}

String _$venuesRemoteDataSourceHash() =>
    r'e3f50d7bfca91f1f7daddcf90adeb4190d66dc72';



FICHIER: flutter_lib/features/venues/data/models/venues_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/venues_entity.dart';

part 'venues_model.freezed.dart';
part 'venues_model.g.dart';

@freezed
abstract class VenuesModel with _$VenuesModel {
  const VenuesModel._();

  const factory VenuesModel({
    required String id,
    required String name,
  }) = _VenuesModel;

  factory VenuesModel.fromJson(Map<String, dynamic> json) =>
      _$VenuesModelFromJson(json);

  VenuesEntity toEntity() => VenuesEntity(id: id, name: name);
}



FICHIER: flutter_lib/features/venues/data/models/venues_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'venues_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$VenuesModel {

 String get id; String get name;
/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VenuesModelCopyWith<VenuesModel> get copyWith => _$VenuesModelCopyWithImpl<VenuesModel>(this as VenuesModel, _$identity);

  /// Serializes this VenuesModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VenuesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'VenuesModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $VenuesModelCopyWith<$Res>  {
  factory $VenuesModelCopyWith(VenuesModel value, $Res Function(VenuesModel) _then) = _$VenuesModelCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$VenuesModelCopyWithImpl<$Res>
    implements $VenuesModelCopyWith<$Res> {
  _$VenuesModelCopyWithImpl(this._self, this._then);

  final VenuesModel _self;
  final $Res Function(VenuesModel) _then;

/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [VenuesModel].
extension VenuesModelPatterns on VenuesModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _VenuesModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _VenuesModel value)  $default,){
final _that = this;
switch (_that) {
case _VenuesModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _VenuesModel value)?  $default,){
final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _VenuesModel():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _VenuesModel extends VenuesModel {
  const _VenuesModel({required this.id, required this.name}): super._();
  factory _VenuesModel.fromJson(Map<String, dynamic> json) => _$VenuesModelFromJson(json);

@override final  String id;
@override final  String name;

/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VenuesModelCopyWith<_VenuesModel> get copyWith => __$VenuesModelCopyWithImpl<_VenuesModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$VenuesModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VenuesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'VenuesModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$VenuesModelCopyWith<$Res> implements $VenuesModelCopyWith<$Res> {
  factory _$VenuesModelCopyWith(_VenuesModel value, $Res Function(_VenuesModel) _then) = __$VenuesModelCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$VenuesModelCopyWithImpl<$Res>
    implements _$VenuesModelCopyWith<$Res> {
  __$VenuesModelCopyWithImpl(this._self, this._then);

  final _VenuesModel _self;
  final $Res Function(_VenuesModel) _then;

/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_VenuesModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/venues/data/models/venues_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_VenuesModel _$VenuesModelFromJson(Map<String, dynamic> json) =>
    _VenuesModel(id: json['id'] as String, name: json['name'] as String);

Map<String, dynamic> _$VenuesModelToJson(_VenuesModel instance) =>
    <String, dynamic>{'id': instance.id, 'name': instance.name};



FICHIER: flutter_lib/features/venues/data/repositories/venues_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/venues_entity.dart';
import '../../domain/repositories/venues_repository.dart';
import '../datasources/venues_remote_data_source.dart';

part 'venues_repository_impl.g.dart';

@riverpod
VenuesRepository venuesRepository(Ref ref) {
  final remoteDataSource = ref.watch(venuesRemoteDataSourceProvider);
  return VenuesRepositoryImpl(remoteDataSource);
}

class VenuesRepositoryImpl implements VenuesRepository {
  final VenuesRemoteDataSource _remoteDataSource;

  VenuesRepositoryImpl(this._remoteDataSource);

  @override
  Future<List<VenuesEntity>> getVenuess() async {
    final models = await _remoteDataSource.fetchVenuess();
    return models.map((e) => e.toEntity()).toList();
  }

  @override
  Future<VenuesEntity> getVenues(String id) async {
    final model = await _remoteDataSource.fetchVenues(id);
    return model.toEntity();
  }
}



FICHIER: flutter_lib/features/venues/data/repositories/venues_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(venuesRepository)
final venuesRepositoryProvider = VenuesRepositoryProvider._();

final class VenuesRepositoryProvider
    extends
        $FunctionalProvider<
          VenuesRepository,
          VenuesRepository,
          VenuesRepository
        >
    with $Provider<VenuesRepository> {
  VenuesRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'venuesRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$venuesRepositoryHash();

  @$internal
  @override
  $ProviderElement<VenuesRepository> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  VenuesRepository create(Ref ref) {
    return venuesRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(VenuesRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<VenuesRepository>(value),
    );
  }
}

String _$venuesRepositoryHash() => r'955ae296e3ec7371336fe0c1b64a9ea6bb687cc9';



FICHIER: flutter_lib/features/venues/domain/entities/venues_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'venues_entity.freezed.dart';

@freezed
abstract class VenuesEntity with _$VenuesEntity {
  const factory VenuesEntity({
    required String id,
    required String name,
  }) = _VenuesEntity;
}



FICHIER: flutter_lib/features/venues/domain/entities/venues_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'venues_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$VenuesEntity {

 String get id; String get name;
/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VenuesEntityCopyWith<VenuesEntity> get copyWith => _$VenuesEntityCopyWithImpl<VenuesEntity>(this as VenuesEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VenuesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'VenuesEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $VenuesEntityCopyWith<$Res>  {
  factory $VenuesEntityCopyWith(VenuesEntity value, $Res Function(VenuesEntity) _then) = _$VenuesEntityCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$VenuesEntityCopyWithImpl<$Res>
    implements $VenuesEntityCopyWith<$Res> {
  _$VenuesEntityCopyWithImpl(this._self, this._then);

  final VenuesEntity _self;
  final $Res Function(VenuesEntity) _then;

/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [VenuesEntity].
extension VenuesEntityPatterns on VenuesEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _VenuesEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _VenuesEntity value)  $default,){
final _that = this;
switch (_that) {
case _VenuesEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _VenuesEntity value)?  $default,){
final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _VenuesEntity():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc


class _VenuesEntity implements VenuesEntity {
  const _VenuesEntity({required this.id, required this.name});


@override final  String id;
@override final  String name;

/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VenuesEntityCopyWith<_VenuesEntity> get copyWith => __$VenuesEntityCopyWithImpl<_VenuesEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VenuesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'VenuesEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$VenuesEntityCopyWith<$Res> implements $VenuesEntityCopyWith<$Res> {
  factory _$VenuesEntityCopyWith(_VenuesEntity value, $Res Function(_VenuesEntity) _then) = __$VenuesEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$VenuesEntityCopyWithImpl<$Res>
    implements _$VenuesEntityCopyWith<$Res> {
  __$VenuesEntityCopyWithImpl(this._self, this._then);

  final _VenuesEntity _self;
  final $Res Function(_VenuesEntity) _then;

/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_VenuesEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/venues/domain/repositories/venues_repository.dart
--------------------------------------------------------------------------------
import '../entities/venues_entity.dart';

abstract class VenuesRepository {
  Future<List<VenuesEntity>> getVenuess();
  Future<VenuesEntity> getVenues(String id);
}



FICHIER: flutter_lib/features/venues/domain/usecases/get_venuess_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/venues_entity.dart';
import '../repositories/venues_repository.dart';
import '../../data/repositories/venues_repository_impl.dart';

part 'get_venuess_usecase.g.dart';

@riverpod
Future<List<VenuesEntity>> getVenuess(Ref ref) {
  return ref.watch(venuesRepositoryProvider).getVenuess();
}



FICHIER: flutter_lib/features/venues/domain/usecases/get_venuess_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_venuess_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getVenuess)
final getVenuessProvider = GetVenuessProvider._();

final class GetVenuessProvider
    extends
        $FunctionalProvider<
          AsyncValue<List<VenuesEntity>>,
          List<VenuesEntity>,
          FutureOr<List<VenuesEntity>>
        >
    with
        $FutureModifier<List<VenuesEntity>>,
        $FutureProvider<List<VenuesEntity>> {
  GetVenuessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getVenuessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getVenuessHash();

  @$internal
  @override
  $FutureProviderElement<List<VenuesEntity>> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<List<VenuesEntity>> create(Ref ref) {
    return getVenuess(ref);
  }
}

String _$getVenuessHash() => r'6b2a6082f558f080b70226dcebd34eb82d08e689';



FICHIER: flutter_lib/features/venues/presentation/controllers/venues_controller.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/venues_entity.dart';
import '../../domain/usecases/get_venuess_usecase.dart';

part 'venues_controller.g.dart';

@riverpod
class VenuesController extends _$VenuesController {
  @override
  FutureOr<List<VenuesEntity>> build() {
    return ref.watch(getVenuessProvider.future);
  }

  Future<void> refresh() async {
     state = const AsyncValue.loading();
     state = await AsyncValue.guard(() => ref.refresh(getVenuessProvider.future));
  }
}



FICHIER: flutter_lib/features/venues/presentation/controllers/venues_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(VenuesController)
final venuesControllerProvider = VenuesControllerProvider._();

final class VenuesControllerProvider
    extends $AsyncNotifierProvider<VenuesController, List<VenuesEntity>> {
  VenuesControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'venuesControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$venuesControllerHash();

  @$internal
  @override
  VenuesController create() => VenuesController();
}

String _$venuesControllerHash() => r'18c03a10919a21dceb170a8eebf95b929dcd9744';

abstract class _$VenuesController extends $AsyncNotifier<List<VenuesEntity>> {
  FutureOr<List<VenuesEntity>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<List<VenuesEntity>>, List<VenuesEntity>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<VenuesEntity>>, List<VenuesEntity>>,
              AsyncValue<List<VenuesEntity>>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/venues/presentation/screens/venues_screen.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../providers/auth_provider.dart';

class VenuesScreen extends ConsumerStatefulWidget {
  const VenuesScreen({super.key});

  @override
  ConsumerState<VenuesScreen> createState() => _VenuesScreenState();
}

class _VenuesScreenState extends ConsumerState<VenuesScreen> {
  bool _isLoggingOut = false;

  Future<void> _handleLogout(BuildContext context) async {
    if (_isLoggingOut) return;

    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E3F),
        title: const Text(
          'DÃ©connexion',
          style: TextStyle(color: Colors.white),
        ),
        content: const Text(
          'Voulez-vous vraiment vous dÃ©connecter ?',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text(
              'Annuler',
              style: TextStyle(color: Colors.white70),
            ),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF6366F1),
            ),
            child: const Text('DÃ©connexion', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );

    if (confirm == true && !_isLoggingOut) {
      setState(() => _isLoggingOut = true);

      try {
        print('ğŸ”´ [VENUES] DÃ©but de la dÃ©connexion');

        // RÃ©cupÃ©rer le notifier
        final notifier = ref.read(authStateNotifierProvider.notifier);

        // Appeler la mÃ©thode de dÃ©connexion du notifier
        await notifier.signOut();

        // Attendre un peu pour la propagation
        await Future.delayed(const Duration(milliseconds: 300));

        // VÃ©rification
        final authState = ref.read(authStateNotifierProvider);
        final firebaseUser = ref.read(authServiceProvider).currentUser;

        print('ğŸ‘¤ [VENUES] Ã‰tat aprÃ¨s dÃ©connexion: $authState');
        print('ğŸ‘¤ [VENUES] Firebase user: ${firebaseUser?.uid ?? 'null'}');

        if (context.mounted) {
          // Navigation forcÃ©e vers login
          context.go('/login');
        }

      } catch (e, stack) {
        print('âŒ [VENUES] Erreur dÃ©connexion: $e');
        print('ğŸ“š [VENUES] Stack: $stack');

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Erreur dÃ©connexion: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );

          // MÃªme en cas d'erreur, forcer la navigation
          context.go('/login');
        }
      } finally {
        if (mounted) {
          setState(() => _isLoggingOut = false);
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    const backgroundColor = Color(0xFF0F0F23);
    const primaryColor = Color(0xFF6366F1);
    const textPrimary = Colors.white;

    // Surveiller l'Ã©tat d'auth (pour debug)
    ref.listen<AuthState>(authStateNotifierProvider, (previous, next) {
      print('ğŸ”„ [VENUES] Auth state changed: $next');
    });

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: _isLoggingOut
              ? const SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: Colors.white,
              )
          )
              : const Icon(Icons.logout, color: textPrimary),
          onPressed: _isLoggingOut ? null : () => _handleLogout(context),
          tooltip: 'Se dÃ©connecter',
        ),
        title: Text(
          'Nos Bars Virtuels',
          style: TextStyle(
            color: textPrimary,
            fontSize: 24,
            fontWeight: FontWeight.bold,
          ),
        ),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings, color: textPrimary),
            onPressed: () {
              context.go('/account');
            },
            tooltip: 'Mon compte',
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 16),
              child: Text(
                'Choisissez votre ambiance',
                style: TextStyle(
                  color: textPrimary,
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            Expanded(
              child: GridView.builder(
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                  crossAxisSpacing: 16,
                  mainAxisSpacing: 16,
                  childAspectRatio: 0.8,
                ),
                itemCount: _venues.length,
                itemBuilder: (context, index) {
                  final venue = _venues[index];
                  return _buildVenueCard(venue, primaryColor, backgroundColor, textPrimary);
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildVenueCard(Map<String, dynamic> venue, Color primaryColor, Color backgroundColor, Color textPrimary) {
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      color: backgroundColor,
      child: InkWell(
        onTap: () {
          final venueId = venue['id'] ?? 'default';
          context.go('/venues/$venueId/tables');
        },
        borderRadius: BorderRadius.circular(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              height: 120,
              decoration: BoxDecoration(
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
                image: DecorationImage(
                  image: AssetImage(venue['image']),
                  fit: BoxFit.cover,
                ),
              ),
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.transparent,
                      Colors.black.withOpacity(0.6),
                    ],
                  ),
                ),
                alignment: Alignment.bottomLeft,
                padding: const EdgeInsets.all(12),
                child: Text(
                  venue['name'],
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    venue['description'],
                    style: TextStyle(
                      color: textPrimary.withOpacity(0.8),
                      fontSize: 12,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  final List<Map<String, dynamic>> _venues = [
    {
      'id': 'lounge',
      'name': 'Le Lounge Ã‰toilÃ©',
      'description': 'Ambiance lounge avec vue sur les Ã©toiles',
      'image': 'assets/images/venues/lounge.png',
      'activeUsers': 24,
    },
    {
      'id': 'port',
      'name': 'Le Bar du Port',
      'description': 'Son des vagues et cocktails fruitÃ©s',
      'image': 'assets/images/venues/port.png',
      'activeUsers': 18,
    },
    {
      'id': 'rooftop',
      'name': 'Le Rooftop Urbain',
      'description': 'Vue panoramique sur la skyline',
      'image': 'assets/images/venues/rooftop.png',
      'activeUsers': 32,
    },
    {
      'id': 'jazz',
      'name': 'La Cave Jazz',
      'description': 'Ambiance intime et musique live',
      'image': 'assets/images/venues/jazz.png',
      'activeUsers': 12,
    },
    {
      'id': 'garden',
      'name': 'Le Garden Tropical',
      'description': 'Jardin virtuel avec cocktails exotiques',
      'image': 'assets/images/venues/garden.png',
      'activeUsers': 28,
    },
    {
      'id': 'club',
      'name': 'Le Club PrivÃ©',
      'description': 'AccÃ¨s exclusif, ambiance feutrÃ©e',
      'image': 'assets/images/venues/club.png',
      'activeUsers': 8,
    },
  ];
}


FICHIER: flutter_lib/providers/auth_provider.dart
--------------------------------------------------------------------------------
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../services/api_service.dart';
import '../services/auth_service.dart';

// Provider pour FlutterSecureStorage (sÃ©parÃ© pour Ã©viter les dÃ©pendances circulaires)
final secureStorageProvider = Provider<FlutterSecureStorage>((ref) {
  return const FlutterSecureStorage();
});

// Provider pour Dio
final dioProvider = Provider<Dio>((ref) {
  return Dio();
});

// Provider pour ApiService (sans rÃ©fÃ©rence Ã  authStateNotifierProvider)
final apiServiceProvider = Provider<ApiService>((ref) {
  final dio = ref.watch(dioProvider);
  final storage = ref.watch(secureStorageProvider);
  return ApiService(dio: dio, storage: storage);
});

// Provider pour AuthService
final authServiceProvider = Provider<AuthService>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthService(
    onAuthenticationEvent: (event) async {
      print('Authentication event: $event');
    },
    onAuthenticationError: (error) async {
      print('Authentication error: $error');
    },
    apiService: apiService,
  );
});

// Stream provider pour les changements d'Ã©tat Firebase
final authStateProvider = StreamProvider<User?>((ref) {
  final authService = ref.watch(authServiceProvider);
  return authService.authStateChanges;
});

// Provider pour l'utilisateur courant Firebase
final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authServiceProvider).currentUser;
});

// Provider pour rÃ©cupÃ©rer le JWT applicatif (version FutureProvider)
final appJwtProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getAppJwt();
});

// Provider pour rÃ©cupÃ©rer le refresh token
final refreshTokenProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getRefreshToken();
});

// ============================================================
// GESTION COMPLÃˆTE DE L'AUTH
// ============================================================

// Enum pour les diffÃ©rents statuts d'authentification
enum AuthStatus {
  initial,           // Non connectÃ©
  authenticated,     // Firebase OK mais JWT en cours
  fullyAuthenticated, // Firebase + JWT OK
  error,             // Erreur
}

// Classe reprÃ©sentant l'Ã©tat d'authentification complet
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? jwtToken;
  final String? refreshToken;
  final Object? error;

  const AuthState({
    required this.status,
    this.user,
    this.jwtToken,
    this.refreshToken,
    this.error,
  });

  static const AuthState initial = AuthState(status: AuthStatus.initial);

  const AuthState.authenticated(User user) : this(
    status: AuthStatus.authenticated,
    user: user,
  );

  const AuthState.fullyAuthenticated({
    required User user,
    required String jwtToken,
    String? refreshToken,
  }) : this(
    status: AuthStatus.fullyAuthenticated,
    user: user,
    jwtToken: jwtToken,
    refreshToken: refreshToken,
  );

  const AuthState.error(Object error) : this(
    status: AuthStatus.error,
    error: error,
  );

  // MÃ©thodes utilitaires
  bool get isFullyAuthenticated => status == AuthStatus.fullyAuthenticated;
  bool get isAuthenticated => status == AuthStatus.authenticated || status == AuthStatus.fullyAuthenticated;
  bool get isInitial => status == AuthStatus.initial;
  bool get hasError => status == AuthStatus.error;

  // MÃ©thode copyWith
  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? jwtToken,
    String? refreshToken,
    Object? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      jwtToken: jwtToken ?? this.jwtToken,
      refreshToken: refreshToken ?? this.refreshToken,
      error: error ?? this.error,
    );
  }

  @override
  String toString() {
    return 'AuthState(status: $status, user: ${user?.uid ?? 'null'}, hasJwt: ${jwtToken != null}, hasRefresh: ${refreshToken != null})';
  }
}

// StateNotifier pour gÃ©rer l'Ã©tat d'authentification complet
class AuthStateNotifier extends StateNotifier<AuthState> {
  final AuthService _authService;
  final Ref _ref;
  StreamSubscription<User?>? _authSubscription;

  AuthStateNotifier({
    required AuthService authService,
    required Ref ref,
  }) : _authService = authService,
        _ref = ref,
        super(AuthState.initial) {
    _init();
  }

  Future<void> _init() async {
    print('ğŸŸ¡ [NOTIFIER] Initialisation...');

    // Configurer le callback unauthorized dans ApiService APRÃˆS la crÃ©ation
    // Mais on ne peut pas le faire ici car Ã§a crÃ©erait une dÃ©pendance circulaire
    // On va plutÃ´t le faire depuis le main ou depuis un provider sÃ©parÃ©

    // Ã‰couter DIRECTEMENT le stream Firebase Auth (plus fiable)
    _authSubscription = _authService.authStateChanges.listen(
          (user) {
        print('ğŸ”µ [NOTIFIER] Firebase Auth State Change: ${user?.uid ?? 'null'}');

        if (user != null) {
          print('âœ… [NOTIFIER] Utilisateur Firebase connectÃ©');
          state = AuthState.authenticated(user);
          _checkTokens(user);
        } else {
          print('âŒ [NOTIFIER] Utilisateur Firebase DÃ‰CONNECTÃ‰ - RÃ©initialisation');
          state = AuthState.initial;
        }
      },
      onError: (error) {
        print('âŒ [NOTIFIER] Erreur auth stream: $error');
        state = AuthState.error(error);
      },
    );

    // Garder le listener du provider pour compatibilitÃ©
    _ref.listen(authStateProvider, (previous, next) {
      next.whenData((user) {
        print('ğŸŸ¡ [PROVIDER] authStateProvider: ${user?.uid ?? 'null'}');
      });
    });

    // Ã‰couter les Ã©vÃ©nements d'authentification
    _authService.onAuthenticationEvent = (event) async {
      if (event is GoogleSignInAuthenticationEventSignIn) {
        print('ğŸ“¡ [NOTIFIER] Ã‰vÃ©nement d\'authentification reÃ§u');

        const maxAttempts = 10;
        var attempts = 0;
        String? jwt;
        String? refreshToken;

        while (attempts < maxAttempts) {
          await Future.delayed(const Duration(milliseconds: 300));
          jwt = await _authService.getAppJwt();
          refreshToken = await _authService.getRefreshToken();
          if (jwt != null && jwt.isNotEmpty) {
            break;
          }
          attempts++;
        }

        final user = _authService.currentUser;

        if (jwt != null && jwt.isNotEmpty && user != null) {
          state = AuthState.fullyAuthenticated(
            user: user,
            jwtToken: jwt,
            refreshToken: refreshToken,
          );
          print('âœ… [NOTIFIER] Authentification complÃ¨te (Firebase + JWT)');
        } else if (user != null) {
          state = AuthState.authenticated(user);
          print('âš ï¸ [NOTIFIER] Firebase authentifiÃ© mais JWT manquant');
        }
      }
    };

    // Ã‰couter les erreurs d'authentification
    _authService.onAuthenticationError = (error) async {
      state = AuthState.error(error);
      print('âŒ [NOTIFIER] Erreur d\'authentification: $error');
    };
  }

  Future<void> _checkTokens(User user) async {
    try {
      final existingJwt = await _authService.getAppJwt();
      final existingRefresh = await _authService.getRefreshToken();

      if (existingJwt != null && existingJwt.isNotEmpty) {
        state = AuthState.fullyAuthenticated(
          user: user,
          jwtToken: existingJwt,
          refreshToken: existingRefresh,
        );
        print('âœ… [NOTIFIER] Tokens dÃ©jÃ  prÃ©sents');
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur vÃ©rification tokens: $e');
    }
  }

  /*
  // Nouvelle mÃ©thode pour gÃ©rer les erreurs 401
  Future<void> handleUnauthorized() async {
    print('âš ï¸ [NOTIFIER] Erreur 401 - Tentative de refresh token...');

    try {
      final newToken = await _authService.refreshJwtToken();

      if (newToken != null && state.user != null) {
        final refreshToken = await _authService.getRefreshToken();
        state = AuthState.fullyAuthenticated(
          user: state.user!,
          jwtToken: newToken,
          refreshToken: refreshToken,
        );
        print('âœ… [NOTIFIER] Token rafraÃ®chi avec succÃ¨s');
      } else {
        // Impossible de rafraÃ®chir, dÃ©connexion
        print('âŒ [NOTIFIER] Ã‰chec du refresh - DÃ©connexion');
        await signOut();
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur handleUnauthorized: $e');
      await signOut();
    }
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ [NOTIFIER] signOut() appelÃ©');

    try {
      state = AuthState.initial;
      await _authService.signOut();

      final userAfter = _authService.currentUser;
      print('ğŸ‘¤ [NOTIFIER] Utilisateur aprÃ¨s service.signOut(): ${userAfter?.uid ?? 'null'}');

      await Future.delayed(const Duration(milliseconds: 200));

      if (_authService.currentUser != null) {
        print('âš ï¸ [NOTIFIER] Utilisateur toujours connectÃ© - tentative de force');
        await _authService.forceSignOut();
        state = AuthState.initial;
      }

      print('âœ… [NOTIFIER] signOut() terminÃ©');
    } catch (e, stack) {
      print('âŒ [NOTIFIER] Erreur signOut: $e');
      print('ğŸ“š [NOTIFIER] Stack: $stack');
      state = AuthState.initial;
      rethrow;
    }
  }

  // MÃ©thode pour rÃ©initialiser manuellement l'Ã©tat
  void reset() {
    print('ğŸŸ¡ [NOTIFIER] reset() appelÃ©');
    state = AuthState.initial;
  }

  // MÃ©thode pour forcer une erreur
  void setError(Object error) {
    print('âŒ [NOTIFIER] setError(): $error');
    state = AuthState.error(error);
  }

  @override
  void dispose() {
    _authSubscription?.cancel();
    super.dispose();
  }
}

// StateNotifierProvider
final authStateNotifierProvider = StateNotifierProvider<AuthStateNotifier, AuthState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return AuthStateNotifier(
    authService: authService,
    ref: ref,
  );
});

// Providers utilitaires
final isFullyAuthenticatedProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.isFullyAuthenticated;
});

final appJwtSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.jwtToken;
});

final refreshTokenSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.refreshToken;
});

final currentUserSyncProvider = Provider<User?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.user;
});

final isAuthenticatingProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.status == AuthStatus.authenticated;
});

final authErrorProvider = Provider<Object?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.error;
});

/*
// Provider sÃ©parÃ© pour configurer le callback unauthorized (Ã  utiliser dans main.dart)
final unauthorizedCallbackProvider = Provider<void Function()>((ref) {
  return () {
    // Cette fonction sera appelÃ©e quand une erreur 401 non rÃ©cupÃ©rable survient
    ref.read(authStateNotifierProvider.notifier).handleUnauthorized();
  };
});

 */


FICHIER: flutter_lib/services/account_service.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'api_service.dart';

part 'account_service.g.dart';

class AccountService {
  final ApiService _apiService;

  AccountService({required ApiService apiService}) : _apiService = apiService;

  // Profile
  Future<Map<String, dynamic>> getProfile() async {
    return _apiService.getProfile();
  }

  Future<Map<String, dynamic>> getAboutMe() async {
    return _apiService.getAboutMe();
  }

  Future<Map<String, dynamic>> getPhoto() async {
    return _apiService.getPhoto();
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    await _apiService.updateProfile(
      displayName: displayName,
      gender: gender,
      birthdate: birthdate,
    );
  }

  Future<void> updateAboutMe(String aboutMe) async {
    await _apiService.updateAboutMe(aboutMe);
  }

  Future<void> updatePhoto(String photoPath) async {
    await _apiService.updatePhoto(photoPath);
  }
}

@riverpod
AccountService accountService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AccountService(apiService: apiService);
}


FICHIER: flutter_lib/services/account_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountService)
final accountServiceProvider = AccountServiceProvider._();

final class AccountServiceProvider
    extends $FunctionalProvider<AccountService, AccountService, AccountService>
    with $Provider<AccountService> {
  AccountServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountServiceHash();

  @$internal
  @override
  $ProviderElement<AccountService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  AccountService create(Ref ref) {
    return accountService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountService>(value),
    );
  }
}

String _$accountServiceHash() => r'b1473d081de813201df44ed2b261f6b3f8538fee';



FICHIER: flutter_lib/services/api_service.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:developer';
import 'dart:ui';

import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'api_service.g.dart';

class ApiException implements Exception {
  final String message;
  final int? statusCode;
  final dynamic originalError;

  ApiException({
    required this.message,
    this.statusCode,
    this.originalError,
  });

  @override
  String toString() => 'ApiException: $message (Status: $statusCode)';
}

class ApiService {
  final Dio _dio;
  final FlutterSecureStorage _storage;
  static const _baseUrl = 'http://192.168.1.56:8101/api';

  // Callback pour la dÃ©connexion en cas d'Ã©chec de refresh
  VoidCallback? onUnauthorized;

  ApiService({
    required Dio dio,
    required FlutterSecureStorage storage,
  })  : _dio = dio,
        _storage = storage {
    _dio.options.baseUrl = _baseUrl;
    _dio.options.headers['accept'] = 'application/json';
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.connectTimeout = const Duration(seconds: 10);
    _dio.options.receiveTimeout = const Duration(seconds: 10);

    _dio.interceptors.add(LogInterceptor(requestBody: true, responseBody: true));

    // Ajouter l'intercepteur pour le refresh token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {
          // Ne pas ajouter le token pour les endpoints d'auth
          if (!options.path.contains('/auth/refresh') &&
              !options.path.contains('/auth/login') &&
              !options.path.contains('/users/jwt-by-firebase-token')) {

            final token = await _storage.read(key: 'app_jwt_token');

            if (token != null) {
              options.headers['Authorization'] = 'Bearer $token';
            }
          }

          return handler.next(options);
        },
        onError: (error, handler) async {
          // Si erreur 401 et que ce n'est pas dÃ©jÃ  une tentative de refresh
          if (error.response?.statusCode == 401 &&
              !error.requestOptions.path.contains('/auth/refresh')) {

            try {
              // Tenter de rafraÃ®chir le token
              final newToken = await _refreshToken();

              if (newToken != null) {
                // Rejouer la requÃªte originale avec le nouveau token
                final options = error.requestOptions;
                options.headers['Authorization'] = 'Bearer $newToken';

                final response = await _dio.fetch(options);
                return handler.resolve(response);
              }
            } catch (refreshError) {
              print('âŒ Erreur lors du refresh: $refreshError');
            }

            // Si le refresh Ã©choue, notifier pour dÃ©connecter l'utilisateur
            if (onUnauthorized != null) {
              onUnauthorized!();
            }
          }

          return handler.next(error);
        },
      ),
    );
  }

  bool _isRefreshing = false;
  final List<Completer<String?>> _refreshCompleters = [];

  Future<String?> _refreshToken() async {
    if (_isRefreshing) {
      // Si un refresh est dÃ©jÃ  en cours, attendre son rÃ©sultat
      final completer = Completer<String?>();
      _refreshCompleters.add(completer);
      return completer.future;
    }

    _isRefreshing = true;
    final completer = Completer<String?>();
    _refreshCompleters.add(completer);

    try {
      final refreshToken = await _storage.read(key: 'refresh_token');

      if (refreshToken == null) {
        throw Exception('No refresh token');
      }

      final appJwtToken = await _storage.read(key: 'app_jwt_token');

      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
            extra: {'noToken': true},
            headers: {'Authorization': 'Bearer $appJwtToken'}
        ),
      );

      if (response.statusCode == 200) {
        final newToken = response.data['token'];
        final newRefreshToken = response.data['refresh_token'];

        await _storage.write(key: 'app_jwt_token', value: newToken);
        if (newRefreshToken != null) {
          await _storage.write(key: 'refresh_token', value: newRefreshToken);
        }

        // RÃ©soudre tous les completer en attente
        for (final c in _refreshCompleters) {
          c.complete(newToken);
        }

        return newToken;
      }
    } catch (e) {
      print('âŒ Erreur refresh token: $e');
      // En cas d'erreur, Ã©chouer tous les completer
      for (final c in _refreshCompleters) {
        c.completeError(e);
      }
    } finally {
      _isRefreshing = false;
      _refreshCompleters.clear();
    }

    return null;
  }

  // MÃ©thode gÃ©nÃ©rique pour gÃ©rer les requÃªtes avec gestion d'erreur centralisÃ©e
  Future<T> safeApiCall<T>({
    required Future<T> Function() apiCall,
    String? errorMessage,
  }) async {
    try {
      return await apiCall();
    } on DioException catch (e) {
      throw _handleDioError(e, errorMessage);
    } catch (e) {
      throw ApiException(
        message: errorMessage ?? 'Une erreur inattendue est survenue',
        originalError: e,
      );
    }
  }

  ApiException _handleDioError(DioException e, String? customMessage) {
    String message;
    int? statusCode = e.response?.statusCode;

    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        message = 'DÃ©lai de connexion dÃ©passÃ©';
        break;
      case DioExceptionType.badResponse:
        message = _parseErrorResponse(e.response);
        break;
      case DioExceptionType.cancel:
        message = 'RequÃªte annulÃ©e';
        break;
      case DioExceptionType.connectionError:
        message = 'Erreur de connexion rÃ©seau';
        break;
      default:
        message = customMessage ?? 'Erreur rÃ©seau inconnue';
    }

    return ApiException(
      message: message,
      statusCode: statusCode,
      originalError: e,
    );
  }

  String _parseErrorResponse(Response? response) {
    try {
      if (response?.data != null && response!.data is Map) {
        return response.data['message'] ??
            response.data['error'] ??
            'Erreur serveur (${response.statusCode})';
      }
      return 'Erreur serveur (${response?.statusCode ?? 'inconnue'})';
    } catch (_) {
      return 'Erreur serveur inconnue';
    }
  }

  // MÃ©thodes API spÃ©cifiques
  Future<Map<String, dynamic>> getJwtFromFirebaseToken(String firebaseToken) async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.post(
          '/users/jwt-by-firebase-token',
          data: {'token': firebaseToken},
          options: Options(extra: {'noToken': true}),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la rÃ©cupÃ©ration du JWT',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le token JWT',
    );
  }

  // Nouvelle mÃ©thode pour rÃ©voquer le refresh token (logout)
  Future<void> revokeRefreshToken(String refreshToken) async {
    try {
      final token = await _storage.read(key: 'app_jwt_token');
      await _dio.post(
        '/auth/logout',
        data: {'refresh_token': refreshToken},
        options: Options(
          headers: token != null ? {'Authorization': 'Bearer $token'} : {},
          extra: {'noToken': true},
        ),
      );
    } catch (e) {
      print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
    }
  }

  Future<Map<String, dynamic>> generateLiveKitToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return safeApiCall(
      apiCall: () async {
        final payload = {
          "participant_identity": participantIdentity,
          "participant_name": participantName,
          "participant_metadata": participantMetadata,
          "participant_attributes": participantAttributes,
          "room_name": roomName,
          "room_config": roomConfig
        };

        final appJwt = await _storage.read(key: 'app_jwt_token');

        if (appJwt == null) {
          throw ApiException(message: 'JWT token non disponible');
        }

        final response = await _dio.post(
          '/sfu/generate-token',
          data: payload,
          options: Options(
            headers: {
              'Authorization': 'Bearer $appJwt',
            },
          ),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la gÃ©nÃ©ration du token LiveKit',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de gÃ©nÃ©rer le token LiveKit',
    );
  }

  // Profile methods
  Future<Map<String, dynamic>> getProfile() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/me');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le profil',
    );
  }

  Future<Map<String, dynamic>> getAboutMe() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/about-me');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer "Ã  propos"',
    );
  }

  Future<Map<String, dynamic>> getPhoto() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/photo');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer la photo',
    );
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    return safeApiCall(
      apiCall: () async {
        final data = <String, dynamic>{};
        if (displayName != null) data['displayName'] = displayName;
        if (gender != null) data['gender'] = gender;
        if (birthdate != null) data['birthdate'] = birthdate.toIso8601String();

        await _dio.put('/account/me', data: data);
      },
      errorMessage: 'Impossible de mettre Ã  jour le profil',
    );
  }

  Future<void> updateAboutMe(String aboutMe) async {
    return safeApiCall(
      apiCall: () async {
        await _dio.put('/account/about-me', data: {'about_me': aboutMe});
      },
      errorMessage: 'Impossible de mettre Ã  jour "Ã  propos"',
    );
  }

  Future<void> updatePhoto(String photoPath) async {
    return safeApiCall(
      apiCall: () async {
        final formData = FormData.fromMap({
          'photo': await MultipartFile.fromFile(photoPath),
        });
        await _dio.put('/account/photo', data: formData);
      },
      errorMessage: 'Impossible de mettre Ã  jour la photo',
    );
  }


// Dans flutter_lib/services/api_service.dart

  Future<Map<String, dynamic>?> refreshJwtToken(String refreshToken) async {
    try {
      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
          extra: {'noToken': true},
        ),
      );

      if (response.statusCode == 200) {
        return response.data as Map<String, dynamic>;
      }
    } catch (e) {
      print('âŒ Erreur refresh token API: $e');
    }

    return null;
  }


}

@riverpod
ApiService apiService(Ref ref) {
  final dio = Dio();
  final storage = const FlutterSecureStorage();
  return ApiService(dio: dio, storage: storage);
}


FICHIER: flutter_lib/services/api_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'api_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(apiService)
final apiServiceProvider = ApiServiceProvider._();

final class ApiServiceProvider
    extends $FunctionalProvider<ApiService, ApiService, ApiService>
    with $Provider<ApiService> {
  ApiServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'apiServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$apiServiceHash();

  @$internal
  @override
  $ProviderElement<ApiService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  ApiService create(Ref ref) {
    return apiService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ApiService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ApiService>(value),
    );
  }
}

String _$apiServiceHash() => r'eb9a66cc54e1c15d5870b8da260d4ea1f6b053ac';



FICHIER: flutter_lib/services/auth_service.dart
--------------------------------------------------------------------------------
import 'dart:developer';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'api_service.dart';

class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final ApiService _apiService;

  final _storage = const FlutterSecureStorage();

  static const _tokenKey = 'firebase_id_token';
  static const _appJwtKey = 'app_jwt_token';
  static const _refreshTokenKey = 'refresh_token';
  static const _userIdentityKey = 'connected_user_identity';
  static const _userDisplayNameKey = 'connected_user_displayname';

  Future<void> Function(GoogleSignInAuthenticationEvent)? onAuthenticationEvent;
  Future<void> Function(Object)? onAuthenticationError;

  AuthService({
    this.onAuthenticationEvent,
    this.onAuthenticationError,
    required ApiService apiService,
  }) : _apiService = apiService;

  User? get currentUser => _firebaseAuth.currentUser;

  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

  bool _isSignInInitialized = false;

  String? clientId;
  String? serverClientId = '1084343369802-36565dmgarm2gkos54eb6j9q6so0s9bf.apps.googleusercontent.com';
  List<String> scopes = <String>[
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
  ];
  final GoogleSignIn signIn = GoogleSignIn.instance;

  Future<void> _handleAuthenticationEvent(GoogleSignInAuthenticationEvent event) async {
    final GoogleSignInAccount? user = switch (event) {
      GoogleSignInAuthenticationEventSignIn() => event.user,
      GoogleSignInAuthenticationEventSignOut() => null,
    };

    final GoogleSignInClientAuthorization? authorization = await user?.authorizationClient.authorizationForScopes(scopes);

    if (user != null && authorization != null) {
      print(user);
      print("===== user =======");

      try {
        final OAuthCredential googleCredential = GoogleAuthProvider.credential(
          accessToken: authorization.accessToken,
          idToken: user.authentication.idToken,
        );

        final UserCredential googleUserCredential = await FirebaseAuth.instance.signInWithCredential(googleCredential);

        IdTokenResult tokenResult = await FirebaseAuth.instance.currentUser!.getIdTokenResult();

        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        log(tokenResult.token.toString());

        if (tokenResult.token != null) {
          await _storage.write(key: _tokenKey, value: tokenResult.token);
          await _storage.write(key: _userIdentityKey, value: user.displayName);
          await _storage.write(key: _userDisplayNameKey, value: user.displayName);

          try {
            print('ğŸ”„ RÃ©cupÃ©ration du JWT applicatif... =======================================');
            final response = await _apiService.getJwtFromFirebaseToken(tokenResult.token!);

            // La rÃ©ponse contient maintenant jwt ET refresh_token
            if (response is Map<String, dynamic>) {
              print('TOKEN ==============');
              log('***** from firebase token : ' + response['token'].toString());
              await _storage.write(key: _appJwtKey, value: response['token']);
              if (response['refresh_token'] != null) {
                print('REFRESH TOKEN ==============');
                print(response['refresh_token']);
                await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
              }
            } else {
              // Pour compatibilitÃ© avec l'ancien format
              await _storage.write(key: _appJwtKey, value: response.toString());
            }

            print('âœ… JWT applicatif rÃ©cupÃ©rÃ© et stockÃ©');
          } catch (e) {
            print('âŒ Erreur lors de la rÃ©cupÃ©ration du JWT applicatif: $e');
          }

          if (onAuthenticationEvent != null) {
            await onAuthenticationEvent!(event);
          }

          print(tokenResult.token);
          print("====== tokenResult.token =======");
        }
      } catch (error) {
        print(error);
        print('error');

        if (onAuthenticationError != null) {
          await onAuthenticationError!(error);
        }
      }
    }
  }

  Future<void> _handleAuthenticationError(Object e) async {
    print(e);
    if (onAuthenticationError != null) {
      await onAuthenticationError!(e);
    }
  }

  Future<void> initGoogleSignIn() async {
    if (_isSignInInitialized) return;

    _isSignInInitialized = true;

    await signIn.initialize(clientId: clientId, serverClientId: serverClientId).then((_) async {
      signIn.authenticationEvents.listen(_handleAuthenticationEvent).onError(_handleAuthenticationError);
    });
  }

  Future<User?> signInWithGoogle() async {
    await initGoogleSignIn();

    if (GoogleSignIn.instance.supportsAuthenticate()) {
      try {
        await GoogleSignIn.instance.authenticate();
      } catch (e) {
        print("Erreur Google Sign-In : $e");
      }
    }
  }

  Future<String?> getAppJwt() async {
    return await _storage.read(key: _appJwtKey);
  }

  Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }

  /*
  // Nouvelle mÃ©thode pour rafraÃ®chir le token
  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ DÃ‰BUT DÃ‰CONNEXION - Utilisateur avant: ${_firebaseAuth.currentUser?.uid}');

    try {
      // 1. RÃ©voquer le refresh token cÃ´tÃ© serveur
      final refreshToken = await getRefreshToken();
      if (refreshToken != null) {
        try {
          await _apiService.revokeRefreshToken(refreshToken);
          print('âœ… Refresh token rÃ©voquÃ© cÃ´tÃ© serveur');
        } catch (e) {
          print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
        }
      }

      // 2. DÃ©connexion Google
      await GoogleSignIn.instance.signOut();

      // 3. DÃ©connexion Firebase
      print('ğŸŸ¡ DÃ©connexion Firebase...');
      await _firebaseAuth.signOut();
      print('âœ… Firebase signOut() exÃ©cutÃ©');

      // 4. VÃ©rification post-dÃ©connexion
      final userAfter = _firebaseAuth.currentUser;
      print('ğŸ‘¤ Utilisateur aprÃ¨s Firebase.signOut(): $userAfter');

      // 5. Attendre un cycle d'event loop pour propager le changement
      await Future.delayed(const Duration(milliseconds: 100));

      // 6. Nettoyer le stockage
      print('ğŸŸ¡ Nettoyage du stockage...');
      await _storage.delete(key: _tokenKey);
      await _storage.delete(key: _appJwtKey);
      await _storage.delete(key: _refreshTokenKey);
      await _storage.delete(key: _userIdentityKey);
      await _storage.delete(key: _userDisplayNameKey);
      print('âœ… Stockage nettoyÃ©');

      // 7. VÃ©rification finale
      final finalUser = _firebaseAuth.currentUser;
      if (finalUser != null) {
        print('âš ï¸ ATTENTION: Utilisateur toujours prÃ©sent aprÃ¨s dÃ©connexion!');
        await forceSignOut();
      } else {
        print('âœ… Utilisateur bien null aprÃ¨s dÃ©connexion');
      }

      print('âœ… DÃ‰CONNEXION TERMINÃ‰E');
    } catch (e, stack) {
      print('âŒ ERREUR DÃ‰CONNEXION: $e');
      print('ğŸ“š Stack: $stack');
      rethrow;
    }
  }

  // MÃ©thode utilitaire pour forcer une dÃ©connexion radicale
  Future<void> forceSignOut() async {
    print('ğŸ”´ FORCE SIGN OUT - MÃ©thode radicale');

    try {
      await _firebaseAuth.signOut();
      await GoogleSignIn.instance.signOut();
      await _storage.deleteAll();
      await Future.delayed(const Duration(milliseconds: 200));
      print('âœ… Force sign out exÃ©cutÃ©');
      print('ğŸ‘¤ Utilisateur aprÃ¨s force: ${_firebaseAuth.currentUser?.uid ?? 'null'}');
    } catch (e) {
      print('âŒ Erreur force sign out: $e');
    }
  }

  bool isLoggedIn() {
    return _firebaseAuth.currentUser != null;
  }

  Future<bool> isUserLoggedIn() async {
    return _firebaseAuth.currentUser != null;
  }


  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }
}


FICHIER: flutter_lib/services/sfu_service.dart
--------------------------------------------------------------------------------
// CrÃ©er un nouveau fichier: flutter_lib/features/tables/services/sfu_service.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../services/api_service.dart';

part 'sfu_service.g.dart';

class SfuService {
  final ApiService _apiService;

  SfuService({required ApiService apiService}) : _apiService = apiService;

  Future<Map<String, dynamic>> generateToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return _apiService.generateLiveKitToken(
      participantIdentity: participantIdentity,
      participantName: participantName,
      participantAttributes: participantAttributes,
      participantMetadata: participantMetadata,
      roomName: roomName,
      roomConfig: roomConfig,
    );
  }
}

@riverpod
SfuService sfuService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return SfuService(apiService: apiService);
}


FICHIER: flutter_lib/services/sfu_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sfu_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(sfuService)
final sfuServiceProvider = SfuServiceProvider._();

final class SfuServiceProvider
    extends $FunctionalProvider<SfuService, SfuService, SfuService>
    with $Provider<SfuService> {
  SfuServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'sfuServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$sfuServiceHash();

  @$internal
  @override
  $ProviderElement<SfuService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  SfuService create(Ref ref) {
    return sfuService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(SfuService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<SfuService>(value),
    );
  }
}

String _$sfuServiceHash() => r'eec97a26458eb6027d15e5c5845938b8e56f520d';



FICHIER: src/Domain/Entity/User.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\Entity;

use App\Domain\ValueObject\Email;
use App\Domain\ValueObject\UserRole;

/**
 * Domain Entity - Aucune dÃ©pendance vers Doctrine ou Symfony
 */
class User
{
    private ?int $id = null;
    private Email $email;
    private array $roles = [];
    private string $password;
    private ?string $firstname = null;
    private ?string $lastname = null;
    private bool $isActive = true;
    private \DateTimeInterface $createdAt;
    private ?\DateTimeInterface $updatedAt = null;

    public function __construct(
        Email $email,
        string $hashedPassword,
        ?string $firstname = null,
        ?string $lastname = null
    ) {
        $this->email = $email;
        $this->password = $hashedPassword;
        $this->firstname = $firstname;
        $this->lastname = $lastname;
        $this->roles = [UserRole::ROLE_USER];
        $this->createdAt = new \DateTime();
    }

    public static function create(
        string $email,
        string $hashedPassword,
        ?string $firstname = null,
        ?string $lastname = null
    ): self {
        return new self(
            new Email($email),
            $hashedPassword,
            $firstname,
            $lastname
        );
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function getEmail(): Email
    {
        return $this->email;
    }

    public function changeEmail(Email $email): void
    {
        $this->email = $email;
        $this->markAsUpdated();
    }

    public function getRoles(): array
    {
        return array_unique($this->roles);
    }

    public function addRole(string $role): void
    {
        if (!in_array($role, $this->roles)) {
            $this->roles[] = $role;
            $this->markAsUpdated();
        }
    }

    public function removeRole(string $role): void
    {
        $this->roles = array_filter($this->roles, fn($r) => $r !== $role);
        $this->markAsUpdated();
    }

    public function hasRole(string $role): bool
    {
        return in_array($role, $this->roles);
    }

    public function getPassword(): string
    {
        return $this->password;
    }

    public function changePassword(string $hashedPassword): void
    {
        $this->password = $hashedPassword;
        $this->markAsUpdated();
    }

    public function getFirstname(): ?string
    {
        return $this->firstname;
    }

    public function setFirstname(?string $firstname): void
    {
        $this->firstname = $firstname;
        $this->markAsUpdated();
    }

    public function getLastname(): ?string
    {
        return $this->lastname;
    }

    public function setLastname(?string $lastname): void
    {
        $this->lastname = $lastname;
        $this->markAsUpdated();
    }

    public function getFullName(): string
    {
        return trim(($this->firstname ?? '') . ' ' . ($this->lastname ?? ''));
    }

    public function isActive(): bool
    {
        return $this->isActive;
    }

    public function activate(): void
    {
        $this->isActive = true;
        $this->markAsUpdated();
    }

    public function deactivate(): void
    {
        $this->isActive = false;
        $this->markAsUpdated();
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    private function markAsUpdated(): void
    {
        $this->updatedAt = new \DateTime();
    }
}


FICHIER: src/Domain/Repository/UserRepositoryInterface.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\Repository;

use App\Domain\ValueObject\Email;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;

/**
 * Repository Interface (Port) - Contrat du domaine
 */
interface UserRepositoryInterface
{
    public function save(UserEntity $user): void;

    public function delete(UserEntity $user): void;

    public function findById(int $id): ?UserEntity;

    public function findByEmail(Email $email): ?UserEntity;

    /**
     * @return UserEntity[]
     */
    public function findAll(): array;

    /**
     * @return UserEntity[]
     */
    public function findActiveUsers(): array;

    /**
     * @return UserEntity[]
     */
    public function findByRole(string $role): array;

    /**
     * @return UserEntity[]
     */
    public function search(string $searchTerm): array;

    public function countActiveUsers(): int;

    public function existsByEmail(Email $email): bool;
}



FICHIER: src/Domain/ValueObject/Email.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\ValueObject;

/**
 * Value Object Email
 */
class Email
{
    private string $value;

    public function __construct(string $email)
    {
        $this->validate($email);
        $this->value = strtolower($email);
    }

    private function validate(string $email): void
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \InvalidArgumentException(sprintf('"%s" is not a valid email', $email));
        }
    }

    public function getValue(): string
    {
        return $this->value;
    }

    public function __toString(): string
    {
        return $this->value;
    }

    public function equals(Email $other): bool
    {
        return $this->value === $other->value;
    }
}


FICHIER: src/Domain/ValueObject/UserRole.php
--------------------------------------------------------------------------------
<?php
namespace App\Domain\ValueObject;

class UserRole
{
    public const ROLE_USER = 'ROLE_USER';
    public const ROLE_ADMIN = 'ROLE_ADMIN';
    public const ROLE_MODERATOR = 'ROLE_MODERATOR';

    private const VALID_ROLES = [
        self::ROLE_USER,
        self::ROLE_ADMIN,
        self::ROLE_MODERATOR,
    ];

    public static function isValid(string $role): bool
    {
        return in_array($role, self::VALID_ROLES);
    }

    public static function validate(string $role): void
    {
        if (!self::isValid($role)) {
            throw new \InvalidArgumentException(sprintf('Invalid role: %s', $role));
        }
    }
}


FICHIER: src/Infrastructure/Console/Command/ClearExpiredRefreshTokensCommand.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Console/Command/ClearExpiredRefreshTokensCommand.php

namespace App\Infrastructure\Console\Command;

use App\Infrastructure\Persistence\Doctrine\Repository\RefreshTokenRepository;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

#[AsCommand(
    name: 'app:clear-expired-refresh-tokens',
    description: 'Supprime les refresh tokens expirÃ©s'
)]
class ClearExpiredRefreshTokensCommand extends Command
{
    public function __construct(
        private readonly RefreshTokenRepository $refreshTokenRepository
    ) {
        parent::__construct();
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $deleted = $this->refreshTokenRepository->deleteExpired();
        $output->writeln(sprintf('%d refresh tokens expirÃ©s supprimÃ©s.', $deleted));

        return Command::SUCCESS;
    }
}



FICHIER: src/Infrastructure/Http/Controller/AccountController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Security\Http\Attribute\CurrentUser;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;

#[Route('/api/account')]
#[OA\Tag(name: 'account')]
class AccountController extends AbstractController
{
    private const PHOTO_UPLOAD_DIR = '/upload/photos';
    private const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    private const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    public function __construct(
        private readonly UserRepository $userRepository,
        private readonly SerializerInterface $serializer,
        private readonly ValidatorInterface $validator,
        private readonly string $projectDir,
    ) {}

    #[Route('/me', name: 'account_get_me', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les informations du compte',
        responses: [
            new OA\Response(
                response: 200,
                description: 'Informations du compte',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'string'),
                        new OA\Property(property: 'displayName', type: 'string', nullable: true),
                        new OA\Property(property: 'gender', type: 'integer', nullable: true),
                        new OA\Property(property: 'birthdate', type: 'string', format: 'date', nullable: true),
                        new OA\Property(property: 'about_me', type: 'string', nullable: true),
                        new OA\Property(property: 'has_photo', type: 'boolean'),
                        new OA\Property(property: 'first_access', type: 'boolean'),
                        new OA\Property(property: 'photo_url', type: 'string', nullable: true),
                    ]
                )
            )
        ]
    )]
    public function getMe(#[CurrentUser] UserEntity $user): JsonResponse
    {
        // SÃ©curitÃ© : s'assurer que hasPhoto est initialisÃ©
        $hasPhoto = false;
        try {
            $hasPhoto = $user->hasPhoto();
        } catch (\Error $e) {
            $hasPhoto = false;
        }

        $firstAccess = false;
        try {
            $firstAccess = $user->isFirstAccess();
        } catch (\Error $e) {
            $firstAccess = false;
        }

        // Si c'est la premiÃ¨re fois qu'on accÃ¨de Ã  /account/me, mettre first_access Ã  false
        if ($firstAccess) {
            $user->setFirstAccess(false);
            $this->userRepository->save($user);
        }

        // Construire l'URL de la photo si elle existe
        $photoUrl = null;
        if ($hasPhoto) {
            // On suppose que la photo est en jpg, mais on pourrait dÃ©tecter l'extension rÃ©elle
            $photoUrl = '/api/photo/' . $user->getAuthUid() . '.jpg';
        }

        return $this->json([
            'id' => $user->getEmail() ?? $user->getAuthUid(),
            'displayName' => $user->getDisplayName() ?? $user->getUsername(),
            'gender' => $user->getGender(),
            'birthdate' => $user->getBirthdate()?->format('Y-m-d'),
            'about_me' => $user->getAboutMe(),
            'has_photo' => $hasPhoto,
            'first_access' => $firstAccess,
            'photo_url' => $photoUrl,
        ]);
    }

    #[Route('/me', name: 'account_update_me', methods: ['PUT'])]
    #[OA\Put(
        summary: 'Met Ã  jour les informations du compte',
        requestBody: new OA\RequestBody(
            content: new OA\JsonContent(
                properties: [
                    new OA\Property(property: 'displayName', type: 'string', nullable: true),
                    new OA\Property(property: 'gender', type: 'integer', nullable: true),
                    new OA\Property(property: 'birthdate', type: 'string', format: 'date', nullable: true),
                ]
            )
        )
    )]
    public function updateMe(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (isset($data['displayName'])) {
            $user->setDisplayName($data['displayName']);
        }

        if (isset($data['gender'])) {
            $user->setGender((int) $data['gender']);
        }

        if (isset($data['birthdate'])) {
            try {
                $user->setBirthdate(new \DateTime($data['birthdate']));
            } catch (\Exception $e) {
                return $this->json(['error' => 'Format de date invalide'], Response::HTTP_BAD_REQUEST);
            }
        }

        $errors = $this->validator->validate($user);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->userRepository->save($user);

        return $this->json(['success' => true]);
    }

    #[Route('/about-me', name: 'account_get_about_me', methods: ['GET'])]
    public function getAboutMe(#[CurrentUser] UserEntity $user): JsonResponse
    {
        return $this->json([
            'about_me' => $user->getAboutMe(),
        ]);
    }

    #[Route('/about-me', name: 'account_update_about_me', methods: ['PUT'])]
    public function updateAboutMe(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (isset($data['about_me'])) {
            $user->setAboutMe($data['about_me']);
            $this->userRepository->save($user);
        }

        return $this->json(['success' => true]);
    }

    #[Route('/photo', name: 'account_get_photo', methods: ['GET'])]
    public function getPhoto(#[CurrentUser] UserEntity $user): JsonResponse
    {
        $photoUrl = null;

        if ($user->hasPhoto()) {
            // Construire l'URL de la photo
            $photoUrl = '/uploads/photos/' . $user->getAuthUid() . '.jpg';
        }

        return $this->json([
            'photo_url' => $photoUrl,
            'has_photo' => $user->hasPhoto(),
        ]);
    }

    #[Route('/photo', name: 'account_delete_photo', methods: ['DELETE'])]
    public function deletePhoto(#[CurrentUser] UserEntity $user): JsonResponse
    {
        if (!$user->hasPhoto()) {
            return $this->json(['error' => 'Aucune photo Ã  supprimer'], Response::HTTP_BAD_REQUEST);
        }

        try {
            $this->deleteOldPhoto($user);
            $user->updatePhotoStatus(false);
            $this->userRepository->save($user);

            return $this->json([
                'success' => true,
                'message' => 'Photo supprimÃ©e avec succÃ¨s'
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Erreur lors de la suppression: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Valide le fichier photo
     */
    private function validatePhoto(UploadedFile $file): bool
    {
        // VÃ©rifier la taille
        if ($file->getSize() > self::MAX_FILE_SIZE) {
            return false;
        }

        // VÃ©rifier le type MIME
        $mimeType = $file->getMimeType();
        if (!in_array($mimeType, self::ALLOWED_MIME_TYPES)) {
            return false;
        }

        return true;
    }

    /**
     * Supprime l'ancienne photo
     */
    private function deleteOldPhoto(UserEntity $user): void
    {
        $uploadDir = $this->projectDir . self::PHOTO_UPLOAD_DIR;

        // Chercher tous les fichiers commenÃ§ant par l'auth_uid
        $pattern = $uploadDir . '/' . $user->getAuthUid() . '.*';
        $oldFiles = glob($pattern);

        foreach ($oldFiles as $file) {
            if (is_file($file)) {
                unlink($file);
            }
        }
    }

    #[Route('/photo', name: 'account_update_photo', methods: ['PUT'])]
    public function updatePhoto(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        /** @var UploadedFile|null $photo */
        $photo = $request->files->get('photo');

        if (!$photo) {
            return $this->json(['error' => 'Aucune photo fournie'], Response::HTTP_BAD_REQUEST);
        }

        // Validation du fichier
        if (!$this->validatePhoto($photo)) {
            return $this->json([
                'error' => 'Format de fichier invalide. Types acceptÃ©s: JPEG, PNG, GIF, WEBP. Taille max: 5MB'
            ], Response::HTTP_BAD_REQUEST);
        }

        try {
            // CrÃ©er le dossier d'upload s'il n'existe pas
            $uploadDir = $this->projectDir . self::PHOTO_UPLOAD_DIR;
            if (!is_dir($uploadDir)) {
                mkdir($uploadDir, 0755, true);
            }

            // GÃ©nÃ©rer un nom de fichier basÃ© sur l'auth_uid
            $extension = $photo->guessExtension() ?? 'jpg';
            $filename = $user->getAuthUid() . '.' . $extension;
            $filepath = $uploadDir . '/' . $filename;

            // Supprimer l'ancienne photo si elle existe
            if ($user->hasPhoto()) {
                $this->deleteOldPhoto($user);
            }

            // DÃ©placer le fichier
            $photo->move($uploadDir, $filename);

            // Mettre Ã  jour le statut has_photo
            $user->updatePhotoStatus(true);
            $this->userRepository->save($user);

            // Construire l'URL de la photo via notre nouveau controller
            $photoUrl = '/api/photo/' . $filename;

            return $this->json([
                'success' => true,
                'photo_url' => $photoUrl,
                'has_photo' => true,
                'message' => 'Photo tÃ©lÃ©chargÃ©e avec succÃ¨s'
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Erreur lors du tÃ©lÃ©chargement: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}



FICHIER: src/Infrastructure/Http/Controller/AuthController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use OpenApi\Attributes as OA;

#[OA\Tag(name: 'auth')]
class AuthController extends AbstractController
{
    public function __construct(
        private UserPasswordHasherInterface $passwordHasher
    ) {}

    #[Route('/api/auth/login', name: 'api_auth_login', methods: ['POST'])]
    #[OA\Post(
        summary: 'Authentifie un utilisateur et renvoie un JWT',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                type: 'object',
                required: ['email', 'password'],
                properties: [
                    new OA\Property(property: 'email', type: 'string', example: 'user@example.com'),
                    new OA\Property(property: 'password', type: 'string', example: 'MonMotDePasse123!')
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Token JWT renvoyÃ©',
                content: new OA\JsonContent(
                    type: 'object',
                    properties: [
                        new OA\Property(property: 'token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIsInR5...')
                    ]
                )
            ),
            new OA\Response(response: 401, description: 'Identifiants invalides')
        ]
    )]
    public function login(): void
    {
        // Lexik gÃ¨re la logique, on ne met rien ici
    }

    #[Route('/api/auth/generate-password', name: 'api_auth_generate_password', methods: ['POST'])]
    #[OA\Post(
        summary: 'Hash un mot de passe en clair (utile pour tests ou crÃ©ation manuelle dâ€™utilisateurs).',
        requestBody: new OA\RequestBody(
            required: true,
            description: 'Mot de passe Ã  chiffrer',
            content: new OA\JsonContent(
                type: 'object',
                required: ['password'],
                properties: [
                    new OA\Property(property: 'password', type: 'string', example: 'MonMotDePasse123!')
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Mot de passe chiffrÃ© renvoyÃ© avec succÃ¨s',
                content: new OA\JsonContent(
                    type: 'object',
                    properties: [
                        new OA\Property(property: 'hash', type: 'string', example: '$2y$13$abc123...')
                    ]
                )
            )
        ]
    )]
    public function generatePassword(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        if (!isset($data['password']) || !is_string($data['password']) || $data['password'] === '') {
            return $this->json(['error' => 'Le champ "password" est requis.'], 400);
        }

        $plain = $data['password'];

        if (strlen($plain) < 8) {
            return $this->json(['error' => 'Le mot de passe doit faire au moins 8 caractÃ¨res.'], 400);
        }

        // Fake user conforme Ã  lâ€™interface PasswordAuthenticatedUserInterface
        $user = new class implements PasswordAuthenticatedUserInterface {
            public function getPassword(): ?string { return null; }
        };

        $hash = $this->passwordHasher->hashPassword($user, $plain);

        return $this->json(['hash' => $hash]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/GenerateLiveKitController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Agence104\LiveKit\AccessToken;
use Agence104\LiveKit\AccessTokenOptions;
use Agence104\LiveKit\VideoGrant;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/sfu/generate-token')]
#[OA\Tag(name: 'sfu')]
class GenerateLiveKitController extends AbstractController
{
    public function __construct(
        private readonly string $livekitApiKey,
        private readonly string $livekitApiSecret,
        private readonly string $livekitUrl,
    ) {
    }

    #[Route('', name: 'sfu_generate_token', methods: ['POST'])]
    #[OA\Post(
        description: 'GÃ©nÃ¨re un token JWT pour LiveKit SFU',
        summary: 'GÃ©nÃ©rer un token d\'accÃ¨s LiveKit',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['participant_identity', 'room_name'],
                properties: [
                    new OA\Property(property: 'participant_identity', type: 'string', description: 'Identifiant unique du participant'),
                    new OA\Property(property: 'participant_name', type: 'string', description: 'Nom du participant'),
                    new OA\Property(property: 'participant_metadata', type: 'string', description: 'MÃ©tadonnÃ©es du participant'),
                    new OA\Property(property: 'participant_attributes', type: 'object', description: 'Attributs du participant'),
                    new OA\Property(property: 'room_name', type: 'string', description: 'Nom de la salle'),
                    new OA\Property(property: 'room_config', type: 'object', description: 'Configuration de la salle'),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Token gÃ©nÃ©rÃ© avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'server_url', type: 'string', example: 'wss://livekit.example.com'),
                        new OA\Property(property: 'participant_token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIs...'),
                    ]
                )
            ),
            new OA\Response(
                response: 400,
                description: 'RequÃªte invalide'
            )
        ]
    )]
    public function generateSfuToken(Request $request): JsonResponse
    {
        try {
            // DÃ©coder le corps de la requÃªte JSON
            $body = json_decode($request->getContent(), true);

            // Valider que nous avons du JSON valide
            if (json_last_error() !== JSON_ERROR_NONE) {
                return $this->json([
                    'error' => 'Invalid JSON in request body'
                ], Response::HTTP_BAD_REQUEST);
            }

            // Valider les champs requis
            if (!isset($body['participant_identity']) || !isset($body['room_name'])) {
                return $this->json([
                    'error' => 'Missing required fields: participant_identity and room_name are required'
                ], Response::HTTP_BAD_REQUEST);
            }

            // DÃ©finir les options du token
            $tokenOptions = (new AccessTokenOptions())
                ->setIdentity($body['participant_identity'])
                ->setName($body['participant_name'] ?? $body['participant_identity']);

            // Ajouter les mÃ©tadonnÃ©es si prÃ©sentes
            if (!empty($body['participant_metadata'])) {
                $tokenOptions = $tokenOptions->setMetadata($body['participant_metadata']);
            }

            // Ajouter les attributs si prÃ©sents
            if (!empty($body['participant_attributes']) && is_array($body['participant_attributes'])) {
                $tokenOptions = $tokenOptions->setAttributes($body['participant_attributes']);
            }

            // DÃ©finir les grants vidÃ©o
            $roomName = $body['room_name'];
            $videoGrant = (new VideoGrant())
                ->setRoomJoin()
                ->setRoomName($roomName);

            // CrÃ©er le token
            $token = (new AccessToken($this->livekitApiKey, $this->livekitApiSecret))
                ->init($tokenOptions)
                ->setGrant($videoGrant);

            // Ajouter la configuration de la salle si prÃ©sente
            if (!empty($body['room_config']) && is_array($body['room_config'])) {
                $token = $token->setRoomConfig($body['room_config']);
            }

            // Retourner la rÃ©ponse JSON
            return $this->json([
                'server_url' => $this->livekitUrl,
                'participant_token' => $token->toJwt(),
                'participant_identity' => $body['participant_identity'],
                'participant_name' => $body['participant_name'],
                'room_name' => $body['room_name'],
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Failed to generate token: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}



FICHIER: src/Infrastructure/Http/Controller/GeneratePromptController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Finder\Finder;

#[Route('/api/generate-prompt')]
#[OA\Tag(name: 'ia assistant', description: 'GÃ©nÃ©ration de prompts pour l\'IA')]
class GeneratePromptController extends AbstractController
{
    #[Route('', name: 'generate_prompt', methods: ['GET'])]
    #[OA\Get(
        description: 'Exporte des fichiers et dossiers au format texte brut pour analyse par IA',
        summary: 'GÃ©nÃ¨re un prompt texte contenant l\'arborescence et le code source',
        parameters: [
            new OA\Parameter(
                name: 'paths',
                description: 'Chemin des dossiers Ã  analyser (sÃ©parÃ©s par des virgules) - absolus ou relatifs Ã  la racine du projet',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    example: 'src,config,templates'
                )
            ),
            new OA\Parameter(
                name: 'files',
                description: 'Chemin des fichiers individuels Ã  analyser (sÃ©parÃ©s par des virgules) - absolus ou relatifs Ã  la racine du projet',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    example: 'src/Controller/GeneratePromptController.php,config/routes.yaml'
                )
            ),
            new OA\Parameter(
                name: 'extensions',
                description: 'Liste des extensions de fichiers Ã  inclure (sÃ©parÃ©es par des virgules)',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    default: 'php,dart,html,twig,js,css',
                    example: 'php,twig,yaml'
                )
            ),
        ]
    )]
    public function generatePrompt(Request $request): Response
    {
        $pathsParam = $request->query->get('paths');
        $filesParam = $request->query->get('files');
        $extensions = $request->query->get('extensions', 'php,dart,html,twig,js,css');

        // VÃ©rifier qu'au moins un paramÃ¨tre est fourni
        if (!$pathsParam && !$filesParam) {
            return new Response(
                "ERREUR: Vous devez fournir au moins un dossier (paths) ou un fichier (files) Ã  analyser.\n",
                Response::HTTP_BAD_REQUEST,
                ['Content-Type' => 'text/plain']
            );
        }

        $allowedExtensions = array_map('trim', explode(',', $extensions));
        $warningMessages = [];
        $allFiles = [];
        $allDirs = [];

        // Traitement des dossiers (paths)
        $resolvedPaths = [];
        if ($pathsParam) {
            $pathsParam = str_replace(" ", "", $pathsParam);
            $pathsParam = str_replace("\n", "", $pathsParam);
            $pathsParam = trim($pathsParam);
            $pathsParam = rtrim($pathsParam, ',');


            $rawPaths = array_map('trim', explode(',', $pathsParam));

            foreach ($rawPaths as $path) {
                // RÃ©soudre le chemin absolu
                if (!str_starts_with($path, '/')) {
                    $path = $this->getParameter('kernel.project_dir') . '/' . $path;
                }

                $realPath = realpath($path);

                if ($realPath && is_dir($realPath)) {
                    $resolvedPaths[] = $realPath;
                } else {
                    $warningMessages[] = "Dossier ignorÃ© (invalide): " . $path;
                }
            }

            // Collecter les fichiers des dossiers valides
            foreach ($resolvedPaths as $rootPath) {
                $finder = new Finder();
                $finder->files()
                    ->in($rootPath)
                    ->ignoreDotFiles(false)
                    ->ignoreVCS(false);

                foreach ($finder as $file) {
                    $ext = $file->getExtension();
                    if (in_array($ext, $allowedExtensions)) {
                        $allFiles[] = $file;

                        // Collecter tous les dossiers parents
                        $relativePath = $file->getRelativePath();
                        if (!empty($relativePath)) {
                            $parts = explode(DIRECTORY_SEPARATOR, $relativePath);
                            $currentPath = '';
                            foreach ($parts as $part) {
                                $currentPath = empty($currentPath) ? $part : $currentPath . DIRECTORY_SEPARATOR . $part;
                                $allDirs[$currentPath] = true;
                            }
                        }
                    }
                }
            }
        }

        // Traitement des fichiers individuels (files)
        $resolvedFiles = [];
        if ($filesParam) {

            $rawFiles = array_map('trim', explode(',', $filesParam));

            foreach ($rawFiles as $file) {
                // RÃ©soudre le chemin absolu
                if (!str_starts_with($file, '/')) {
                    $file = $this->getParameter('kernel.project_dir') . '/' . $file;
                }

                $realPath = realpath($file);

                if ($realPath && is_file($realPath)) {
                    $ext = pathinfo($realPath, PATHINFO_EXTENSION);
                    if (in_array($ext, $allowedExtensions)) {
                        $resolvedFiles[] = $realPath;

                        // CrÃ©er un objet fichier virtuel pour le traitement
                        $virtualFile = new \SplFileInfo($realPath);
                        $allFiles[] = $virtualFile;

                        // Collecter le dossier parent
                        $relativePath = str_replace($this->getParameter('kernel.project_dir') . '/', '', dirname($realPath));
                        if ($relativePath !== '.' && !empty($relativePath)) {
                            $parts = explode(DIRECTORY_SEPARATOR, $relativePath);
                            $currentPath = '';
                            foreach ($parts as $part) {
                                $currentPath = empty($currentPath) ? $part : $currentPath . DIRECTORY_SEPARATOR . $part;
                                $allDirs[$currentPath] = true;
                            }
                        }
                    } else {
                        $warningMessages[] = "Fichier ignorÃ© (extension non autorisÃ©e): " . $file;
                    }
                } else {
                    $warningMessages[] = "Fichier ignorÃ© (invalide): " . $file;
                }
            }
        }

        // VÃ©rifier qu'on a au moins un fichier Ã  analyser
        if (empty($allFiles)) {
            $errorMsg = "ERREUR: Aucun fichier valide trouvÃ©.\n";
            if (!empty($warningMessages)) {
                $errorMsg .= implode("\n", $warningMessages) . "\n";
            }
            return new Response(
                $errorMsg,
                Response::HTTP_NOT_FOUND,
                ['Content-Type' => 'text/plain']
            );
        }

        try {
            $content = $this->generateExport($allFiles, $allDirs, $resolvedPaths, $allowedExtensions);

            // Ajouter les avertissements au dÃ©but si nÃ©cessaire
            if (!empty($warningMessages)) {
                $warnings = "ATTENTIONS:\n" . implode("\n", $warningMessages) . "\n\n";
                $content = $warnings . $content;
            }

            return new Response(
                $content,
                Response::HTTP_OK,
                ['Content-Type' => 'text/plain']
            );

        } catch (\Exception $e) {
            return new Response(
                "ERREUR: " . $e->getMessage() . "\n",
                Response::HTTP_INTERNAL_SERVER_ERROR,
                ['Content-Type' => 'text/plain']
            );
        }
    }

    private function generateExport(array $allFiles, array $allDirs, array $rootPaths, array $allowedExtensions): string
    {
        $output = [];
        $projectRoot = $this->getParameter('kernel.project_dir');

        // En-tÃªte
        $output[] = "FICHIERS POUR ANALYSE";
        $output[] = "=====================";

        if (!empty($rootPaths)) {
            $output[] = "Dossiers analysÃ©s:";
            foreach ($rootPaths as $path) {
                $relativePath = str_replace($projectRoot . '/', '', $path);
                $output[] = "  - " . $relativePath;
            }
        }

        $output[] = "Extensions: " . implode(', ', $allowedExtensions);
        $output[] = "Date: " . date('Y-m-d H:i:s');
        $output[] = "";

        // Trier les fichiers par chemin
        usort($allFiles, function($a, $b) {
            return strcmp($a->getRealPath(), $b->getRealPath());
        });

        // Trier les dossiers
        $dirs = array_keys($allDirs);
        sort($dirs);

        // GÃ©nÃ©rer l'arborescence complÃ¨te
        $output[] = "ARBORESCENCE:";
        $output[] = "-------------";

        if (empty($allFiles)) {
            $output[] = "  (aucun fichier trouvÃ©)";
        } else {
            // Construire l'arbre global
            $globalTree = [];

            foreach ($allFiles as $file) {
                $fullPath = $file->getRealPath();
                $relativePath = str_replace($projectRoot . '/', '', $fullPath);
                $parts = explode('/', $relativePath);

                $current = &$globalTree;
                $lastIndex = count($parts) - 1;

                foreach ($parts as $index => $part) {
                    if ($index === $lastIndex) {
                        // C'est un fichier
                        $current[$part] = null;
                    } else {
                        // C'est un dossier
                        if (!isset($current[$part])) {
                            $current[$part] = [];
                        }
                        $current = &$current[$part];
                    }
                }
            }

            $output[] = $this->renderTree($globalTree);
        }

        $output[] = "";
        $output[] = "CONTENU DES FICHIERS";
        $output[] = "====================";
        $output[] = "";

        // Contenu de chaque fichier
        foreach ($allFiles as $file) {
            $fullPath = $file->getRealPath();
            $relativeToProject = str_replace($projectRoot . '/', '', $fullPath);

            $output[] = "FICHIER: " . $relativeToProject;
            $output[] = str_repeat("-", 80);

            $content = file_get_contents($fullPath);
            if ($content === false) {
                $output[] = "[ERREUR LECTURE]";
            } else {
                $output[] = $content;
            }

            $output[] = ""; // Ligne vide entre les fichiers
            $output[] = ""; // Une de plus pour la sÃ©paration
        }

        $output[] = "FIN";
        $output[] = "============";
        $output[] = "Total fichiers: " . count($allFiles);

        return implode("\n", $output);
    }

    private function renderTree(array $tree, string $prefix = ''): string
    {
        $output = '';
        $items = $this->sortTreeItems($tree);
        $count = count($items);
        $i = 0;

        foreach ($items as $key => $value) {
            $i++;
            $isLast = ($i === $count);
            $isDir = is_array($value);

            // Choisir le marqueur
            if ($isDir) {
                $marker = $isLast ? 'â””â”€â”€ ğŸ“ ' : 'â”œâ”€â”€ ğŸ“ ';
            } else {
                $marker = $isLast ? 'â””â”€â”€ ğŸ“„ ' : 'â”œâ”€â”€ ğŸ“„ ';
            }

            // Ajouter l'Ã©lÃ©ment courant
            $output .= $prefix . $marker . $key . ($isDir ? '/' : '') . "\n";

            // Si c'est un dossier, rendre son contenu
            if ($isDir) {
                $newPrefix = $prefix . ($isLast ? '    ' : 'â”‚   ');
                $output .= $this->renderTree($value, $newPrefix);
            }
        }

        return $output;
    }

    private function sortTreeItems(array $tree): array
    {
        // SÃ©parer les dossiers et les fichiers
        $dirs = [];
        $files = [];

        foreach ($tree as $key => $value) {
            if (is_array($value)) {
                $dirs[$key] = $value;
            } else {
                $files[$key] = $value;
            }
        }

        // Trier alphabÃ©tiquement
        ksort($dirs);
        ksort($files);

        // Fusionner (dossiers d'abord, puis fichiers)
        return array_merge($dirs, $files);
    }
}



FICHIER: src/Infrastructure/Http/Controller/LogoutController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/LogoutController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Security\RefreshTokenService;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/auth/logout', name: 'api_auth_logout', methods: ['POST'])]
#[OA\Tag(name: 'auth')]
class LogoutController extends AbstractController
{
    public function __construct(
        private readonly RefreshTokenService $refreshTokenService
    ) {}

    #[OA\Post(
        summary: 'DÃ©connecte l\'utilisateur',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                type: 'object',
                required: ['refresh_token'],
                properties: [
                    new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                ]
            )
        ),
        responses: [
            new OA\Response(response: 200, description: 'DÃ©connexion rÃ©ussie')
        ]
    )]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $refreshTokenString = $data['refresh_token'] ?? null;

        if ($refreshTokenString) {
            $this->refreshTokenService->revokeRefreshToken($refreshTokenString);
        }

        return $this->json(['message' => 'DÃ©connexion rÃ©ussie']);
    }
}



FICHIER: src/Infrastructure/Http/Controller/PhotoController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\ResponseHeaderBag;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/photo')]
class PhotoController extends AbstractController
{
    private string $uploadDir;

    public function __construct(string $projectDir)
    {
        $this->uploadDir = $projectDir . '/upload/photos';
    }

    #[Route('/{filename}', name: 'photo_get', methods: ['GET'])]
    public function getPhoto(string $filename): Response
    {
        // SÃ©curitÃ© : empÃªcher les traversÃ©es de rÃ©pertoire
        if (str_contains($filename, '..') || str_contains($filename, '/') || str_contains($filename, '\\')) {
            return new JsonResponse(['error' => 'Nom de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        // Validation du format de fichier - CORRIGÃ‰E
        // Accepte: lettres (maj/min), chiffres, tirets, underscore, points
        if (!preg_match('/^[a-zA-Z0-9_-]+\.(jpg|jpeg|png|gif|webp)$/i', $filename)) {
            return new JsonResponse([
                'error' => 'Format de fichier invalide',
                'filename' => $filename,
                'expected_format' => 'auth_uid.extension (ex: AtJbLX0UgIcpiaWCZNnc9JdLzff1.jpg)'
            ], Response::HTTP_BAD_REQUEST);
        }

        $filePath = $this->uploadDir . '/' . $filename;

        if (!file_exists($filePath)) {
            return new JsonResponse(['error' => 'Photo non trouvÃ©e'], Response::HTTP_NOT_FOUND);
        }

        // DÃ©tecter le type MIME
        $mimeType = mime_content_type($filePath);
        if (!$mimeType) {
            $extension = pathinfo($filename, PATHINFO_EXTENSION);
            $mimeType = match(strtolower($extension)) {
                'jpg', 'jpeg' => 'image/jpeg',
                'png' => 'image/png',
                'gif' => 'image/gif',
                'webp' => 'image/webp',
                default => 'application/octet-stream',
            };
        }

        // Retourner le fichier avec des en-tÃªtes de cache
        return new BinaryFileResponse($filePath, 200, [
            'Content-Type' => $mimeType,
            'Cache-Control' => 'public, max-age=31536000', // Cache d'un an
            'Access-Control-Allow-Origin' => '*', // Permettre l'accÃ¨s depuis n'importe quelle origine
        ]);
    }

    #[Route('/{filename}/download', name: 'photo_download', methods: ['GET'])]
    public function downloadPhoto(string $filename): Response
    {
        // MÃªme logique de sÃ©curitÃ©
        if (str_contains($filename, '..') || str_contains($filename, '/') || str_contains($filename, '\\')) {
            return new JsonResponse(['error' => 'Nom de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        if (!preg_match('/^[a-f0-9-]+\.(jpg|jpeg|png|gif|webp)$/i', $filename)) {
            return new JsonResponse(['error' => 'Format de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        $filePath = $this->uploadDir . '/' . $filename;

        if (!file_exists($filePath)) {
            return new JsonResponse(['error' => 'Photo non trouvÃ©e'], Response::HTTP_NOT_FOUND);
        }

        $response = new BinaryFileResponse($filePath);
        $response->setContentDisposition(
            ResponseHeaderBag::DISPOSITION_ATTACHMENT,
            $filename
        );
        $response->headers->set('Access-Control-Allow-Origin', '*');

        return $response;
    }
}



FICHIER: src/Infrastructure/Http/Controller/RefreshTokenController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/RefreshTokenController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Security\RefreshTokenService;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/auth/refresh', name: 'api_auth_refresh', methods: ['POST'])]
#[OA\Tag(name: 'auth')]
class RefreshTokenController extends AbstractController
{
    public function __construct(
        private readonly RefreshTokenService $refreshTokenService,
        private readonly JWTTokenManagerInterface $jwtManager
    ) {}

    #[OA\Post(
        summary: 'RafraÃ®chit un token JWT expirÃ©',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['refresh_token'],
                properties: [
                    new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                ],
                type: 'object'
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Nouveau token JWT et nouveau refresh token',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIsInR5...'),
                        new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                    ],
                    type: 'object'
                )
            ),
            new OA\Response(response: 401, description: 'Refresh token invalide')
        ]
    )]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

//        echo "popipopipopipopipopipopipopipopi\n";
//        print_r($data);
//        exit;

        $refreshTokenString = $data['refresh_token'] ?? null;

        if (!$refreshTokenString) {
            return $this->json(['error' => 'Refresh token requis'], Response::HTTP_BAD_REQUEST);
        }

        // Rotation du refresh token (single use)
        $newRefreshToken = $this->refreshTokenService->rotateRefreshToken($refreshTokenString);

        if (!$newRefreshToken) {
            return $this->json(['error' => 'Refresh token invalide ou expirÃ©'], Response::HTTP_UNAUTHORIZED);
        }

        // GÃ©nÃ©rer un nouveau JWT
        $user = $newRefreshToken->getUser();
        $newJwt = $this->jwtManager->create($user);

        return $this->json([
            'token' => $newJwt,
            'refresh_token' => $newRefreshToken->getRefreshToken()
        ]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/UsersGetJwtTokenFromFirebaseAuthAction.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Infrastructure\Security\RefreshTokenService;
use App\Shared\Application\Query\QueryBusInterface;
use App\Users\Application\Config\UsersAppConfig;
use App\Users\Application\DTO\UserDTO;
use App\Users\Application\Query\GetJwtForSignup\GetJwtForSignupQuery;
use App\Users\Application\Query\GetJwtFromUser\GetJwtFromUserQuery;
use App\Users\Application\Query\GetUserByFirebaseToken\GetUserByFirebaseTokenQuery;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Token\Parser;
use Lcobucci\JWT\Token\Plain;
use OpenApi\Attributes as OA;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Uid\Uuid;

#[Route('/api/users/jwt-by-firebase-token', name: 'UsersGetJwtTokenFromFirebaseAuth', methods: ['POST'])]
class UsersGetJwtTokenFromFirebaseAuthAction
{
    public function __construct(
        private readonly QueryBusInterface $queryBus,
        private readonly RefreshTokenService $refreshTokenService,
        private readonly UserRepository $userRepository,
        private readonly UserPasswordHasherInterface $passwordHasher
    ) {
    }

    #[OA\Tag(name: 'users')]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $token = $data['token'];

        /** @var UserDTO $userDTO */
        $userDTO = $this->queryBus->execute(new GetUserByFirebaseTokenQuery($token));

        if ($userDTO->status >= 20) {
            $message = '';
            switch($userDTO->status) {
                case UsersAppConfig::$USER_UNSUBSCRIBED:
                    $message = 'Vous Ãªtes dÃ©sinscrit(e).';
                    break;
                case UsersAppConfig::$USER_BANNED:
                    $message = 'Vous avez Ã©tÃ© banni(e).';
                    break;
                case UsersAppConfig::$USER_BLOCKED:
                    $message = 'Vous avez Ã©tÃ© bloquÃ©(e).';
                    break;
            }

            return new JsonResponse(['message' => json_encode([
                "code" => UsersAppConfig::$ERREUR_USER,
                "title" => "Erreur",
                "message" => $message."\n\nSupport: contact@playwinher.com",
            ])], Response::HTTP_FORBIDDEN);
        } else {
            $refreshToken = null;
            $userEntity = null;

            if ('' == $userDTO->email) {
                // Nouvel utilisateur - le crÃ©er Ã  partir du token Firebase
                $userEntity = $this->createUserFromFirebaseToken($token);

                // Sauvegarder l'utilisateur
                $this->userRepository->getEntityManager()->persist($userEntity);
                $this->userRepository->getEntityManager()->flush();

                // Re-crÃ©er le UserDTO avec les nouvelles informations
                $userDTO = UserDTO::fromEntity($userEntity);

                // GÃ©nÃ©rer le JWT pour le nouvel utilisateur
                $jwtToken = $this->queryBus->execute(new GetJwtFromUserQuery($userDTO));
            } else {
                // Utilisateur existant - gÃ©nÃ©rer JWT normal
                $jwtToken = $this->queryBus->execute(new GetJwtFromUserQuery($userDTO));

                // RÃ©cupÃ©rer l'entitÃ© utilisateur pour gÃ©nÃ©rer le refresh token
                $userEntity = $this->getUserEntityByAuthUid($userDTO->authUid);
            }

            // GÃ©nÃ©rer le refresh token si on a une entitÃ© utilisateur
            if ($userEntity) {
                // RÃ©voquer tous les anciens refresh tokens (single session)
                $this->refreshTokenService->revokeAllUserTokens($userEntity);

                // CrÃ©er un nouveau refresh token
                $refreshTokenEntity = $this->refreshTokenService->createRefreshToken($userEntity);
                $refreshToken = $refreshTokenEntity->getRefreshToken();
            }

            $response = [
                'token' => $jwtToken,
                'found' => ('' != $userDTO->email),
                'auth_uid' => $userDTO->authUid,
            ];

            // Ajouter le refresh token
            if ($refreshToken) {
                $response['refresh_token'] = $refreshToken;
            }

            return new JsonResponse($response);
        }
    }

    /**
     * CrÃ©e un nouvel utilisateur Ã  partir du token Firebase
     */
    private function createUserFromFirebaseToken(string $firebaseToken): UserEntity
    {
        // Parser le token Firebase pour extraire les informations
        $parser = new Parser(new JoseEncoder());
        /** @var Plain $token */
        $token = $parser->parse($firebaseToken);

        // RÃ©cupÃ©rer les claims
        $claims = $token->claims();

        // Extraire l'email et le sub (auth_uid)
        $email = $claims->get('email');
        $authUid = $claims->get('sub');

        // Essayer de rÃ©cupÃ©rer le nom depuis Firebase
        $name = $claims->get('name', null); // Firebase peut fournir un champ 'name'

        if (!$email || !$authUid) {
            throw new \Exception('Email ou sub manquant dans le token Firebase');
        }

        // CrÃ©er la nouvelle entitÃ©
        $userEntity = new UserEntity();

        // GÃ©nÃ©rer un UID unique pour l'utilisateur
        $userEntity->setUid(Uuid::v4()->toString());
        $userEntity->setAuthUid($authUid);
        $userEntity->setEmail($email);
        $userEntity->setUsername($email); // Garder username pour compatibilitÃ©
        $userEntity->setDisplayName($name ?? $email); // Utiliser le nom Firebase ou fallback sur email
        $userEntity->setAboutMe('');
        $userEntity->setGender(0);
        $userEntity->setBirthdate(new \DateTime('today'));
        $userEntity->setStatus(0);
        $userEntity->setRoles(['ROLE_USER']);

        // Hasher le mot de passe alÃ©atoire
        $randomPassword = bin2hex(random_bytes(16));
        $hashedPassword = $this->passwordHasher->hashPassword($userEntity, $randomPassword);
        $userEntity->setPassword($hashedPassword);

        // DÃ©finir la date de crÃ©ation (sera aussi gÃ©rÃ©e par le PrePersist)
        $userEntity->setCreatedAt(new \DateTime());

        return $userEntity;
    }

    /**
     * MÃ©thode utilitaire pour rÃ©cupÃ©rer l'entitÃ© User Ã  partir de l'authUid
     */
    private function getUserEntityByAuthUid(string $authUid): ?UserEntity
    {
        return $this->userRepository->findOneBy(['authUid' => $authUid]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/VenueController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/VenueController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\VenueEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\VenueRepository;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;
use Symfony\Component\Uid\Uuid;

#[Route('/api/venue')]
#[OA\Tag(name: 'venue')]
class VenueController extends AbstractController
{
    public function __construct(
        private readonly VenueRepository $venueRepository,
        private readonly SerializerInterface $serializer,
        private readonly ValidatorInterface $validator,
    ) {}

    #[Route('/list', name: 'venue_list', methods: ['GET'])]
    #[OA\Get(
        summary: 'Liste des venues avec pagination',
        parameters: [
            new OA\Parameter(
                name: 'page',
                in: 'query',
                description: 'NumÃ©ro de page',
                schema: new OA\Schema(type: 'integer', default: 1)
            ),
            new OA\Parameter(
                name: 'limit',
                in: 'query',
                description: 'Nombre d\'Ã©lÃ©ments par page',
                schema: new OA\Schema(type: 'integer', default: 20, maximum: 100)
            ),
            new OA\Parameter(
                name: 'search',
                in: 'query',
                description: 'Terme de recherche (nom ou description)',
                schema: new OA\Schema(type: 'string')
            ),
            new OA\Parameter(
                name: 'type',
                in: 'query',
                description: 'Filtre par type',
                schema: new OA\Schema(type: 'integer')
            ),
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Liste paginÃ©e des venues',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'items', type: 'array', items: new OA\Items(
                            properties: [
                                new OA\Property(property: 'id', type: 'integer'),
                                new OA\Property(property: 'uuid', type: 'string'),
                                new OA\Property(property: 'name', type: 'string'),
                                new OA\Property(property: 'description', type: 'string', nullable: true),
                                new OA\Property(property: 'type', type: 'integer', nullable: true),
                                new OA\Property(property: 'rank', type: 'integer', nullable: true),
                            ]
                        )),
                        new OA\Property(property: 'total', type: 'integer'),
                        new OA\Property(property: 'page', type: 'integer'),
                        new OA\Property(property: 'limit', type: 'integer'),
                        new OA\Property(property: 'pages', type: 'integer'),
                    ]
                )
            )
        ]
    )]
    public function list(Request $request): JsonResponse
    {
        $page = max(1, (int) $request->query->get('page', 1));
        $limit = min(100, max(1, (int) $request->query->get('limit', 20)));
        $search = $request->query->get('search');
        $type = $request->query->has('type') ? (int) $request->query->get('type') : null;

        $result = $this->venueRepository->findPaginated($page, $limit, $search, $type);

        // Formater les donnÃ©es pour la rÃ©ponse
        $items = array_map(function (VenueEntity $venue) {
            return [
                'id' => $venue->getId(),
                'uuid' => $venue->getUuid(),
                'name' => $venue->getName(),
                'description' => $venue->getDescription(),
                'type' => $venue->getType(),
                'rank' => $venue->getRank(),
            ];
        }, $result['items']);

        return $this->json([
            'items' => $items,
            'total' => $result['total'],
            'page' => $result['page'],
            'limit' => $result['limit'],
            'pages' => $result['pages'],
        ]);
    }

    #[Route('/{uuid}', name: 'venue_get', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re un venue par son UUID',
        parameters: [
            new OA\Parameter(
                name: 'uuid',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'string')
            )
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Venue trouvÃ©',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'integer'),
                        new OA\Property(property: 'uuid', type: 'string'),
                        new OA\Property(property: 'name', type: 'string'),
                        new OA\Property(property: 'description', type: 'string', nullable: true),
                        new OA\Property(property: 'type', type: 'integer', nullable: true),
                        new OA\Property(property: 'rank', type: 'integer', nullable: true),
                    ]
                )
            ),
            new OA\Response(response: 404, description: 'Venue non trouvÃ©')
        ]
    )]
    public function get(string $uuid): JsonResponse
    {
        $venue = $this->venueRepository->findByUuid($uuid);

        if (!$venue) {
            return $this->json(['error' => 'Venue non trouvÃ©'], Response::HTTP_NOT_FOUND);
        }

        return $this->json([
            'id' => $venue->getId(),
            'uuid' => $venue->getUuid(),
            'name' => $venue->getName(),
            'description' => $venue->getDescription(),
            'type' => $venue->getType(),
            'rank' => $venue->getRank(),
        ]);
    }

    #[Route('', name: 'venue_create', methods: ['POST'])]
    #[OA\Post(
        summary: 'CrÃ©e un nouveau venue',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['name'],
                properties: [
                    new OA\Property(property: 'name', type: 'string', maxLength: 50),
                    new OA\Property(property: 'description', type: 'string', maxLength: 200, nullable: true),
                    new OA\Property(property: 'type', type: 'integer', nullable: true),
                    new OA\Property(property: 'rank', type: 'integer', nullable: true),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 201,
                description: 'Venue crÃ©Ã© avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'integer'),
                        new OA\Property(property: 'uuid', type: 'string'),
                        new OA\Property(property: 'name', type: 'string'),
                        new OA\Property(property: 'description', type: 'string', nullable: true),
                        new OA\Property(property: 'type', type: 'integer', nullable: true),
                        new OA\Property(property: 'rank', type: 'integer', nullable: true),
                    ]
                )
            ),
            new OA\Response(response: 400, description: 'DonnÃ©es invalides')
        ]
    )]
    public function create(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (!isset($data['name']) || empty($data['name'])) {
            return $this->json(['error' => 'Le nom est requis'], Response::HTTP_BAD_REQUEST);
        }

        $venue = new VenueEntity();
        $venue->setUuid(Uuid::v4()->toString());
        $venue->setName($data['name']);
        $venue->setDescription($data['description'] ?? null);
        $venue->setType($data['type'] ?? null);
        $venue->setRank($data['rank'] ?? null);

        $errors = $this->validator->validate($venue);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->venueRepository->save($venue);

        return $this->json([
            'id' => $venue->getId(),
            'uuid' => $venue->getUuid(),
            'name' => $venue->getName(),
            'description' => $venue->getDescription(),
            'type' => $venue->getType(),
            'rank' => $venue->getRank(),
        ], Response::HTTP_CREATED);
    }

    #[Route('/{uuid}', name: 'venue_update', methods: ['PUT'])]
    #[OA\Put(
        summary: 'Met Ã  jour un venue existant',
        parameters: [
            new OA\Parameter(
                name: 'uuid',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'string')
            )
        ],
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                properties: [
                    new OA\Property(property: 'name', type: 'string', maxLength: 50),
                    new OA\Property(property: 'description', type: 'string', maxLength: 200, nullable: true),
                    new OA\Property(property: 'type', type: 'integer', nullable: true),
                    new OA\Property(property: 'rank', type: 'integer', nullable: true),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Venue mis Ã  jour avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'integer'),
                        new OA\Property(property: 'uuid', type: 'string'),
                        new OA\Property(property: 'name', type: 'string'),
                        new OA\Property(property: 'description', type: 'string', nullable: true),
                        new OA\Property(property: 'type', type: 'integer', nullable: true),
                        new OA\Property(property: 'rank', type: 'integer', nullable: true),
                    ]
                )
            ),
            new OA\Response(response: 404, description: 'Venue non trouvÃ©'),
            new OA\Response(response: 400, description: 'DonnÃ©es invalides')
        ]
    )]
    public function update(string $uuid, Request $request): JsonResponse
    {
        $venue = $this->venueRepository->findByUuid($uuid);

        if (!$venue) {
            return $this->json(['error' => 'Venue non trouvÃ©'], Response::HTTP_NOT_FOUND);
        }

        $data = json_decode($request->getContent(), true);

        if (isset($data['name']) && !empty($data['name'])) {
            $venue->setName($data['name']);
        }

        if (array_key_exists('description', $data)) {
            $venue->setDescription($data['description']);
        }

        if (array_key_exists('type', $data)) {
            $venue->setType($data['type'] !== null ? (int) $data['type'] : null);
        }

        if (array_key_exists('rank', $data)) {
            $venue->setRank($data['rank'] !== null ? (int) $data['rank'] : null);
        }

        $errors = $this->validator->validate($venue);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->venueRepository->save($venue);

        return $this->json([
            'id' => $venue->getId(),
            'uuid' => $venue->getUuid(),
            'name' => $venue->getName(),
            'description' => $venue->getDescription(),
            'type' => $venue->getType(),
            'rank' => $venue->getRank(),
        ]);
    }

    #[Route('/{uuid}', name: 'venue_delete', methods: ['DELETE'])]
    #[OA\Delete(
        summary: 'Supprime un venue',
        parameters: [
            new OA\Parameter(
                name: 'uuid',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'string')
            )
        ],
        responses: [
            new OA\Response(response: 204, description: 'Venue supprimÃ© avec succÃ¨s'),
            new OA\Response(response: 404, description: 'Venue non trouvÃ©')
        ]
    )]
    public function delete(string $uuid): JsonResponse
    {
        $venue = $this->venueRepository->findByUuid($uuid);

        if (!$venue) {
            return $this->json(['error' => 'Venue non trouvÃ©'], Response::HTTP_NOT_FOUND);
        }

        $this->venueRepository->delete($venue);

        return $this->json(null, Response::HTTP_NO_CONTENT);
    }

    #[Route('/type/{type}', name: 'venue_by_type', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les venues par type',
        parameters: [
            new OA\Parameter(
                name: 'type',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'integer')
            )
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Liste des venues du type spÃ©cifiÃ©',
                content: new OA\JsonContent(
                    type: 'array',
                    items: new OA\Items(
                        properties: [
                            new OA\Property(property: 'id', type: 'integer'),
                            new OA\Property(property: 'uuid', type: 'string'),
                            new OA\Property(property: 'name', type: 'string'),
                            new OA\Property(property: 'description', type: 'string', nullable: true),
                            new OA\Property(property: 'type', type: 'integer', nullable: true),
                            new OA\Property(property: 'rank', type: 'integer', nullable: true),
                        ]
                    )
                )
            )
        ]
    )]
    public function getByType(int $type): JsonResponse
    {
        $venues = $this->venueRepository->findByType($type);

        $items = array_map(function (VenueEntity $venue) {
            return [
                'id' => $venue->getId(),
                'uuid' => $venue->getUuid(),
                'name' => $venue->getName(),
                'description' => $venue->getDescription(),
                'type' => $venue->getType(),
                'rank' => $venue->getRank(),
            ];
        }, $venues);

        return $this->json($items);
    }

    #[Route('/top/{limit}', name: 'venue_top', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les venues les mieux classÃ©es',
        parameters: [
            new OA\Parameter(
                name: 'limit',
                in: 'path',
                description: 'Nombre maximum de venues Ã  retourner',
                schema: new OA\Schema(type: 'integer', default: 10)
            )
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Liste des meilleurs venues',
                content: new OA\JsonContent(
                    type: 'array',
                    items: new OA\Items(
                        properties: [
                            new OA\Property(property: 'id', type: 'integer'),
                            new OA\Property(property: 'uuid', type: 'string'),
                            new OA\Property(property: 'name', type: 'string'),
                            new OA\Property(property: 'description', type: 'string', nullable: true),
                            new OA\Property(property: 'type', type: 'integer', nullable: true),
                            new OA\Property(property: 'rank', type: 'integer', nullable: true),
                        ]
                    )
                )
            )
        ]
    )]
    public function getTop(int $limit = 10): JsonResponse
    {
        $limit = min(50, max(1, $limit));
        $venues = $this->venueRepository->findTopRated($limit);

        $items = array_map(function (VenueEntity $venue) {
            return [
                'id' => $venue->getId(),
                'uuid' => $venue->getUuid(),
                'name' => $venue->getName(),
                'description' => $venue->getDescription(),
                'type' => $venue->getType(),
                'rank' => $venue->getRank(),
            ];
        }, $venues);

        return $this->json($items);
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/RefreshTokenEntity.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Entity/RefreshTokenEntity.php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
#[ORM\Table(name: 'refresh_tokens')]
#[ORM\HasLifecycleCallbacks]
class RefreshTokenEntity
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 128, unique: true)]
    private string $refreshToken;

    #[ORM\ManyToOne(targetEntity: UserEntity::class)]
    #[ORM\JoinColumn(nullable: false)]
    private UserEntity $user;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $valid;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(type: 'boolean')]
    private bool $revoked = false;

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        $this->createdAt = new \DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getRefreshToken(): string
    {
        return $this->refreshToken;
    }

    public function setRefreshToken(string $refreshToken): self
    {
        $this->refreshToken = $refreshToken;
        return $this;
    }

    public function getUser(): UserEntity
    {
        return $this->user;
    }

    public function setUser(UserEntity $user): self
    {
        $this->user = $user;
        return $this;
    }

    public function getValid(): \DateTimeInterface
    {
        return $this->valid;
    }

    public function setValid(\DateTimeInterface $valid): self
    {
        $this->valid = $valid;
        return $this;
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function isRevoked(): bool
    {
        return $this->revoked;
    }

    public function setRevoked(bool $revoked): self
    {
        $this->revoked = $revoked;
        return $this;
    }

    public function isValid(): bool
    {
        return !$this->revoked && $this->valid > new \DateTime();
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/UserEntity.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;

/**
 * Infrastructure Entity - Mapping Doctrine uniquement
 * Sert d'adapter entre le domaine et la base de donnÃ©es
 */
#[ORM\Entity]
#[ORM\Table(name: '`user`')]
#[ORM\HasLifecycleCallbacks]
class UserEntity implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $uid = null;

    #[ORM\Column(name: 'auth_uid', type: 'string', length: 100, nullable: true)]
    private ?string $authUid = null;

    #[ORM\Column(type: 'json')]
    private array $roles = [];

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $email = null;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $username = null;

    // Champ displayName
    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $displayName = null;

    #[ORM\Column(type: 'string', length: 255)]
    private string $password;

    #[ORM\Column(name: 'about_me', type: 'text', nullable: true)]
    private ?string $aboutMe = null;

    #[ORM\Column(type: 'integer', nullable: true)]
    private ?int $gender = null;

    #[ORM\Column(type: 'date', nullable: true)]
    private ?\DateTime $birthdate = null;

    #[ORM\Column(type: 'integer', options: ['default' => 1])]
    private int $status = 1;

    #[ORM\Column(name: 'has_photo', type: 'boolean', options: ['default' => false])]
    private bool $hasPhoto = false;
    #[ORM\Column(name: 'first_access', type: 'boolean', options: ['default' => true])]
    private bool $firstAccess = true;

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime', nullable: true)]
    private ?\DateTimeInterface $updatedAt = null;

    /**
     * Constructeur avec initialisation de toutes les propriÃ©tÃ©s
     */
    public function __construct()
    {
        $this->hasPhoto = false;
        $this->createdAt = new \DateTime();
    }

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        if ($this->createdAt === null) {
            $this->createdAt = new \DateTime();
        }
    }

    #[ORM\PreUpdate]
    public function setUpdatedAtValue(): void
    {
        $this->updatedAt = new \DateTime();
    }

    // Getters and Setters
    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(?int $id): void
    {
        $this->id = $id;
    }

    public function getUid(): ?string
    {
        return $this->uid;
    }

    public function setUid(?string $uid): void
    {
        $this->uid = $uid;
    }

    public function getAuthUid(): ?string
    {
        return $this->authUid;
    }

    public function setAuthUid(?string $authUid): void
    {
        $this->authUid = $authUid;
    }

    public function getEmail(): ?string
    {
        return $this->email;
    }

    public function setEmail(?string $email): void
    {
        $this->email = $email;
    }

    public function getUsername(): ?string
    {
        return $this->username;
    }

    public function setUsername(?string $username): void
    {
        $this->username = $username;
    }

    public function getDisplayName(): ?string
    {
        return $this->displayName;
    }

    public function setDisplayName(?string $displayName): void
    {
        $this->displayName = $displayName;
    }

    public function getAboutMe(): ?string
    {
        return $this->aboutMe;
    }

    public function setAboutMe(?string $aboutMe): void
    {
        $this->aboutMe = $aboutMe;
    }

    public function getGender(): ?int
    {
        return $this->gender;
    }

    public function setGender(?int $gender): void
    {
        $this->gender = $gender;
    }

    public function getBirthdate(): ?\DateTime
    {
        return $this->birthdate;
    }

    public function setBirthdate(?\DateTime $birthdate): void
    {
        $this->birthdate = $birthdate;
    }

    public function getStatus(): int
    {
        return $this->status;
    }

    public function setStatus(int $status): void
    {
        $this->status = $status;
    }

    // Getter/Setter pour hasPhoto
    public function hasPhoto(): bool
    {
        return $this->hasPhoto;
    }

    public function setHasPhoto(bool $hasPhoto): self
    {
        $this->hasPhoto = $hasPhoto;
        return $this;
    }

    public function isFirstAccess(): bool
    {
        return $this->firstAccess;
    }

    public function setFirstAccess(bool $firstAccess): void
    {
        $this->firstAccess = $firstAccess;
    }


    // MÃ©thode utilitaire pour mettre Ã  jour le statut photo
    public function updatePhotoStatus(bool $hasPhoto): void
    {
        $this->hasPhoto = $hasPhoto;
        $this->updatedAt = new \DateTime();
    }

    public function getUserIdentifier(): string
    {
        return $this->email ?? '';
    }

    public function getRoles(): array
    {
        $roles = $this->roles;
        $roles[] = 'ROLE_USER';
        return array_unique($roles);
    }

    public function setRoles(array $roles): void
    {
        $this->roles = $roles;
    }

    public function getPassword(): string
    {
        return $this->password;
    }

    public function setPassword(string $password): void
    {
        $this->password = $password;
    }

    public function eraseCredentials(): void
    {
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTimeInterface $createdAt): void
    {
        $this->createdAt = $createdAt;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    public function setUpdatedAt(?\DateTimeInterface $updatedAt): void
    {
        $this->updatedAt = $updatedAt;
    }

    /**
     * MÃ©thodes d'aide pour la compatibilitÃ© avec l'ancien nommage
     */
    public function isActive(): bool
    {
        return $this->status === 1;
    }

    public function setIsActive(bool $isActive): void
    {
        $this->status = $isActive ? 1 : 0;
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/VenueEntity.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Entity/VenueEntity.php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
#[ORM\Table(name: 'venue')]
#[ORM\HasLifecycleCallbacks]
class VenueEntity
{
    #[ORM\Id]
    #[ORM\GeneratedValue(strategy: 'AUTO')]
    #[ORM\Column(name: 'id_venue', type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 50, nullable: false)]
    private string $uuid;

    #[ORM\Column(type: 'string', length: 50, nullable: false)]
    private string $name;

    #[ORM\Column(type: 'string', length: 200, nullable: true)]
    private ?string $description = null;

    #[ORM\Column(type: 'integer', nullable: true)]
    private ?int $type = null;

    #[ORM\Column(name: '`rank`', type: 'integer', nullable: true)]
    private ?int $rank = null;

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime', nullable: true)]
    private ?\DateTimeInterface $updatedAt = null;

    public function __construct()
    {
        $this->createdAt = new \DateTime();
    }

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        if ($this->createdAt === null) {
            $this->createdAt = new \DateTime();
        }
    }

    #[ORM\PreUpdate]
    public function setUpdatedAtValue(): void
    {
        $this->updatedAt = new \DateTime();
    }

    // Getters and Setters

    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(?int $id): self
    {
        $this->id = $id;
        return $this;
    }

    public function getUuid(): string
    {
        return $this->uuid;
    }

    public function setUuid(string $uuid): self
    {
        $this->uuid = $uuid;
        return $this;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function setName(string $name): self
    {
        $this->name = $name;
        return $this;
    }

    public function getDescription(): ?string
    {
        return $this->description;
    }

    public function setDescription(?string $description): self
    {
        $this->description = $description;
        return $this;
    }

    public function getType(): ?int
    {
        return $this->type;
    }

    public function setType(?int $type): self
    {
        $this->type = $type;
        return $this;
    }

    public function getRank(): ?int
    {
        return $this->rank;
    }

    public function setRank(?int $rank): self
    {
        $this->rank = $rank;
        return $this;
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTimeInterface $createdAt): self
    {
        $this->createdAt = $createdAt;
        return $this;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    public function setUpdatedAt(?\DateTimeInterface $updatedAt): self
    {
        $this->updatedAt = $updatedAt;
        return $this;
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/RefreshTokenRepository.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Repository/RefreshTokenRepository.php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Infrastructure\Persistence\Doctrine\Entity\RefreshTokenEntity;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class RefreshTokenRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, RefreshTokenEntity::class);
    }

    public function save(RefreshTokenEntity $refreshToken): void
    {
        $this->getEntityManager()->persist($refreshToken);
        $this->getEntityManager()->flush();
    }

    public function delete(RefreshTokenEntity $refreshToken): void
    {
        $this->getEntityManager()->remove($refreshToken);
        $this->getEntityManager()->flush();
    }

    public function findByToken(string $refreshToken): ?RefreshTokenEntity
    {
        return $this->findOneBy(['refreshToken' => $refreshToken]);
    }

    public function revokeAllForUser(UserEntity $user): void
    {
        $this->createQueryBuilder('rt')
            ->update()
            ->set('rt.revoked', ':revoked')
            ->where('rt.user = :user')
            ->setParameter('revoked', true)
            ->setParameter('user', $user)
            ->getQuery()
            ->execute();
    }

    public function deleteExpired(): int
    {
        return $this->createQueryBuilder('rt')
            ->delete()
            ->where('rt.valid < :now')
            ->setParameter('now', new \DateTime())
            ->getQuery()
            ->execute();
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/UserRepository.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Domain\Entity\User;
use App\Domain\Repository\UserRepositoryInterface;
use App\Domain\ValueObject\Email;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * Doctrine Repository (Adapter) - ImplÃ©mente le port du domaine
 */
class UserRepository extends ServiceEntityRepository implements UserRepositoryInterface
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, UserEntity::class);
    }

    public function save(UserEntity $user): void
    {
        $userEntity = $this->toDoctrineEntity($user);

        $this->getEntityManager()->persist($userEntity);
        $this->getEntityManager()->flush();

        // Sync l'ID gÃ©nÃ©rÃ© vers l'entitÃ© domain
        if ($user->getId() === null && $userEntity->getId() !== null) {
            $user->setId($userEntity->getId());
        }
    }

    public function delete(UserEntity $user): void
    {
        $userEntity = $this->find($user->getId());
        if ($userEntity) {
            $this->getEntityManager()->remove($userEntity);
            $this->getEntityManager()->flush();
        }
    }

    public function findById(int $id): ?UserEntity
    {
        $userEntity = $this->find($id);
        return $userEntity ? $this->toDomainEntity($userEntity) : null;
    }

    public function findByEmail(Email $email): ?UserEntity
    {
        $userEntity = $this->findOneBy(['email' => $email->getValue()]);
        return $userEntity ? $this->toDomainEntity($userEntity) : null;
    }

    public function findAll(): array
    {
        $entities = $this->findBy([], ['createdAt' => 'DESC']);
        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function findActiveUsers(): array
    {
        $entities = $this->createQueryBuilder('u')
            ->where('u.isActive = :active')
            ->setParameter('active', true)
            ->orderBy('u.createdAt', 'DESC')
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function findByRole(string $role): array
    {
        $entities = $this->createQueryBuilder('u')
            ->andWhere('JSON_CONTAINS(u.roles, :role) = 1')
            ->setParameter('role', json_encode($role))
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function search(string $searchTerm): array
    {
        $entities = $this->createQueryBuilder('u')
            ->where('u.email LIKE :search OR u.firstname LIKE :search OR u.lastname LIKE :search')
            ->setParameter('search', '%' . $searchTerm . '%')
            ->orderBy('u.lastname', 'ASC')
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function countActiveUsers(): int
    {
        return (int) $this->createQueryBuilder('u')
            ->select('COUNT(u.id)')
            ->where('u.isActive = :active')
            ->setParameter('active', true)
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function existsByEmail(Email $email): bool
    {
        return $this->count(['email' => $email->getValue()]) > 0;
    }

    /**
     * Convertit une entitÃ© Domain en entitÃ© Doctrine
     */
    private function toDoctrineEntity(UserEntity $domainUser): UserEntity
    {
        $userEntity = new UserEntity();

        if ($domainUser->getId() !== null) {
            $existing = $this->find($domainUser->getId());
            if ($existing) {
                $userEntity = $existing;
            } else {
                $userEntity->setId($domainUser->getId());
            }
        }

        $userEntity->setEmail($domainUser->getEmail());
        $userEntity->setRoles($domainUser->getRoles());
        $userEntity->setPassword($domainUser->getPassword());
//        $userEntity->setFirstname($domainUser->getFirstname());
//        $userEntity->setLastname($domainUser->getLastname());
        $userEntity->setIsActive($domainUser->isActive());
        $userEntity->setCreatedAt($domainUser->getCreatedAt());

        if ($domainUser->getUpdatedAt()) {
            $userEntity->setUpdatedAt($domainUser->getUpdatedAt());
        }

        return $userEntity;
    }

    /**
     * Convertit une entitÃ© Doctrine en entitÃ© Domain
     */
    private function toDomainEntity(UserEntity $userEntity): UserEntity
    {
        $user = new UserEntity(
            new Email($userEntity->getEmail()),
            $userEntity->getPassword(),
//            $userEntity->getFirstname(),
//            $userEntity->getLastname()
        );

        $user->setId($userEntity->getId());

        // Restaurer les rÃ´les (sans ROLE_USER par dÃ©faut qui sera ajoutÃ© automatiquement)
        $roles = array_filter($userEntity->getRoles(), fn($r) => $r !== 'ROLE_USER');
//        foreach ($roles as $role) {
//            $user->addRole($role);
//        }
        $user->setRoles($roles);

//        if (!$userEntity->isActive()) {
//            $user->deactivate();
//        }

        return $user;
    }

    public function getUserByAuthUid(string $firebaseAuthId): ?UserEntity
    {
        return $this->findOneBy(['authUid' => $firebaseAuthId]);
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/VenueRepository.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Repository/VenueRepository.php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Infrastructure\Persistence\Doctrine\Entity\VenueEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<VenueEntity>
 */
class VenueRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, VenueEntity::class);
    }

    public function save(VenueEntity $venue): void
    {
        $this->getEntityManager()->persist($venue);
        $this->getEntityManager()->flush();
    }

    public function delete(VenueEntity $venue): void
    {
        $this->getEntityManager()->remove($venue);
        $this->getEntityManager()->flush();
    }

    public function findByUuid(string $uuid): ?VenueEntity
    {
        return $this->findOneBy(['uuid' => $uuid]);
    }

    /**
     * RÃ©cupÃ¨re la liste des venues avec pagination
     *
     * @param int $page NumÃ©ro de page (commence Ã  1)
     * @param int $limit Nombre d'Ã©lÃ©ments par page
     * @param string|null $search Terme de recherche optionnel
     * @param int|null $type Filtre par type optionnel
     * @return array{items: VenueEntity[], total: int, page: int, limit: int, pages: int}
     */
    public function findPaginated(int $page = 1, int $limit = 20, ?string $search = null, ?int $type = null): array
    {
        $qb = $this->createQueryBuilder('v')
            ->orderBy('v.rank', 'DESC')
            ->addOrderBy('v.name', 'ASC');

        // Appliquer les filtres
        if ($search !== null && !empty($search)) {
            $qb->andWhere('v.name LIKE :search OR v.description LIKE :search')
                ->setParameter('search', '%' . $search . '%');
        }

        if ($type !== null) {
            $qb->andWhere('v.type = :type')
                ->setParameter('type', $type);
        }

        // Compter le total
        $countQb = clone $qb;
        $total = (int) $countQb->select('COUNT(v.id)')
            ->getQuery()
            ->getSingleScalarResult();

        // Pagination
        $offset = ($page - 1) * $limit;
        $qb->setFirstResult($offset)
            ->setMaxResults($limit);

        $items = $qb->getQuery()->getResult();

        $pages = (int) ceil($total / $limit);

        return [
            'items' => $items,
            'total' => $total,
            'page' => $page,
            'limit' => $limit,
            'pages' => $pages
        ];
    }

    /**
     * RÃ©cupÃ¨re les venues par type
     */
    public function findByType(int $type): array
    {
        return $this->findBy(['type' => $type], ['rank' => 'DESC', 'name' => 'ASC']);
    }

    /**
     * RÃ©cupÃ¨re les venues les mieux classÃ©es
     */
    public function findTopRated(int $limit = 10): array
    {
        return $this->findBy([], ['rank' => 'DESC', 'name' => 'ASC'], $limit);
    }
}



FICHIER: src/Infrastructure/Security/JWTLoginSuccessHandler.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/JWTLoginSuccessHandler.php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Lexik\Bundle\JWTAuthenticationBundle\Event\AuthenticationSuccessEvent;
use Lexik\Bundle\JWTAuthenticationBundle\Events;
use Lexik\Bundle\JWTAuthenticationBundle\Response\JWTAuthenticationSuccessResponse;
use Lexik\Bundle\JWTAuthenticationBundle\Security\Http\Cookie\JWTCookieProvider;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationSuccessHandlerInterface;
use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;

class JWTLoginSuccessHandler implements AuthenticationSuccessHandlerInterface
{
    public function __construct(
        protected JWTTokenManagerInterface $jwtManager,
        protected EventDispatcherInterface $dispatcher,
        protected RefreshTokenService $refreshTokenService,
        iterable $cookieProviders = [],
        bool $removeTokenFromBodyWhenCookiesUsed = true
    ) {
        $this->jwtManager = $jwtManager;
        $this->dispatcher = $dispatcher;
        $this->refreshTokenService = $refreshTokenService;
        $this->cookieProviders = $cookieProviders;
        $this->removeTokenFromBodyWhenCookiesUsed = $removeTokenFromBodyWhenCookiesUsed;
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token): Response
    {
        return $this->handleAuthenticationSuccess($token->getUser());
    }

    public function handleAuthenticationSuccess(UserInterface $user, $jwt = null)
    {
        if (null === $jwt) {
            $jwt = $this->jwtManager->create($user);
        }

        // GÃ©nÃ©rer un refresh token si l'utilisateur est une instance de UserEntity
        $refreshToken = null;
        if ($user instanceof UserEntity) {
            $refreshTokenEntity = $this->refreshTokenService->createRefreshToken($user);
            $refreshToken = $refreshTokenEntity->getRefreshToken();
        }

        $jwtCookies = [];
        foreach ($this->cookieProviders as $cookieProvider) {
            $jwtCookies[] = $cookieProvider->createCookie($jwt);
        }

        $responseData = [
            'token' => $jwt,
            'refresh_token' => $refreshToken,
            'user' => [
                'email' => $user->getUserIdentifier(),
                'roles' => $user->getRoles(),
                'firstname' => method_exists($user, 'getFirstname') ? $user->getFirstname() : null,
                'lastname' => method_exists($user, 'getLastname') ? $user->getLastname() : null,
            ],
        ];

        $event = new AuthenticationSuccessEvent($responseData, $user, new JWTAuthenticationSuccessResponse($jwt, [], $jwtCookies));
        $this->dispatcher->dispatch($event, Events::AUTHENTICATION_SUCCESS);

        $response = new JWTAuthenticationSuccessResponse($jwt, [], $jwtCookies);
        $response->setData($event->getData());

        if ($jwtCookies && $this->removeTokenFromBodyWhenCookiesUsed) {
            unset($responseData['token']);
        }

        return $response;
    }
}



FICHIER: src/Infrastructure/Security/JwtAuthenticator.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;

class JwtAuthenticator extends AbstractAuthenticator
{
    private JWTTokenManagerInterface $jwtManager;
    private UserProviderInterface $userProvider;

    public function __construct(JWTTokenManagerInterface $jwtManager, UserProviderInterface $userProvider)
    {
        $this->jwtManager = $jwtManager;
        $this->userProvider = $userProvider;
    }

    public function supports(Request $request): ?bool
    {
        return $request->headers->has('Authorization');
    }

    public function authenticate(Request $request): SelfValidatingPassport
    {
        $authHeader = $request->headers->get('Authorization');
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            throw new AuthenticationException('JWT Token not found');
        }

        $jwt = substr($authHeader, 7);

        try {
            $payload = $this->jwtManager->decodeFromJsonWebToken($jwt);
        } catch (\Exception $e) {
            throw new AuthenticationException('Invalid JWT Token');
        }

        $username = $payload['username'] ?? null;
        if (!$username) {
            throw new AuthenticationException('JWT Token invalid: username missing');
        }

        return new SelfValidatingPassport(
            new UserBadge($username, fn($userIdentifier) => $this->userProvider->loadUserByUsername($userIdentifier))
        );
    }

    public function onAuthenticationSuccess(Request $request, $token, string $firewallName): ?JsonResponse
    {
        // Laisser continuer la requÃªte
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?JsonResponse
    {
        return new JsonResponse([
            'code' => 401,
            'message' => $exception->getMessage(),
        ], 401);
    }
}



FICHIER: src/Infrastructure/Security/RefreshTokenAuthenticator.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/RefreshTokenAuthenticator.php

namespace App\Infrastructure\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

class RefreshTokenAuthenticator extends AbstractAuthenticator
{
    public function __construct(
        private RefreshTokenService $refreshTokenService,
        private UserProviderInterface $userProvider
    ) {}

    public function supports(Request $request): ?bool
    {
        return $request->getPathInfo() === '/api/auth/refresh' && $request->isMethod('POST');
    }

    public function authenticate(Request $request): SelfValidatingPassport
    {
        $data = json_decode($request->getContent(), true);
        $refreshTokenString = $data['refresh_token'] ?? null;

        if (!$refreshTokenString) {
            throw new AuthenticationException('Refresh token missing');
        }

        $refreshToken = $this->refreshTokenService->validateRefreshToken($refreshTokenString);

        if (!$refreshToken) {
            throw new AuthenticationException('Invalid refresh token');
        }

        $user = $refreshToken->getUser();

        return new SelfValidatingPassport(
            new UserBadge($user->getUserIdentifier(), fn() => $user)
        );
    }

    public function onAuthenticationSuccess(Request $request, $token, string $firewallName): ?JsonResponse
    {
        return null; // Continue la requÃªte
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?JsonResponse
    {
        return new JsonResponse([
            'error' => 'Refresh token invalide'
        ], 401);
    }
}



FICHIER: src/Infrastructure/Security/RefreshTokenService.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/RefreshTokenService.php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Entity\RefreshTokenEntity;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\RefreshTokenRepository;
use Symfony\Component\Security\Csrf\TokenGenerator\TokenGeneratorInterface;

class RefreshTokenService
{
    public function __construct(
        private readonly RefreshTokenRepository $refreshTokenRepository,
        private readonly TokenGeneratorInterface $tokenGenerator,
        private readonly int $ttl = 2592000 // 30 jours en secondes
    ) {}

    public function createRefreshToken(UserEntity $user): RefreshTokenEntity
    {
        // Optionnel: rÃ©voquer tous les anciens tokens pour cet utilisateur
        // $this->refreshTokenRepository->revokeAllForUser($user);

        $refreshToken = new RefreshTokenEntity();
        $refreshToken->setRefreshToken($this->tokenGenerator->generateToken());
        $refreshToken->setUser($user);
        $refreshToken->setValid(new \DateTime('+' . $this->ttl . ' seconds'));
        $refreshToken->setRevoked(false);

        $this->refreshTokenRepository->save($refreshToken);

        return $refreshToken;
    }

    public function validateRefreshToken(string $tokenString): ?RefreshTokenEntity
    {
        $refreshToken = $this->refreshTokenRepository->findByToken($tokenString);

        if (!$refreshToken || !$refreshToken->isValid()) {
            return null;
        }

        return $refreshToken;
    }

    public function revokeRefreshToken(string $tokenString): void
    {
        $refreshToken = $this->refreshTokenRepository->findByToken($tokenString);
        if ($refreshToken) {
            $refreshToken->setRevoked(true);
            $this->refreshTokenRepository->save($refreshToken);
        }
    }

    public function revokeAllUserTokens(UserEntity $user): void
    {
        $this->refreshTokenRepository->revokeAllForUser($user);
    }

    public function rotateRefreshToken(string $oldTokenString): ?RefreshTokenEntity
    {
        $oldToken = $this->validateRefreshToken($oldTokenString);
        if (!$oldToken) {
            return null;
        }

        // RÃ©voquer l'ancien token
        $oldToken->setRevoked(true);
        $this->refreshTokenRepository->save($oldToken);

        // CrÃ©er un nouveau token
        return $this->createRefreshToken($oldToken->getUser());
    }
}



FICHIER: src/Infrastructure/Security/UserProvider.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Symfony\Component\Security\Core\Exception\UserNotFoundException;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Core\User\UserProviderInterface;

/**
 * UserProvider adaptÃ© Ã  l'architecture hexagonale
 */
class UserProvider implements UserProviderInterface, PasswordUpgraderInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {}

    public function refreshUser(UserInterface $user): UserInterface
    {
        if (!$user instanceof \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity) {
            throw new UnsupportedUserException(sprintf('Invalid user class "%s".', $user::class));
        }

        $freshUser = $this->userRepository->find($user->getId());

        if (!$freshUser) {
            throw new UserNotFoundException();
        }

        return $freshUser;
    }

    public function supportsClass(string $class): bool
    {
        return \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity::class === $class
            || is_subclass_of($class, \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity::class);
    }

    public function loadUserByIdentifier(string $identifier): UserInterface
    {
        $user = $this->userRepository->findOneBy(['email' => $identifier]);

        if (!$user) {
            throw new UserNotFoundException(sprintf('User "%s" not found.', $identifier));
        }

        return $user;
    }

    public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
    {
        if (!$user instanceof \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity) {
            throw new UnsupportedUserException(sprintf('Invalid user class "%s".', $user::class));
        }

        $user->setPassword($newHashedPassword);
        $this->userRepository->getEntityManager()->persist($user);
        $this->userRepository->getEntityManager()->flush();
    }
}


FICHIER: src/Kernel.php
--------------------------------------------------------------------------------
<?php

namespace App;

use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
}



FICHIER: src/Shared/Application/Command/CommandBusInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandBusInterface
{
    public function execute(CommandInterface $command): mixed;
}



FICHIER: src/Shared/Application/Command/CommandHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandHandlerInterface
{
}



FICHIER: src/Shared/Application/Command/CommandInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandInterface
{
}



FICHIER: src/Shared/Application/Query/QueryBusInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryBusInterface
{
    public function execute(QueryInterface $query): mixed;
}



FICHIER: src/Shared/Application/Query/QueryHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryHandlerInterface
{
}



FICHIER: src/Shared/Application/Query/QueryInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryInterface
{
}



FICHIER: src/Shared/Domain/Event/EventHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Domain\Event;

interface EventHandlerInterface
{
}



FICHIER: src/Shared/Domain/Event/EventInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Domain\Event;

interface EventInterface
{
}



FICHIER: src/Shared/Infrastructure/Bus/CommandBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Command\CommandBusInterface;
use App\Shared\Application\Command\CommandInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class CommandBus implements CommandBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $commandBus)
    {
        $this->messageBus = $commandBus;
    }

    public function execute(CommandInterface $command): mixed
    {
        return $this->handle($command);
    }
}



FICHIER: src/Shared/Infrastructure/Bus/EventBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Event\EventBusInterface;
use App\Shared\Domain\Event\EventInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class EventBus implements EventBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $queryBus)
    {
        $this->messageBus = $queryBus;
    }

    public function execute(EventInterface $event): mixed
    {
        return $this->handle($event);
    }
}



FICHIER: src/Shared/Infrastructure/Bus/QueryBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Query\QueryBusInterface;
use App\Shared\Application\Query\QueryInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class QueryBus implements QueryBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $queryBus)
    {
        $this->messageBus = $queryBus;
    }

    public function execute(QueryInterface $query): mixed
    {
        return $this->handle($query);
    }
}



FICHIER: src/Users/Application/Config/UsersAppConfig.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Config;

class UsersAppConfig
{
    static int $ERREUR_FATAL = 1;
    static int $ERREUR_SYSTEM_INFO = 2;
    static int $ERREUR_USER = 3;
    static int $USER_NEED_RESTART = 10; // temporaire
    static int $USER_BANNED = 20; // dÃ©finitif
    static int $USER_BLOCKED = 30; // temporaire
    static int $USER_UNSUBSCRIBED = 50; // dÃ©finitif


    static int $RANDOM_LIMIT = 10;
    static int $RANDOM_TIME_LIMIT = 5;
    static int $RANDOM_HISTORY_TIME_LIMIT = 604800;
    static string $SLOT_SECRET = "Nu31Xc8em6X76UKGJxqAOTClh6egRT8vAMQYbQdSqVBuToYcFN";
    static int $LINK_SUGGESTED = 1;
    static int $LINK_ACCEPTED = 2;
    static int $LINK_DECLINED = 3;
    static int $LINK_SLOT_WIN = 4;
    static int $NOTIFICATION_STATE_NEW = 0;
    static int $NOTIFICATION_STATE_READ = 1;
    static int $FOLLOW_TYPE_VISIT = 01;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_SUGGEST = 11;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_ACCEPT = 12;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_DECLINE = 13;
    static int $FOLLOW_TYPE_SLOT_WIN = 21;


    static int $NOTIFICATION_TYPE_CONTACT = 1;
    static int $NOTIFICATION_TYPE_SLOT_WIN = 3;
    static int $NOTIFICATION_TYPE_MESSAGE = 10;

    static int $CREDITS_BY_NB_WON = 5;
    static int $FREE_DAY_CREDITS = 50;


    static int $CREDIT_LOG_REASON_DAY_FREE = 1;
    static int $CREDIT_LOG_REASON_SLOT_WIN_CONFIRM = 2;
}


FICHIER: src/Users/Application/DTO/UserDTO.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Users\Application\DTO;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Users\Domain\Entity\User;

class UserDTO
{
    public function __construct(
        public readonly ?int $id,
        public readonly string $uid,
        public readonly string $authUid,
        public readonly string $email,
        public readonly string $username = '',
        public readonly string $aboutMe = '',
        public readonly int $gender = 0,
        public readonly \DateTime $birthdate = new \DateTime(),
        public readonly int $status = 0,
    ) {
    }

    public static function fromEntity(UserEntity $user): self
    {
        return new self(
            $user->getId(),
            $user->getUid(),
            $user->getAuthUid(),
            $user->getEmail(),
            $user->getUsername(),
            $user->getAboutMe(),
            $user->getGender(),
            $user->getBirthdate(),
            $user->getStatus(),
        );
    }
    public static function fromArray(array $user): self
    {
        $birthdate = \DateTime::createFromFormat("Y-m-d", $user['birthdate']);

        return new self(
            $user['id'],
            $user['uid'],
            $user['auth_uid'],
            $user['email'],
            $user['username'],
            $user['about_me'],
            $user['gender'],
            $birthdate,
            $user['status'],
        );
    }

    public static function forSignupProcess(string $authUid): self
    {
        return new self(null, '', $authUid, '');
    }
}



FICHIER: src/Users/Application/Query/GetJwtForSignup/GetJwtForSignupQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtForSignup;

use App\Shared\Application\Query\QueryInterface;
use App\Users\Application\DTO\UserDTO;

class GetJwtForSignupQuery implements QueryInterface
{
    public function __construct(
        public readonly UserDTO $userDto
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetJwtForSignup/GetJwtForSignupQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtForSignup;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Shared\Application\Query\QueryHandlerInterface;
use App\Users\Application\DTO\UserDTO;
//use App\Users\Domain\Repository\UserRepositoryInterface;
use Lcobucci\JWT\Encoding\ChainedFormatter;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Signer\Key\InMemory;
use Lcobucci\JWT\Signer\Hmac\Sha512;
use Lcobucci\JWT\Token\Builder;

class GetJwtForSignupQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {
    }

    public function __invoke(GetJwtForSignupQuery $query): string
    {
        $userDto = $query->userDto;

        $authUid = $userDto->authUid;
        $email = $userDto->email;

        $tokenBuilder = (new Builder(new JoseEncoder(), ChainedFormatter::default()));
        $algorithm = new Sha512();
        $signinKey = InMemory::file(__DIR__.'/../../../../../config/jwt/private.pem');

        $now = new \DateTimeImmutable();

        $token = $tokenBuilder
//            ->issuedBy('http://example.com')
//            ->permittedFor('http://example.org')
//            ->relatedTo('component1')
//            ->identifiedBy('4f1g23a12aa')
//            ->issuedAt($now)
//            ->canOnlyBeUsedAfter($now->modify('+1 minute'))
            ->expiresAt($now->modify('+1 hour'))
            ->withClaim('authUid', $authUid)
            ->withClaim('email', $email)
            ->withClaim('username', $email)
            ->getToken($algorithm, $signinKey);

        return $token->toString();
    }
}



FICHIER: src/Users/Application/Query/GetJwtFromUser/GetJwtFromUserQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtFromUser;

use App\Shared\Application\Query\QueryInterface;
use App\Users\Application\DTO\UserDTO;

class GetJwtFromUserQuery implements QueryInterface
{
    public function __construct(
        public readonly UserDTO $user
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetJwtFromUser/GetJwtFromUserQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtFromUser;

use App\Shared\Application\Query\QueryHandlerInterface;
use Lexik\Bundle\JWTAuthenticationBundle\Encoder\JWTEncoderInterface;

class GetJwtFromUserQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly JWTEncoderInterface $encoder
    ) {
    }

    public function __invoke(GetJwtFromUserQuery $query): string
    {
        return $this->encoder->encode(
            [
                'roles' => [
                    'ROLE_USER',
                ],
                'email' => $query->user->email,
                'username' => $query->user->email,
                'uid' => $query->user->authUid,
            ]
        );
    }
}



FICHIER: src/Users/Application/Query/GetUserByFirebaseToken/GetUserByFirebaseTokenQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetUserByFirebaseToken;

use App\Shared\Application\Query\QueryInterface;

class GetUserByFirebaseTokenQuery implements QueryInterface
{
    public function __construct(
        public readonly string $token,
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetUserByFirebaseToken/GetUserByFirebaseTokenQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetUserByFirebaseToken;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Shared\Application\Query\QueryHandlerInterface;
use App\Users\Application\DTO\UserDTO;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Signer;
use Lcobucci\JWT\Signer\Rsa\Sha256;
use Lcobucci\JWT\Token\Parser;
use Lcobucci\JWT\Token\Plain;
use Lcobucci\JWT\Validation\Constraint\SignedWith;
use Lcobucci\JWT\Validation\Validator;

class GetUserByFirebaseTokenQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {
    }

    public function __invoke(GetUserByFirebaseTokenQuery $query): UserDTO
    {
        $firebaseToken = $query->token;

        $parser = new Parser(new JoseEncoder());

        /** @var Plain $token */
        $token = $parser->parse($firebaseToken);

        $kid = $token->headers()->get('kid');

        $googleJson = file_get_contents('https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com');

        $jsonParsed = json_decode($googleJson, true);

        $privateKey = $jsonParsed[$kid];

        $signer = new Sha256();

        $validator = new Validator();

        $validator->assert($token, new SignedWith($signer, Signer\Key\InMemory::plainText($privateKey)));

        $firebaseAuthId = $token->claims()->get('user_id');

        $user = $this->userRepository->getUserByAuthUid($firebaseAuthId);

        if (null == $user) {
            return UserDTO::forSignupProcess($firebaseAuthId);
        }

        return UserDTO::fromEntity($user);
    }
}



FICHIER: src/Users/Domain/Repository/UserRepositoryInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Users\Domain\Repository;

use App\Users\Domain\Entity\User;

interface UserRepositoryInterface
{
    public function add(User $user): void;
    public function update(User $user): void;
    public function findByAuthUid(string $authUid): ?User;
    public function findByUid(string $uid): ?User;
    public function findDetailedByUid(string $uid, float $myLatitude, float $myLongitude): array;
    public function findByEmail(string $email): ?User;
    public function getUserByAuthUid(string $firebaseAuthId): ?User;
    public function getFilteredList(bool $totally, int $myIdUser, int $skip, int $genderWanted, int $minAge, int $maxAge, int $maxDistance, bool $onlyWithPhoto, bool $onlyInFavorites, float $myLatitude, float $myLongitude): array;
    public function getRandomList(int $myIdUser, array $excludedUsers, int $genderWanted, int $minAge, int $maxAge, int $maxDistance, bool $onlyWithPhoto, bool $onlyInFavorites, float $myLatitude, float $myLongitude, int $nbMax = -1, bool $excludeFake = false): array;
    public function getAllPhotosByUsers(array $listIdUsers): array;
    public function findManyByUids(array $contactsUids);
    public function getContactsFilteredList(int $idUser): array;
    public function findByUsername(string $username): ?User;

    public function getListFromIds(int $myIdUser, array $usersIds, float $myLatitude, float $myLongitude): array;

}



FIN
============
Total fichiers: 69


