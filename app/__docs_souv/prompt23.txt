venues_remote_data_source.dart ne me convient pas.
Je voudrais faire comme tables_controller.
Il faut un venue_service, Ã  l'instart de account_service ou sfu_service.
Qui appelle ensuite api_service avec des mÃ©thodes Ã  implÃ©menter.

On ne passe pas le datasource pour faire un appel api, mais par le controller.

Voici l'Ã©tat actuel du projet.

FICHIERS POUR ANALYSE
=====================
Dossiers analysÃ©s:
  - flutter_lib/features/venues
  - flutter_lib/features/tables
  - flutter_lib/providers
  - flutter_lib/services
  - src
Extensions: dart, php, yaml, yml
Date: 2026-02-25 15:53:54

ARBORESCENCE:
-------------
â”œâ”€â”€ ğŸ“ flutter_lib/
â”‚   â”œâ”€â”€ ğŸ“ features/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ tables/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ data/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ datasources/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_remote_data_source.dart
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_remote_data_source.g.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ models/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_model.dart
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_model.freezed.dart
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_model.g.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ repositories/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ tables_repository_impl.dart
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“„ tables_repository_impl.g.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ domain/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ entities/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tables_entity.dart
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_entity.freezed.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ repositories/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ tables_repository.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ usecases/
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“„ get_tabless_usecase.dart
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“„ get_tabless_usecase.g.dart
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ presentation/
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ controllers/
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ tables_controller.dart
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ tables_controller.g.dart
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ screens/
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ connect.dart
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ prejoin.dart
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ room.dart
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ tables_screen.dart
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ widgets/
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“„ controls.dart
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“„ no_video.dart
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“„ participant.dart
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“„ participant_info.dart
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“„ participant_stats.dart
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“„ sound_waveform.dart
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“„ text_field.dart
â”‚   â”‚   â””â”€â”€ ğŸ“ venues/
â”‚   â”‚       â”œâ”€â”€ ğŸ“ data/
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ datasources/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_remote_data_source.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_remote_data_source.g.dart
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ models/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ paginated_response_model.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ paginated_response_model.freezed.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ paginated_response_model.g.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_model.dart
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_model.freezed.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_model.g.dart
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ repositories/
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ venues_repository_impl.dart
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“„ venues_repository_impl.g.dart
â”‚   â”‚       â”œâ”€â”€ ğŸ“ domain/
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ entities/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“„ venues_entity.dart
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_entity.freezed.dart
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ repositories/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“„ venues_repository.dart
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ usecases/
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“„ get_venues_usecase.dart
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“„ get_venues_usecase.g.dart
â”‚   â”‚       â””â”€â”€ ğŸ“ presentation/
â”‚   â”‚           â”œâ”€â”€ ğŸ“ controllers/
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“„ venues_controller.dart
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“„ venues_controller.g.dart
â”‚   â”‚           â””â”€â”€ ğŸ“ screens/
â”‚   â”‚               â””â”€â”€ ğŸ“„ venues_screen.dart
â”‚   â”œâ”€â”€ ğŸ“ providers/
â”‚   â”‚   â””â”€â”€ ğŸ“„ auth_provider.dart
â”‚   â””â”€â”€ ğŸ“ services/
â”‚       â”œâ”€â”€ ğŸ“„ account_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ account_service.g.dart
â”‚       â”œâ”€â”€ ğŸ“„ api_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ api_service.g.dart
â”‚       â”œâ”€â”€ ğŸ“„ auth_service.dart
â”‚       â”œâ”€â”€ ğŸ“„ sfu_service.dart
â”‚       â””â”€â”€ ğŸ“„ sfu_service.g.dart
â””â”€â”€ ğŸ“ src/
    â”œâ”€â”€ ğŸ“ Domain/
    â”‚   â”œâ”€â”€ ğŸ“ Entity/
    â”‚   â”‚   â””â”€â”€ ğŸ“„ User.php
    â”‚   â”œâ”€â”€ ğŸ“ Repository/
    â”‚   â”‚   â””â”€â”€ ğŸ“„ UserRepositoryInterface.php
    â”‚   â””â”€â”€ ğŸ“ ValueObject/
    â”‚       â”œâ”€â”€ ğŸ“„ Email.php
    â”‚       â””â”€â”€ ğŸ“„ UserRole.php
    â”œâ”€â”€ ğŸ“ Infrastructure/
    â”‚   â”œâ”€â”€ ğŸ“ Console/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Command/
    â”‚   â”‚       â””â”€â”€ ğŸ“„ ClearExpiredRefreshTokensCommand.php
    â”‚   â”œâ”€â”€ ğŸ“ Http/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Controller/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ AccountController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ AuthController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ GenerateLiveKitController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ GeneratePromptController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ LogoutController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ PhotoController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenController.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ UsersGetJwtTokenFromFirebaseAuthAction.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ VenueController.php
    â”‚   â”œâ”€â”€ ğŸ“ Persistence/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ Entity/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ RefreshTokenEntity.php
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ UserEntity.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ VenueEntity.php
    â”‚   â”‚       â””â”€â”€ ğŸ“ Repository/
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ RefreshTokenRepository.php
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ UserRepository.php
    â”‚   â”‚           â””â”€â”€ ğŸ“„ VenueRepository.php
    â”‚   â””â”€â”€ ğŸ“ Security/
    â”‚       â”œâ”€â”€ ğŸ“„ JWTLoginSuccessHandler.php
    â”‚       â”œâ”€â”€ ğŸ“„ JwtAuthenticator.php
    â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenAuthenticator.php
    â”‚       â”œâ”€â”€ ğŸ“„ RefreshTokenService.php
    â”‚       â””â”€â”€ ğŸ“„ UserProvider.php
    â”œâ”€â”€ ğŸ“ Shared/
    â”‚   â”œâ”€â”€ ğŸ“ Application/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ Command/
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CommandBusInterface.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CommandHandlerInterface.php
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ CommandInterface.php
    â”‚   â”‚   â””â”€â”€ ğŸ“ Query/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ QueryBusInterface.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ QueryHandlerInterface.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ QueryInterface.php
    â”‚   â”œâ”€â”€ ğŸ“ Domain/
    â”‚   â”‚   â””â”€â”€ ğŸ“ Event/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“„ EventHandlerInterface.php
    â”‚   â”‚       â””â”€â”€ ğŸ“„ EventInterface.php
    â”‚   â””â”€â”€ ğŸ“ Infrastructure/
    â”‚       â””â”€â”€ ğŸ“ Bus/
    â”‚           â”œâ”€â”€ ğŸ“„ CommandBus.php
    â”‚           â”œâ”€â”€ ğŸ“„ EventBus.php
    â”‚           â””â”€â”€ ğŸ“„ QueryBus.php
    â”œâ”€â”€ ğŸ“ Users/
    â”‚   â”œâ”€â”€ ğŸ“ Application/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ Config/
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ UsersAppConfig.php
    â”‚   â”‚   â”œâ”€â”€ ğŸ“ DTO/
    â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ UserDTO.php
    â”‚   â”‚   â””â”€â”€ ğŸ“ Query/
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ GetJwtForSignup/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ GetJwtForSignupQuery.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ GetJwtForSignupQueryHandler.php
    â”‚   â”‚       â”œâ”€â”€ ğŸ“ GetJwtFromUser/
    â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“„ GetJwtFromUserQuery.php
    â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“„ GetJwtFromUserQueryHandler.php
    â”‚   â”‚       â””â”€â”€ ğŸ“ GetUserByFirebaseToken/
    â”‚   â”‚           â”œâ”€â”€ ğŸ“„ GetUserByFirebaseTokenQuery.php
    â”‚   â”‚           â””â”€â”€ ğŸ“„ GetUserByFirebaseTokenQueryHandler.php
    â”‚   â””â”€â”€ ğŸ“ Domain/
    â”‚       â””â”€â”€ ğŸ“ Repository/
    â”‚           â””â”€â”€ ğŸ“„ UserRepositoryInterface.php
    â””â”€â”€ ğŸ“„ Kernel.php


CONTENU DES FICHIERS
====================

FICHIER: flutter_lib/features/tables/data/datasources/tables_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../core/providers/network_providers.dart';
import '../models/tables_model.dart';

part 'tables_remote_data_source.g.dart';

abstract class TablesRemoteDataSource {
  Future<List<TablesModel>> fetchTabless();
  Future<TablesModel> fetchTables(String id);
}

@riverpod
TablesRemoteDataSource tablesRemoteDataSource(Ref ref) {
  final dio = ref.watch(dioProvider);
  return TablesRemoteDataSourceImpl(dio);
}

class TablesRemoteDataSourceImpl implements TablesRemoteDataSource {
  final Dio _dio;

  TablesRemoteDataSourceImpl(this._dio);

  @override
  Future<List<TablesModel>> fetchTabless() async {
    // final response = await _dio.get('/tabless');
    // return (response.data as List).map((e) => TablesModel.fromJson(e)).toList();
    await Future.delayed(const Duration(seconds: 1));
    return [
      const TablesModel(id: '1', name: 'Item 1'),
      const TablesModel(id: '2', name: 'Item 2'),
    ];
  }

  @override
  Future<TablesModel> fetchTables(String id) async {
    await Future.delayed(const Duration(seconds: 1));
    return TablesModel(id: id, name: 'Item ');
  }
}



FICHIER: flutter_lib/features/tables/data/datasources/tables_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(tablesRemoteDataSource)
final tablesRemoteDataSourceProvider = TablesRemoteDataSourceProvider._();

final class TablesRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          TablesRemoteDataSource,
          TablesRemoteDataSource,
          TablesRemoteDataSource
        >
    with $Provider<TablesRemoteDataSource> {
  TablesRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tablesRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tablesRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<TablesRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  TablesRemoteDataSource create(Ref ref) {
    return tablesRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TablesRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TablesRemoteDataSource>(value),
    );
  }
}

String _$tablesRemoteDataSourceHash() =>
    r'faaf82b4441e0fce90ae1381dc58e5f62907abaf';



FICHIER: flutter_lib/features/tables/data/models/tables_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/tables_entity.dart';

part 'tables_model.freezed.dart';
part 'tables_model.g.dart';

@freezed
abstract class TablesModel with _$TablesModel {
  const TablesModel._();

  const factory TablesModel({
    required String id,
    required String name,
  }) = _TablesModel;

  factory TablesModel.fromJson(Map<String, dynamic> json) =>
      _$TablesModelFromJson(json);

  TablesEntity toEntity() => TablesEntity(id: id, name: name);
}



FICHIER: flutter_lib/features/tables/data/models/tables_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tables_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$TablesModel {

 String get id; String get name;
/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TablesModelCopyWith<TablesModel> get copyWith => _$TablesModelCopyWithImpl<TablesModel>(this as TablesModel, _$identity);

  /// Serializes this TablesModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TablesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $TablesModelCopyWith<$Res>  {
  factory $TablesModelCopyWith(TablesModel value, $Res Function(TablesModel) _then) = _$TablesModelCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$TablesModelCopyWithImpl<$Res>
    implements $TablesModelCopyWith<$Res> {
  _$TablesModelCopyWithImpl(this._self, this._then);

  final TablesModel _self;
  final $Res Function(TablesModel) _then;

/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [TablesModel].
extension TablesModelPatterns on TablesModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _TablesModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _TablesModel value)  $default,){
final _that = this;
switch (_that) {
case _TablesModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _TablesModel value)?  $default,){
final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _TablesModel():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _TablesModel() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _TablesModel extends TablesModel {
  const _TablesModel({required this.id, required this.name}): super._();
  factory _TablesModel.fromJson(Map<String, dynamic> json) => _$TablesModelFromJson(json);

@override final  String id;
@override final  String name;

/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TablesModelCopyWith<_TablesModel> get copyWith => __$TablesModelCopyWithImpl<_TablesModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TablesModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TablesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesModel(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$TablesModelCopyWith<$Res> implements $TablesModelCopyWith<$Res> {
  factory _$TablesModelCopyWith(_TablesModel value, $Res Function(_TablesModel) _then) = __$TablesModelCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$TablesModelCopyWithImpl<$Res>
    implements _$TablesModelCopyWith<$Res> {
  __$TablesModelCopyWithImpl(this._self, this._then);

  final _TablesModel _self;
  final $Res Function(_TablesModel) _then;

/// Create a copy of TablesModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_TablesModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/tables/data/models/tables_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_TablesModel _$TablesModelFromJson(Map<String, dynamic> json) =>
    _TablesModel(id: json['id'] as String, name: json['name'] as String);

Map<String, dynamic> _$TablesModelToJson(_TablesModel instance) =>
    <String, dynamic>{'id': instance.id, 'name': instance.name};



FICHIER: flutter_lib/features/tables/data/repositories/tables_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/tables_entity.dart';
import '../../domain/repositories/tables_repository.dart';
import '../datasources/tables_remote_data_source.dart';

part 'tables_repository_impl.g.dart';

@riverpod
TablesRepository tablesRepository(Ref ref) {
  final remoteDataSource = ref.watch(tablesRemoteDataSourceProvider);
  return TablesRepositoryImpl(remoteDataSource);
}

class TablesRepositoryImpl implements TablesRepository {
  final TablesRemoteDataSource _remoteDataSource;

  TablesRepositoryImpl(this._remoteDataSource);

  @override
  Future<List<TablesEntity>> getTabless() async {
    final models = await _remoteDataSource.fetchTabless();
    return models.map((e) => e.toEntity()).toList();
  }

  @override
  Future<TablesEntity> getTables(String id) async {
    final model = await _remoteDataSource.fetchTables(id);
    return model.toEntity();
  }
}



FICHIER: flutter_lib/features/tables/data/repositories/tables_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(tablesRepository)
final tablesRepositoryProvider = TablesRepositoryProvider._();

final class TablesRepositoryProvider
    extends
        $FunctionalProvider<
          TablesRepository,
          TablesRepository,
          TablesRepository
        >
    with $Provider<TablesRepository> {
  TablesRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tablesRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tablesRepositoryHash();

  @$internal
  @override
  $ProviderElement<TablesRepository> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  TablesRepository create(Ref ref) {
    return tablesRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TablesRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TablesRepository>(value),
    );
  }
}

String _$tablesRepositoryHash() => r'e1101c1fd0ee9937e6af20cff3e97441681de356';



FICHIER: flutter_lib/features/tables/domain/entities/tables_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'tables_entity.freezed.dart';

@freezed
abstract class TablesEntity with _$TablesEntity {
  const factory TablesEntity({
    required String id,
    required String name,
  }) = _TablesEntity;
}



FICHIER: flutter_lib/features/tables/domain/entities/tables_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tables_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$TablesEntity {

 String get id; String get name;
/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TablesEntityCopyWith<TablesEntity> get copyWith => _$TablesEntityCopyWithImpl<TablesEntity>(this as TablesEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TablesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class $TablesEntityCopyWith<$Res>  {
  factory $TablesEntityCopyWith(TablesEntity value, $Res Function(TablesEntity) _then) = _$TablesEntityCopyWithImpl;
@useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class _$TablesEntityCopyWithImpl<$Res>
    implements $TablesEntityCopyWith<$Res> {
  _$TablesEntityCopyWithImpl(this._self, this._then);

  final TablesEntity _self;
  final $Res Function(TablesEntity) _then;

/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? name = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}


/// Adds pattern-matching-related methods to [TablesEntity].
extension TablesEntityPatterns on TablesEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _TablesEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _TablesEntity value)  $default,){
final _that = this;
switch (_that) {
case _TablesEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _TablesEntity value)?  $default,){
final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( String id,  String name)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( String id,  String name)  $default,) {final _that = this;
switch (_that) {
case _TablesEntity():
return $default(_that.id,_that.name);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( String id,  String name)?  $default,) {final _that = this;
switch (_that) {
case _TablesEntity() when $default != null:
return $default(_that.id,_that.name);case _:
  return null;

}
}

}

/// @nodoc


class _TablesEntity implements TablesEntity {
  const _TablesEntity({required this.id, required this.name});


@override final  String id;
@override final  String name;

/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TablesEntityCopyWith<_TablesEntity> get copyWith => __$TablesEntityCopyWithImpl<_TablesEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TablesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.name, name) || other.name == name));
}


@override
int get hashCode => Object.hash(runtimeType,id,name);

@override
String toString() {
  return 'TablesEntity(id: $id, name: $name)';
}


}

/// @nodoc
abstract mixin class _$TablesEntityCopyWith<$Res> implements $TablesEntityCopyWith<$Res> {
  factory _$TablesEntityCopyWith(_TablesEntity value, $Res Function(_TablesEntity) _then) = __$TablesEntityCopyWithImpl;
@override @useResult
$Res call({
 String id, String name
});




}
/// @nodoc
class __$TablesEntityCopyWithImpl<$Res>
    implements _$TablesEntityCopyWith<$Res> {
  __$TablesEntityCopyWithImpl(this._self, this._then);

  final _TablesEntity _self;
  final $Res Function(_TablesEntity) _then;

/// Create a copy of TablesEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? name = null,}) {
  return _then(_TablesEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/tables/domain/repositories/tables_repository.dart
--------------------------------------------------------------------------------
import '../entities/tables_entity.dart';

abstract class TablesRepository {
  Future<List<TablesEntity>> getTabless();
  Future<TablesEntity> getTables(String id);
}



FICHIER: flutter_lib/features/tables/domain/usecases/get_tabless_usecase.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/tables_entity.dart';
import '../repositories/tables_repository.dart';
import '../../data/repositories/tables_repository_impl.dart';

part 'get_tabless_usecase.g.dart';

@riverpod
Future<List<TablesEntity>> getTabless(Ref ref) {
  return ref.watch(tablesRepositoryProvider).getTabless();
}



FICHIER: flutter_lib/features/tables/domain/usecases/get_tabless_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_tabless_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getTabless)
final getTablessProvider = GetTablessProvider._();

final class GetTablessProvider
    extends
        $FunctionalProvider<
          AsyncValue<List<TablesEntity>>,
          List<TablesEntity>,
          FutureOr<List<TablesEntity>>
        >
    with
        $FutureModifier<List<TablesEntity>>,
        $FutureProvider<List<TablesEntity>> {
  GetTablessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'getTablessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$getTablessHash();

  @$internal
  @override
  $FutureProviderElement<List<TablesEntity>> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<List<TablesEntity>> create(Ref ref) {
    return getTabless(ref);
  }
}

String _$getTablessHash() => r'a540bcb396d51fbb80a1e6601cd7d6608e758543';



FICHIER: flutter_lib/features/tables/presentation/controllers/tables_controller.dart
--------------------------------------------------------------------------------
// flutter_lib/features/tables/presentation/controllers/tables_controller.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/tables_entity.dart';
import '../../domain/usecases/get_tabless_usecase.dart';
import '../../../../services/sfu_service.dart';
import '../../../../providers/auth_provider.dart';

part 'tables_controller.g.dart';

// Nouveau state pour gÃ©rer la gÃ©nÃ©ration de token
class TokenGenerationState {
  final bool isLoading;
  final Map<String, dynamic>? tokenData;
  final Object? error;

  const TokenGenerationState({
    this.isLoading = false,
    this.tokenData,
    this.error,
  });

  TokenGenerationState copyWith({
    bool? isLoading,
    Map<String, dynamic>? tokenData,
    Object? error,
  }) {
    return TokenGenerationState(
      isLoading: isLoading ?? this.isLoading,
      tokenData: tokenData ?? this.tokenData,
      error: error ?? this.error,
    );
  }
}

@riverpod
class TablesController extends _$TablesController {
  late SfuService _sfuService;

  @override
  FutureOr<List<TablesEntity>> build() {
    _sfuService = ref.watch(sfuServiceProvider);
    return ref.watch(getTablessProvider.future);
  }

  // Nouvelle mÃ©thode pour gÃ©nÃ©rer le token
  Future<Map<String, dynamic>?> generateTokenForTable(Map<String, dynamic> table) async {
    final authState = ref.read(authStateNotifierProvider);

    if (!authState.isFullyAuthenticated) {
      print('âŒ Utilisateur non authentifiÃ©');
      return null;
    }

    final connectedUserName = authState.user?.displayName ?? 'Utilisateur';
    final connectedUserIdentity = authState.user?.uid ?? '';

    if (connectedUserName.isEmpty || connectedUserIdentity.isEmpty) {
      print('âŒ Informations utilisateur manquantes');
      return null;
    }

    try {
      print('ğŸ”„ GÃ©nÃ©ration du token pour la table: ${table['name']}');

      final tokenData = await _sfuService.generateToken(
        participantIdentity: connectedUserIdentity,
        participantName: connectedUserName,
        roomName: table['name'],
      );

      print('âœ… Token gÃ©nÃ©rÃ© avec succÃ¨s');
      return tokenData;

    } catch (e) {
      print('âŒ Erreur lors de la gÃ©nÃ©ration du token: $e');
      rethrow;
    }
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => ref.refresh(getTablessProvider.future));
  }
}


FICHIER: flutter_lib/features/tables/presentation/controllers/tables_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'tables_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(TablesController)
final tablesControllerProvider = TablesControllerProvider._();

final class TablesControllerProvider
    extends $AsyncNotifierProvider<TablesController, List<TablesEntity>> {
  TablesControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tablesControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tablesControllerHash();

  @$internal
  @override
  TablesController create() => TablesController();
}

String _$tablesControllerHash() => r'f15b9925908014fc546d034ff7c0a2a99081cf9c';

abstract class _$TablesController extends $AsyncNotifier<List<TablesEntity>> {
  FutureOr<List<TablesEntity>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<List<TablesEntity>>, List<TablesEntity>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<TablesEntity>>, List<TablesEntity>>,
              AsyncValue<List<TablesEntity>>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/tables/presentation/screens/connect.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:livekit_client/livekit_client.dart';
import './prejoin.dart';
import '../widgets/text_field.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:permission_handler/permission_handler.dart';

import 'dart:async';
import '../../../../drinkks/exts.dart';

class ConnectPage extends StatefulWidget {
  //
  const ConnectPage({
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _ConnectPageState();
}

class _ConnectPageState extends State<ConnectPage> {
  //
  static const _storeKeyUri = 'uri';
  static const _storeKeyToken = 'token';
  static const _storeKeySimulcast = 'simulcast';
  static const _storeKeyAdaptiveStream = 'adaptive-stream';
  static const _storeKeyDynacast = 'dynacast';
  static const _storeKeyE2EE = 'e2ee';
  static const _storeKeySharedKey = 'shared-key';
  static const _storeKeyMultiCodec = 'multi-codec';
  static const _storeKeyPreferredCodec = 'preferred-codec';

  final _uriCtrl = TextEditingController();
  final _tokenCtrl = TextEditingController();
  final _sharedKeyCtrl = TextEditingController();
  bool _simulcast = true;
  bool _adaptiveStream = true;
  bool _dynacast = true;
  bool _busy = false;
  bool _e2ee = false;
  bool _multiCodec = false;
  String _preferredCodec = 'VP8';

  @override
  void initState() {
    super.initState();
    unawaited(_readPrefs());
    if (lkPlatformIs(PlatformType.android)) {
      unawaited(_checkPermissions());
    }
  }

  @override
  void dispose() {
    _uriCtrl.dispose();
    _tokenCtrl.dispose();
    super.dispose();
  }

  Future<void> _checkPermissions() async {
    var status = await Permission.bluetooth.request();
    if (status.isPermanentlyDenied) {
      print('Bluetooth Permission disabled');
    }

    status = await Permission.bluetoothConnect.request();
    if (status.isPermanentlyDenied) {
      print('Bluetooth Connect Permission disabled');
    }

    status = await Permission.camera.request();
    if (status.isPermanentlyDenied) {
      print('Camera Permission disabled');
    }

    status = await Permission.microphone.request();
    if (status.isPermanentlyDenied) {
      print('Microphone Permission disabled');
    }
  }

  // Read saved URL and Token
  Future<void> _readPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    _uriCtrl.text =
        const bool.hasEnvironment('URL') ? const String.fromEnvironment('URL') : prefs.getString(_storeKeyUri) ?? '';
    _tokenCtrl.text = const bool.hasEnvironment('TOKEN')
        ? const String.fromEnvironment('TOKEN')
        : prefs.getString(_storeKeyToken) ?? '';
    _sharedKeyCtrl.text = const bool.hasEnvironment('E2EEKEY')
        ? const String.fromEnvironment('E2EEKEY')
        : prefs.getString(_storeKeySharedKey) ?? '';
    setState(() {
      _simulcast = prefs.getBool(_storeKeySimulcast) ?? true;
      _adaptiveStream = prefs.getBool(_storeKeyAdaptiveStream) ?? true;
      _dynacast = prefs.getBool(_storeKeyDynacast) ?? true;
      _e2ee = prefs.getBool(_storeKeyE2EE) ?? false;
      _multiCodec = prefs.getBool(_storeKeyMultiCodec) ?? false;
      _preferredCodec = prefs.getString(_storeKeyPreferredCodec) ?? 'VP8';
    });
  }

  // Save URL and Token
  Future<void> _writePrefs() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_storeKeyUri, _uriCtrl.text);
    await prefs.setString(_storeKeyToken, _tokenCtrl.text);
    await prefs.setString(_storeKeySharedKey, _sharedKeyCtrl.text);
    await prefs.setBool(_storeKeySimulcast, _simulcast);
    await prefs.setBool(_storeKeyAdaptiveStream, _adaptiveStream);
    await prefs.setBool(_storeKeyDynacast, _dynacast);
    await prefs.setBool(_storeKeyE2EE, _e2ee);
    await prefs.setBool(_storeKeyMultiCodec, _multiCodec);
    await prefs.setString(_storeKeyPreferredCodec, _preferredCodec);
  }

  Future<void> _connect(BuildContext ctx) async {
    //
    try {
      setState(() {
        _busy = true;
      });

      // Save URL and Token for convenience
      await _writePrefs();

      print('Connecting with url: ${_uriCtrl.text}, '
          'token: ${_tokenCtrl.text}...');

      final url = _uriCtrl.text;
      final token = _tokenCtrl.text;
      final e2eeKey = _sharedKeyCtrl.text;
      if (!ctx.mounted) return;
      await Navigator.push<void>(
        ctx,
        MaterialPageRoute(
            builder: (_) => PreJoinPage(
                  args: JoinArgs(
                    url: url,
                    token: token,
                    e2ee: _e2ee,
                    e2eeKey: e2eeKey,
                    simulcast: _simulcast,
                    adaptiveStream: _adaptiveStream,
                    dynacast: _dynacast,
                    preferredCodec: _preferredCodec,
                    enableBackupVideoCodec: ['VP9', 'AV1'].contains(_preferredCodec),
                  ),
                )),
      );
    } catch (error) {
      print('Could not connect $error');
      if (!ctx.mounted) return;
      await ctx.showErrorDialog(error);
    } finally {
      setState(() {
        _busy = false;
      });
    }
  }

  void _setSimulcast(bool? value) async {
    if (value == null || _simulcast == value) return;
    setState(() {
      _simulcast = value;
    });
  }

  void _setE2EE(bool? value) async {
    if (value == null || _e2ee == value) return;
    setState(() {
      _e2ee = value;
    });
  }

  void _setAdaptiveStream(bool? value) async {
    if (value == null || _adaptiveStream == value) return;
    setState(() {
      _adaptiveStream = value;
    });
  }

  void _setDynacast(bool? value) async {
    if (value == null || _dynacast == value) return;
    setState(() {
      _dynacast = value;
    });
  }

  void _setMultiCodec(bool? value) async {
    if (value == null || _multiCodec == value) return;
    setState(() {
      _multiCodec = value;
    });
  }

  @override
  Widget build(BuildContext context) => Scaffold(
        body: Container(
          alignment: Alignment.center,
          child: SingleChildScrollView(
            child: Container(
              padding: const EdgeInsets.symmetric(
                horizontal: 20,
                vertical: 20,
              ),
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.only(bottom: 70),
                    child: SvgPicture.asset(
                      'images/logo-dark.svg',
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 25),
                    child: LKTextField(
                      label: 'Server URL',
                      ctrl: _uriCtrl,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 25),
                    child: LKTextField(
                      label: 'Token',
                      ctrl: _tokenCtrl,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 25),
                    child: LKTextField(
                      label: 'Shared Key',
                      ctrl: _sharedKeyCtrl,
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('E2EE'),
                        Switch(
                          value: _e2ee,
                          onChanged: (value) => _setE2EE(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Simulcast'),
                        Switch(
                          value: _simulcast,
                          onChanged: (value) => _setSimulcast(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Adaptive Stream'),
                        Switch(
                          value: _adaptiveStream,
                          onChanged: (value) => _setAdaptiveStream(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.only(bottom: 5),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Dynacast'),
                        Switch(
                          value: _dynacast,
                          onChanged: (value) => _setDynacast(value),
                        ),
                      ],
                    ),
                  ),
                  Padding(
                    padding: EdgeInsets.only(bottom: _multiCodec ? 5 : 25),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Multi Codec'),
                        Switch(
                          value: _multiCodec,
                          onChanged: (value) => _setMultiCodec(value),
                        ),
                      ],
                    ),
                  ),
                  if (_multiCodec)
                    Padding(
                        padding: const EdgeInsets.only(bottom: 5),
                        child: Row(mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [
                          const Text('Preferred Codec:'),
                          DropdownButton<String>(
                            value: _preferredCodec,
                            icon: const Icon(
                              Icons.arrow_drop_down,
                              color: Colors.blue,
                            ),
                            elevation: 16,
                            style: const TextStyle(color: Colors.blue),
                            underline: Container(
                              height: 2,
                              color: Colors.blueAccent,
                            ),
                            onChanged: (String? value) {
                              if (value == null) return;
                              setState(() {
                                _preferredCodec = value;
                              });
                              unawaited(_writePrefs());
                            },
                            items: ['Preferred Codec', 'AV1', 'VP9', 'VP8', 'H264', 'H265']
                                .map<DropdownMenuItem<String>>((String value) {
                              return DropdownMenuItem<String>(
                                value: value,
                                child: Text(value),
                              );
                            }).toList(),
                          )
                        ])),
                  ElevatedButton(
                    onPressed: _busy ? null : () => _connect(context),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        if (_busy)
                          const Padding(
                            padding: EdgeInsets.only(right: 10),
                            child: SizedBox(
                              height: 15,
                              width: 15,
                              child: CircularProgressIndicator(
                                color: Colors.white,
                                strokeWidth: 2,
                              ),
                            ),
                          ),
                        const Text('CONNECT'),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/screens/prejoin.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:math' as math;

import 'package:dropdown_button2/dropdown_button2.dart';
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../../../drinkks/exts.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../../drinkks/theme.dart';
import 'room.dart';

class JoinArgs {
  JoinArgs({
    required this.url,
    required this.token,
    this.e2ee = false,
    this.e2eeKey,
    this.simulcast = true,
    this.adaptiveStream = true,
    this.dynacast = true,
    this.preferredCodec = 'VP8',
    this.enableBackupVideoCodec = true,
  });
  final String url;
  final String token;
  final bool e2ee;
  final String? e2eeKey;
  final bool simulcast;
  final bool adaptiveStream;
  final bool dynacast;
  final String preferredCodec;
  final bool enableBackupVideoCodec;
}

class PreJoinPage extends StatefulWidget {
  const PreJoinPage({
    required this.args,
    super.key,
  });
  final JoinArgs args;
  @override
  State<StatefulWidget> createState() => _PreJoinPageState();
}

class _PreJoinPageState extends State<PreJoinPage> {
  static const _prefKeyEnableVideo = 'prejoin-enable-video';
  static const _prefKeyEnableAudio = 'prejoin-enable-audio';

  // Couleurs du thÃ¨me sombre
  final Color _backgroundColor = const Color(0xFF0F0F23); // Noir bleutÃ© profond
  final Color _surfaceColor = const Color(0xFF1A1A2E); // Surface lÃ©gÃ¨rement plus claire
  final Color _primaryColor = const Color(0xFF6366F1); // Indigo doux
  final Color _accentColor = const Color(0xFF8B5CF6); // Violet accent
  final Color _textPrimary = Colors.white;
  final Color _textSecondary = const Color(0xFF94A3B8); // Gris bleutÃ©
  final Color _borderColor = Colors.white.withOpacity(0.1);

  List<MediaDevice> _audioInputs = [];
  List<MediaDevice> _videoInputs = [];
  StreamSubscription? _subscription;

  bool _busy = false;
  bool _enableVideo = true;
  bool _enableAudio = true;
  LocalAudioTrack? _audioTrack;
  LocalVideoTrack? _videoTrack;

  MediaDevice? _selectedVideoDevice;
  MediaDevice? _selectedAudioDevice;
  VideoParameters _selectedVideoParameters = VideoParametersPresets.h720_169;

  // Nouvelle mÃ©thode pour vÃ©rifier et demander les permissions
  Future<bool> _checkAndRequestPermissions() async {
    Map<Permission, PermissionStatus> statuses = await [
      Permission.camera,
      Permission.microphone,
    ].request();

    bool cameraGranted = statuses[Permission.camera]?.isGranted ?? false;
    bool microphoneGranted = statuses[Permission.microphone]?.isGranted ?? false;

    if (!cameraGranted || !microphoneGranted) {
      if (mounted) {
        await showDialog(
          context: context,
          builder: (BuildContext context) => AlertDialog(
            backgroundColor: _surfaceColor,
            title: const Text(
              'Permissions requises',
              style: TextStyle(color: Colors.white),
            ),
            content: const Text(
              'L\'application a besoin des permissions camÃ©ra et microphone pour la visioconfÃ©rence. '
                  'Veuillez les activer dans les paramÃ¨tres.',
              style: TextStyle(color: Colors.white70),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                style: TextButton.styleFrom(
                  foregroundColor: _textSecondary,
                ),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
      return false;
    }
    return true;
  }

  @override
  void initState() {
    super.initState();
    unawaited(_initStateAsync());
  }

  Future<void> _initStateAsync() async {
    // VÃ©rifier les permissions avant de continuer
    bool hasPermissions = await _checkAndRequestPermissions();
    if (!hasPermissions) {
      return;
    }

    await _readPrefs();
    _subscription = Hardware.instance.onDeviceChange.stream.listen(_loadDevices);
    final devices = await Hardware.instance.enumerateDevices();
    await _loadDevices(devices);
  }

  Future<void> _loadDevices(List<MediaDevice> devices) async {
    _audioInputs = devices.where((d) => d.kind == 'audioinput').toList();
    _videoInputs = devices.where((d) => d.kind == 'videoinput').toList();

    if (_selectedAudioDevice != null && !_audioInputs.contains(_selectedAudioDevice)) {
      _selectedAudioDevice = null;
    }
    if (_audioInputs.isEmpty) {
      await _audioTrack?.stop();
      _audioTrack = null;
    }
    if (_selectedVideoDevice != null && !_videoInputs.contains(_selectedVideoDevice)) {
      _selectedVideoDevice = null;
    }
    if (_videoInputs.isEmpty) {
      await _videoTrack?.stop();
      _videoTrack = null;
    }

    if (_enableAudio && _audioInputs.isNotEmpty) {
      if (_selectedAudioDevice == null) {
        _selectedAudioDevice = _audioInputs.first;
        Future.delayed(const Duration(milliseconds: 100), () async {
          if (!mounted) return;
          await _changeLocalAudioTrack();
          if (mounted) setState(() {});
        });
      }
    }

    if (_enableVideo && _videoInputs.isNotEmpty) {
      if (_selectedVideoDevice == null) {
        _selectedVideoDevice = _videoInputs.first;
        Future.delayed(const Duration(milliseconds: 100), () async {
          if (!mounted) return;
          await _changeLocalVideoTrack();
          if (mounted) setState(() {});
        });
      }
    }
    if (mounted) setState(() {});
  }

  Future<void> _setEnableVideo(value) async {
    _enableVideo = value;
    await _writePrefs();
    if (!_enableVideo) {
      await _videoTrack?.stop();
      _videoTrack = null;
      _selectedVideoDevice = null;
    } else {
      // VÃ©rifier les permissions avant d'activer la camÃ©ra
      PermissionStatus cameraStatus = await Permission.camera.status;
      if (!cameraStatus.isGranted) {
        bool granted = await _checkAndRequestPermissions();
        if (!granted) {
          setState(() {
            _enableVideo = false;
          });
          return;
        }
      }

      if (_selectedVideoDevice == null && _videoInputs.isNotEmpty) {
        _selectedVideoDevice = _videoInputs.first;
      }
      await _changeLocalVideoTrack();
    }
    setState(() {});
  }

  Future<void> _setEnableAudio(value) async {
    _enableAudio = value;
    await _writePrefs();
    if (!_enableAudio) {
      await _audioTrack?.stop();
      _audioTrack = null;
      _selectedAudioDevice = null;
    } else {
      // VÃ©rifier les permissions avant d'activer le micro
      PermissionStatus microphoneStatus = await Permission.microphone.status;
      if (!microphoneStatus.isGranted) {
        bool granted = await _checkAndRequestPermissions();
        if (!granted) {
          setState(() {
            _enableAudio = false;
          });
          return;
        }
      }

      if (_selectedAudioDevice == null && _audioInputs.isNotEmpty) {
        _selectedAudioDevice = _audioInputs.first;
      }
      await _changeLocalAudioTrack();
    }
    setState(() {});
  }

  Future<void> _changeLocalAudioTrack() async {
    if (!_enableAudio) return;
    try {
      if (_audioTrack != null) {
        await _audioTrack!.stop();
        _audioTrack = null;
      }

      if (_selectedAudioDevice != null) {
        _audioTrack = await LocalAudioTrack.create(
          AudioCaptureOptions(
            deviceId: _selectedAudioDevice!.deviceId,
          ),
        );
        await _audioTrack!.start();
      }
    } catch (e) {
      print('Erreur lors de la crÃ©ation du track audio: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erreur audio: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  Future<void> _changeLocalVideoTrack() async {
    if (!_enableVideo) return;
    try {
      if (_videoTrack != null) {
        await _videoTrack!.stop();
        _videoTrack = null;
      }

      if (_selectedVideoDevice != null) {
        _videoTrack = await LocalVideoTrack.createCameraTrack(CameraCaptureOptions(
          deviceId: _selectedVideoDevice!.deviceId,
          params: _selectedVideoParameters,
        ));
        await _videoTrack!.start();
      }
    } catch (e) {
      print('Erreur lors de la crÃ©ation du track vidÃ©o: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Erreur vidÃ©o: $e'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
        // DÃ©sactiver la vidÃ©o en cas d'erreur
        setState(() {
          _enableVideo = false;
        });
      }
    }
  }

  @override
  void dispose() {
    unawaited(_subscription?.cancel());
    super.dispose();
  }

  _join(BuildContext context) async {
    _busy = true;

    setState(() {});

    final args = widget.args;

    try {
      // VÃ©rifier les permissions avant de rejoindre
      bool hasPermissions = await _checkAndRequestPermissions();
      if (!hasPermissions) {
        setState(() {
          _busy = false;
        });
        return;
      }

      //create new room
      const cameraEncoding = VideoEncoding(
        maxBitrate: 5 * 1000 * 1000,
        maxFramerate: 30,
      );

      const screenEncoding = VideoEncoding(
        maxBitrate: 3 * 1000 * 1000,
        maxFramerate: 15,
      );

      E2EEOptions? e2eeOptions;
      if (args.e2ee && args.e2eeKey != null) {
        final keyProvider = await BaseKeyProvider.create();
        e2eeOptions = E2EEOptions(keyProvider: keyProvider);
        await keyProvider.setKey(args.e2eeKey!);
      }

      final room = Room(
        roomOptions: RoomOptions(
          adaptiveStream: args.adaptiveStream,
          dynacast: args.dynacast,
          defaultAudioPublishOptions: const AudioPublishOptions(
            name: 'custom_audio_track_name',
          ),
          defaultCameraCaptureOptions: const CameraCaptureOptions(
              maxFrameRate: 30,
              params: VideoParameters(
                dimensions: VideoDimensions(1280, 720),
              )),
          defaultScreenShareCaptureOptions: const ScreenShareCaptureOptions(
              useiOSBroadcastExtension: true,
              params: VideoParameters(
                dimensions: VideoDimensionsPresets.h1080_169,
              )),
          defaultVideoPublishOptions: VideoPublishOptions(
            simulcast: args.simulcast,
            videoCodec: args.preferredCodec,
            backupVideoCodec: BackupVideoCodec(
              enabled: args.enableBackupVideoCodec,
            ),
            videoEncoding: cameraEncoding,
            screenShareEncoding: screenEncoding,
          ),
          encryption: e2eeOptions,
        ),
      );
      // Create a Listener before connecting
      final listener = room.createListener();

      await room.prepareConnection(args.url, args.token);

      // Try to connect to the room
      // This will throw an Exception if it fails for any reason.
      await room.connect(
        args.url,
        args.token,
        fastConnectOptions: FastConnectOptions(
          microphone: TrackOption(track: _audioTrack),
          camera: TrackOption(track: _videoTrack),
        ),
      );

      if (!context.mounted) return;
      await Navigator.push<void>(
        context,
        MaterialPageRoute(builder: (_) => RoomPage(room, listener)),
      );
    } catch (error) {
      print('Could not connect $error');
      if (!context.mounted) return;
      await context.showErrorDialog(error);
    } finally {
      setState(() {
        _busy = false;
      });
    }
  }

  void _actionBack(BuildContext context) async {
    await _setEnableVideo(false);
    await _setEnableAudio(false);
    if (!context.mounted) return;
    Navigator.of(context).pop();
  }

  Future<void> _readPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _enableVideo = prefs.getBool(_prefKeyEnableVideo) ?? true;
      _enableAudio = prefs.getBool(_prefKeyEnableAudio) ?? true;
    });
  }

  Future<void> _writePrefs() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_prefKeyEnableVideo, _enableVideo);
    await prefs.setBool(_prefKeyEnableAudio, _enableAudio);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: _backgroundColor,
      appBar: AppBar(
        backgroundColor: _surfaceColor,
        elevation: 0,
        title: const Text(
          'Configuration',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w600,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white),
          onPressed: () => _actionBack(context),
        ),
      ),
      body: Container(
        alignment: Alignment.center,
        child: SingleChildScrollView(
          child: Container(
            padding: const EdgeInsets.symmetric(
              horizontal: 20,
              vertical: 20,
            ),
            constraints: const BoxConstraints(maxWidth: 400),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // AperÃ§u vidÃ©o
                Padding(
                  padding: const EdgeInsets.only(bottom: 20),
                  child: Container(
                    width: 320,
                    height: 240,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(16),
                      border: Border.all(
                        color: _borderColor,
                        width: 1,
                      ),
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(15),
                      child: Container(
                        color: _surfaceColor,
                        child: _videoTrack != null
                            ? VideoTrackRenderer(
                          renderMode: VideoRenderMode.auto,
                          _videoTrack!,
                        )
                            : Container(
                          alignment: Alignment.center,
                          child: LayoutBuilder(
                            builder: (ctx, constraints) => Icon(
                              Icons.videocam_off,
                              color: _primaryColor.withOpacity(0.5),
                              size: math.min(constraints.maxHeight, constraints.maxWidth) * 0.3,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                // Section CamÃ©ra
                Container(
                  margin: const EdgeInsets.only(bottom: 16),
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: _surfaceColor,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: _borderColor,
                      width: 1,
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'CamÃ©ra',
                            style: TextStyle(
                              color: _textPrimary,
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          Switch(
                            value: _enableVideo,
                            onChanged: (value) => _setEnableVideo(value),
                            activeColor: _primaryColor,
                            activeTrackColor: _primaryColor.withOpacity(0.3),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_enableVideo) ...[
                        DropdownButtonHideUnderline(
                          child: DropdownButton2<MediaDevice>(
                            isExpanded: true,
                            hint: Text(
                              'SÃ©lectionner une camÃ©ra',
                              style: TextStyle(color: _textSecondary),
                            ),
                            items: _videoInputs
                                .map((MediaDevice item) => DropdownMenuItem<MediaDevice>(
                              value: item,
                              child: Text(
                                item.label,
                                style: TextStyle(
                                  fontSize: 14,
                                  color: _textPrimary,
                                ),
                              ),
                            ))
                                .toList(),
                            value: _selectedVideoDevice,
                            onChanged: (MediaDevice? value) async {
                              if (value != null) {
                                _selectedVideoDevice = value;
                                await _changeLocalVideoTrack();
                                setState(() {});
                              }
                            },
                            buttonStyleData: ButtonStyleData(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              height: 48,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                border: Border.all(color: _borderColor),
                                color: _backgroundColor,
                              ),
                            ),
                            menuItemStyleData: const MenuItemStyleData(
                              height: 48,
                            ),
                            dropdownStyleData: DropdownStyleData(
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: _surfaceColor,
                                border: Border.all(color: _borderColor),
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(height: 12),
                        DropdownButtonHideUnderline(
                          child: DropdownButton2<VideoParameters>(
                            isExpanded: true,
                            hint: Text(
                              'RÃ©solution vidÃ©o',
                              style: TextStyle(color: _textSecondary),
                            ),
                            items: [
                              VideoParametersPresets.h480_43,
                              VideoParametersPresets.h540_169,
                              VideoParametersPresets.h720_169,
                              VideoParametersPresets.h1080_169,
                            ]
                                .map((VideoParameters item) => DropdownMenuItem<VideoParameters>(
                              value: item,
                              child: Text(
                                '${item.dimensions.width}x${item.dimensions.height}',
                                style: TextStyle(
                                  fontSize: 14,
                                  color: _textPrimary,
                                ),
                              ),
                            ))
                                .toList(),
                            value: _selectedVideoParameters,
                            onChanged: (VideoParameters? value) async {
                              if (value != null) {
                                _selectedVideoParameters = value;
                                await _changeLocalVideoTrack();
                                setState(() {});
                              }
                            },
                            buttonStyleData: ButtonStyleData(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              height: 48,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                border: Border.all(color: _borderColor),
                                color: _backgroundColor,
                              ),
                            ),
                            menuItemStyleData: const MenuItemStyleData(
                              height: 48,
                            ),
                            dropdownStyleData: DropdownStyleData(
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: _surfaceColor,
                                border: Border.all(color: _borderColor),
                              ),
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ),

                // Section Microphone
                Container(
                  margin: const EdgeInsets.only(bottom: 24),
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: _surfaceColor,
                    borderRadius: BorderRadius.circular(16),
                    border: Border.all(
                      color: _borderColor,
                      width: 1,
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            'Microphone',
                            style: TextStyle(
                              color: _textPrimary,
                              fontSize: 16,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          Switch(
                            value: _enableAudio,
                            onChanged: (value) => _setEnableAudio(value),
                            activeColor: _primaryColor,
                            activeTrackColor: _primaryColor.withOpacity(0.3),
                          ),
                        ],
                      ),
                      const SizedBox(height: 12),
                      if (_enableAudio)
                        DropdownButtonHideUnderline(
                          child: DropdownButton2<MediaDevice>(
                            isExpanded: true,
                            hint: Text(
                              'SÃ©lectionner un microphone',
                              style: TextStyle(color: _textSecondary),
                            ),
                            items: _audioInputs
                                .map((MediaDevice item) => DropdownMenuItem<MediaDevice>(
                              value: item,
                              child: Text(
                                item.label,
                                style: TextStyle(
                                  fontSize: 14,
                                  color: _textPrimary,
                                ),
                              ),
                            ))
                                .toList(),
                            value: _selectedAudioDevice,
                            onChanged: (MediaDevice? value) async {
                              if (value != null) {
                                _selectedAudioDevice = value;
                                await _changeLocalAudioTrack();
                                setState(() {});
                              }
                            },
                            buttonStyleData: ButtonStyleData(
                              padding: const EdgeInsets.symmetric(horizontal: 16),
                              height: 48,
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                border: Border.all(color: _borderColor),
                                color: _backgroundColor,
                              ),
                            ),
                            menuItemStyleData: const MenuItemStyleData(
                              height: 48,
                            ),
                            dropdownStyleData: DropdownStyleData(
                              decoration: BoxDecoration(
                                borderRadius: BorderRadius.circular(12),
                                color: _surfaceColor,
                                border: Border.all(color: _borderColor),
                              ),
                            ),
                          ),
                        ),
                    ],
                  ),
                ),

                // Bouton Rejoindre
                ElevatedButton(
                  onPressed: _busy ? null : () => _join(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _primaryColor,
                    foregroundColor: Colors.white,
                    minimumSize: const Size(double.infinity, 54),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                    elevation: 0,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      if (_busy)
                        Padding(
                          padding: const EdgeInsets.only(right: 10),
                          child: SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              color: Colors.white,
                              strokeWidth: 2,
                            ),
                          ),
                        ),
                      Text(
                        _busy ? 'Connexion...' : 'Rejoindre la conversation',
                        style: const TextStyle(
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}


FICHIER: flutter_lib/features/tables/presentation/screens/room.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:convert';
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';

import '../../../../drinkks/exts.dart';
import '../../../../drinkks/utils.dart';
import '../widgets/controls.dart';
import '../widgets/participant.dart';
import '../widgets/participant_info.dart';

class RoomPage extends StatefulWidget {
  final Room room;
  final EventsListener<RoomEvent> listener;

  const RoomPage(
      this.room,
      this.listener, {
        super.key,
      });

  @override
  State<StatefulWidget> createState() => _RoomPageState();
}

class _RoomPageState extends State<RoomPage> {
  // Couleurs du thÃ¨me sombre
  final Color _backgroundColor = const Color(0xFF0F0F23); // Noir bleutÃ© profond
  final Color _surfaceColor = const Color(0xFF1A1A2E); // Surface lÃ©gÃ¨rement plus claire
  final Color _primaryColor = const Color(0xFF6366F1); // Indigo doux
  final Color _accentColor = const Color(0xFF8B5CF6); // Violet accent
  final Color _textPrimary = Colors.white;
  final Color _textSecondary = const Color(0xFF94A3B8); // Gris bleutÃ©
  final Color _borderColor = Colors.white.withOpacity(0.1);

  List<ParticipantTrack> participantTracks = [];
  EventsListener<RoomEvent> get _listener => widget.listener;
  bool get fastConnection => widget.room.engine.fastConnectOptions != null;

  @override
  void initState() {
    super.initState();
    // add callback for a `RoomEvent` as opposed to a `ParticipantEvent`
    widget.room.addListener(_onRoomDidUpdate);
    // add callbacks for finer grained events
    _setUpListeners();
    _sortParticipants();
    WidgetsBindingCompatible.instance?.addPostFrameCallback((_) {
      if (!fastConnection) {
        _askPublish();
      }
    });

    if (lkPlatformIs(PlatformType.android)) {
      unawaited(Hardware.instance.setSpeakerphoneOn(true));
    }

    if (lkPlatformIsDesktop()) {
      onWindowShouldClose = () async {
        unawaited(widget.room.disconnect());
        await _listener.waitFor<RoomDisconnectedEvent>(duration: const Duration(seconds: 5));
      };
    }
  }

  @override
  void dispose() {
    // always dispose listener
    widget.room.removeListener(_onRoomDidUpdate);
    unawaited(_disposeRoomAsync());
    onWindowShouldClose = null;
    super.dispose();
  }

  Future<void> _disposeRoomAsync() async {
    await _listener.dispose();
    await widget.room.dispose();
  }

  /// for more information, see [event types](https://docs.livekit.io/client/events/#events)
  void _setUpListeners() => _listener
    ..on<RoomDisconnectedEvent>((event) async {
      if (event.reason != null) {
        print('Room disconnected: reason => ${event.reason}');
      }
      WidgetsBindingCompatible.instance
          ?.addPostFrameCallback((timeStamp) => Navigator.popUntil(context, (route) => route.isFirst));
    })
    ..on<ParticipantEvent>((event) {
      // sort participants on many track events as noted in documentation linked above
      _sortParticipants();
    })
    ..on<RoomRecordingStatusChanged>((event) {
      unawaited(context.showRecordingStatusChangedDialog(event.activeRecording));
    })
    ..on<RoomAttemptReconnectEvent>((event) {
      print('Attempting to reconnect ${event.attempt}/${event.maxAttemptsRetry}, '
          '(${event.nextRetryDelaysInMs}ms delay until next attempt)');
    })
    ..on<LocalTrackSubscribedEvent>((event) {
      print('Local track subscribed: ${event.trackSid}');
    })
    ..on<LocalTrackPublishedEvent>((_) => _sortParticipants())
    ..on<LocalTrackUnpublishedEvent>((_) => _sortParticipants())
    ..on<TrackSubscribedEvent>((_) => _sortParticipants())
    ..on<TrackUnsubscribedEvent>((_) => _sortParticipants())
    ..on<TrackE2EEStateEvent>(_onE2EEStateEvent)
    ..on<ParticipantNameUpdatedEvent>((event) {
      print('Participant name updated: ${event.participant.identity}, name => ${event.name}');
      _sortParticipants();
    })
    ..on<ParticipantMetadataUpdatedEvent>((event) {
      print('Participant metadata updated: ${event.participant.identity}, metadata => ${event.metadata}');
    })
    ..on<RoomMetadataChangedEvent>((event) {
      print('Room metadata changed: ${event.metadata}');
    })
    ..on<DataReceivedEvent>((event) {
      String decoded = 'Failed to decode';
      try {
        decoded = utf8.decode(event.data);
      } catch (err) {
        print('Failed to decode: $err');
      }
      unawaited(context.showDataReceivedDialog(decoded));
    })
    ..on<AudioPlaybackStatusChanged>((event) async {
      if (!widget.room.canPlaybackAudio) {
        print('Audio playback failed for iOS Safari ..........');
        final yesno = await context.showPlayAudioManuallyDialog();
        if (yesno == true) {
          await widget.room.startAudio();
        }
      }
    });

  void _askPublish() async {
    final result = await context.showPublishDialog();
    if (!mounted) return;
    if (result != true) return;
    // video will fail when running in ios simulator
    try {
      await widget.room.localParticipant?.setCameraEnabled(true);
    } catch (error) {
      print('could not publish video: $error');
      if (!mounted) return;
      await context.showErrorDialog(error);
    }
    try {
      await widget.room.localParticipant?.setMicrophoneEnabled(true);
    } catch (error) {
      print('could not publish audio: $error');
      if (!mounted) return;
      await context.showErrorDialog(error);
    }
  }

  void _onRoomDidUpdate() {
    _sortParticipants();
  }

  void _onE2EEStateEvent(TrackE2EEStateEvent e2eeState) {
    print('e2ee state: $e2eeState');
  }

  void _sortParticipants() {
    final userMediaTracks = <ParticipantTrack>[];
    final screenTracks = <ParticipantTrack>[];
    for (var participant in widget.room.remoteParticipants.values) {
      for (var t in participant.videoTrackPublications) {
        if (t.isScreenShare) {
          screenTracks.add(ParticipantTrack(
            participant: participant,
            type: ParticipantTrackType.kScreenShare,
          ));
        } else {
          userMediaTracks.add(ParticipantTrack(participant: participant));
        }
      }
    }
    // sort speakers for the grid
    userMediaTracks.sort((a, b) {
      // loudest speaker first
      if (a.participant.isSpeaking && b.participant.isSpeaking) {
        if (a.participant.audioLevel > b.participant.audioLevel) {
          return -1;
        } else {
          return 1;
        }
      }

      // last spoken at
      final aSpokeAt = a.participant.lastSpokeAt?.millisecondsSinceEpoch ?? 0;
      final bSpokeAt = b.participant.lastSpokeAt?.millisecondsSinceEpoch ?? 0;

      if (aSpokeAt != bSpokeAt) {
        return aSpokeAt > bSpokeAt ? -1 : 1;
      }

      // video on
      if (a.participant.hasVideo != b.participant.hasVideo) {
        return a.participant.hasVideo ? -1 : 1;
      }

      // joinedAt
      return a.participant.joinedAt.millisecondsSinceEpoch - b.participant.joinedAt.millisecondsSinceEpoch;
    });

    final localParticipantTracks = widget.room.localParticipant?.videoTrackPublications;
    if (localParticipantTracks != null) {
      for (var t in localParticipantTracks) {
        if (t.isScreenShare) {
          screenTracks.add(ParticipantTrack(
            participant: widget.room.localParticipant!,
            type: ParticipantTrackType.kScreenShare,
          ));
        } else {
          userMediaTracks.add(ParticipantTrack(participant: widget.room.localParticipant!));
        }
      }
    }
    setState(() {
      participantTracks = [...screenTracks, ...userMediaTracks];
    });
  }

  @override
  Widget build(BuildContext context) => Scaffold(
    backgroundColor: _backgroundColor,
    body: Stack(
      children: [
        // Participant principal
        Container(
          color: _backgroundColor,
          child: Column(
            children: [
              Expanded(
                child: Container(
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: _borderColor,
                      width: 0.5,
                    ),
                  ),
                  child: participantTracks.isNotEmpty
                      ? ParticipantWidget.widgetFor(
                    participantTracks.first,
                    showStatsLayer: true,
                  )
                      : _buildEmptyParticipant(),
                ),
              ),
              if (widget.room.localParticipant != null)
                SafeArea(
                  top: false,
                  child: ControlsWidget(
                    widget.room,
                    widget.room.localParticipant!,
                  ),
                )
            ],
          ),
        ),

        // Miniatures des autres participants
        Positioned(
          left: 0,
          right: 0,
          top: 0,
          child: Container(
            height: 140,
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [
                  _backgroundColor.withOpacity(0.9),
                  _backgroundColor.withOpacity(0.0),
                ],
              ),
            ),
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
              itemCount: math.max(0, participantTracks.length - 1),
              itemBuilder: (BuildContext context, int index) {
                return Container(
                  width: 180,
                  height: 120,
                  margin: const EdgeInsets.only(right: 8),
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: _borderColor,
                      width: 1,
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.3),
                        blurRadius: 8,
                        offset: const Offset(0, 2),
                      ),
                    ],
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(11),
                    child: ParticipantWidget.widgetFor(participantTracks[index + 1]),
                  ),
                );
              },
            ),
          ),
        ),
      ],
    ),
  );

  Widget _buildEmptyParticipant() {
    return Container(
      color: _surfaceColor,
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: LinearGradient(
                  colors: [
                    _primaryColor.withOpacity(0.2),
                    _accentColor.withOpacity(0.2),
                  ],
                ),
              ),
              child: Icon(
                Icons.videocam_off,
                size: 40,
                color: _primaryColor.withOpacity(0.5),
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'En attente de participants...',
              style: TextStyle(
                color: _textSecondary,
                fontSize: 16,
              ),
            ),
          ],
        ),
      ),
    );
  }
}


FICHIER: flutter_lib/features/tables/presentation/screens/tables_screen.dart
--------------------------------------------------------------------------------
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:dio/dio.dart';
import '../../../../services/api_service.dart';
import '../controllers/tables_controller.dart';
import 'prejoin.dart';

class TablesScreen extends ConsumerWidget {
  final String venueId;
  final Dio _dio = Dio(); // Ã€ idÃ©alement injecter via un provider

  TablesScreen({
    super.key,
    required this.venueId,
  });

  // MÃ©thode pour gÃ©nÃ©rer le token LiveKit
  Future<void> _generateLiveKitToken(BuildContext context, WidgetRef ref, Map<String, dynamic> table) async {
    try {
      // Appel via le controller qui utilise le service
      final tokenData = await ref.read(tablesControllerProvider.notifier).generateTokenForTable(table);

      if (tokenData == null) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Impossible de gÃ©nÃ©rer le token de connexion'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      // Navigation vers la page de prÃ©-join
      if (context.mounted) {
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (_) => PreJoinPage(
              args: JoinArgs(
                url: tokenData['server_url'],
                token: tokenData['participant_token'],
                e2ee: false,
                e2eeKey: null,
                simulcast: true,
                adaptiveStream: true,
                dynacast: true,
                preferredCodec: 'VP8',
                enableBackupVideoCodec: true,
              ),
            ),
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        String errorMessage = 'Erreur de connexion';
        if (e is ApiException) {
          errorMessage = e.message;
        }

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final tablesState = ref.watch(tablesControllerProvider);

    const backgroundColor = Color(0xFF0F0F23);
    const primaryColor = Color(0xFF6366F1);
    const secondaryColor = Color(0xFF8B5CF6);
    const textPrimary = Colors.white;
    const occupiedColor = Color(0xFF10B981);
    const emptyColor = Color(0xFF6B7280);
    const barColor = Color(0xFF8B4513); // Couleur bois du bar

    // DonnÃ©es statiques pour les tables
    final tablesData = [
      {
        'id': '1',
        'name': 'Table du Coin',
        'occupiedSeats': 3,
        'totalSeats': 4,
      },
      {
        'id': '2',
        'name': 'Table du Milieu',
        'occupiedSeats': 1,
        'totalSeats': 4,
      },
      {
        'id': '3',
        'name': 'Table VIP',
        'occupiedSeats': 4,
        'totalSeats': 4,
      },
      {
        'id': '4',
        'name': 'Table FenÃªtre',
        'occupiedSeats': 0,
        'totalSeats': 4,
      },
      {
        'id': '5',
        'name': 'Table Bar',
        'occupiedSeats': 2,
        'totalSeats': 4,
      },
      {
        'id': '6',
        'name': 'Table Intime',
        'occupiedSeats': 3,
        'totalSeats': 4,
      },
    ];

    return Scaffold(
      backgroundColor: backgroundColor,
      body: SafeArea(
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                backgroundColor.withOpacity(0.9),
                Color(0xFF1A1A2E),
              ],
            ),
          ),
          child: Stack(
            children: [
              // Effet d'Ã©toiles en arriÃ¨re-plan
              Positioned.fill(
                child: CustomPaint(
                  painter: _StarsPainter(),
                ),
              ),

              Column(
                children: [
                  // AppBar personnalisÃ©e
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.05),
                      border: Border(
                        bottom: BorderSide(color: Colors.white.withOpacity(0.1)),
                      ),
                    ),
                    child: Row(
                      children: [
                        IconButton(
                          icon: const Icon(Icons.arrow_back, color: textPrimary),
                          onPressed: () {
                            Navigator.pop(context);
                          },
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Le Lounge Ã‰toilÃ©',
                                style: TextStyle(
                                  color: textPrimary,
                                  fontSize: 20,
                                  fontWeight: FontWeight.bold,
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                              Text(
                                'Ambiance feutrÃ©e â€¢ Jazz doux',
                                style: TextStyle(
                                  color: textPrimary.withOpacity(0.6),
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ),
                        Container(
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                          decoration: BoxDecoration(
                            color: primaryColor.withOpacity(0.2),
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(color: primaryColor.withOpacity(0.3)),
                          ),
                          child: Text(
                            '${tablesData.length} tables',
                            style: TextStyle(
                              color: textPrimary,
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),

                  // LÃ©gende avec option pour le bar
                  Container(
                    padding: const EdgeInsets.all(12),
                    margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.03),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceAround,
                      children: [
                        _buildLegendItem(
                          color: occupiedColor,
                          label: 'OccupÃ©',
                          icon: Icons.person,
                        ),
                        _buildLegendItem(
                          color: emptyColor,
                          label: 'Libre',
                          icon: Icons.person_outline,
                        ),
                        _buildLegendItem(
                          color: barColor,
                          label: 'Bar',
                          icon: Icons.local_bar,
                        ),
                      ],
                    ),
                  ),

                  // Contenu principal avec le bar au centre
                  Expanded(
                    child: Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16.0),
                      child: CustomScrollView(
                        slivers: [
                          // Sliver pour les tables (premiÃ¨re rangÃ©e)
                          SliverGrid(
                            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                              crossAxisCount: 2,
                              crossAxisSpacing: 16,
                              mainAxisSpacing: 24,
                              childAspectRatio: 1,
                            ),
                            delegate: SliverChildBuilderDelegate(
                                  (context, index) {
                                if (index < 2) {
                                  final table = tablesData[index];
                                  return _buildTableCard(
                                    table,
                                    occupiedColor,
                                    emptyColor,
                                    primaryColor,
                                    textPrimary,
                                    onTap: () {
                                      final isFull = (table['occupiedSeats'] as int) == (table['totalSeats'] as int);
                                      if (!isFull) {
                                        _generateLiveKitToken(context, ref, table);
                                      }
                                    },
                                  );
                                }
                                return null;
                              },
                              childCount: 2,
                            ),
                          ),

                          // // Sliver pour le bar central
                          // SliverToBoxAdapter(
                          //   child: Container(
                          //     height: 180,
                          //     margin: const EdgeInsets.symmetric(vertical: 20),
                          //     child: _buildBarIsland(  // â† Ici, il faut appeler la fonction
                          //       barColor,
                          //       primaryColor,
                          //       textPrimary,
                          //     ),
                          //   ),
                          // ),

                          // Sliver pour les autres tables
                          SliverGrid(
                            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                              crossAxisCount: 2,
                              crossAxisSpacing: 16,
                              mainAxisSpacing: 24,
                              childAspectRatio: 1,
                            ),
                            delegate: SliverChildBuilderDelegate(
                                  (context, index) {
                                if (index < tablesData.length - 2) {
                                  final table = tablesData[index + 2];
                                  return _buildTableCard(
                                    table,
                                    occupiedColor,
                                    emptyColor,
                                    primaryColor,
                                    textPrimary,
                                    onTap: () {
                                      final isFull = (table['occupiedSeats'] as int) == (table['totalSeats'] as int);
                                      if (!isFull) {
                                        _generateLiveKitToken(context, ref, table);
                                      }
                                    },
                                  );
                                }
                                return null;
                              },
                              childCount: tablesData.length - 2,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildLegendItem({
    required Color color,
    required String label,
    required IconData icon,
  }) {
    return Row(
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: color,
            shape: BoxShape.circle,
          ),
        ),
        const SizedBox(width: 6),
        Icon(icon, color: color, size: 14),
        const SizedBox(width: 4),
        Text(
          label,
          style: TextStyle(
            color: Colors.white.withOpacity(0.7),
            fontSize: 11,
          ),
        ),
      ],
    );
  }

  Widget _buildBarIsland(Color barColor, Color primaryColor, Color textPrimary) {
    return InkWell(
      onTap: () {
        // Lancer une visio avec le barman
        print('DÃ©marrer une visio avec le barman');
      },
      borderRadius: BorderRadius.circular(20),
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.all(16.0),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(20),
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              barColor.withOpacity(0.8),
              barColor.withOpacity(0.6),
            ],
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.4),
              blurRadius: 15,
              offset: const Offset(0, 5),
            ),
          ],
          border: Border.all(
            color: Colors.amber.withOpacity(0.5),
            width: 2,
          ),
        ),
        child: Stack(
          children: [
            // Effet de bois en arriÃ¨re-plan
            Positioned.fill(
              child: ClipRRect(
                borderRadius: BorderRadius.circular(20),
                child: CustomPaint(
                  painter: _WoodGrainPainter(),
                ),
              ),
            ),

            // Contenu principal Ã  gauche
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Avatar et informations du barman
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Avatar et nom sur la mÃªme ligne
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          // Avatar du barman
                          Container(
                            width: 60,
                            height: 60,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              border: Border.all(
                                color: Colors.white.withOpacity(0.3),
                                width: 2,
                              ),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.3),
                                  blurRadius: 8,
                                  offset: const Offset(0, 3),
                                ),
                              ],
                            ),
                            child: Stack(
                              alignment: Alignment.center,
                              children: [
                                // Avatar
                                Container(
                                  width: 54,
                                  height: 54,
                                  decoration: BoxDecoration(
                                    shape: BoxShape.circle,
                                    color: Color(0xFF2D3748),
                                    border: Border.all(
                                      color: Colors.amber,
                                      width: 1.5,
                                    ),
                                  ),
                                  child: const Icon(
                                    Icons.person,
                                    color: Colors.white,
                                    size: 32,
                                  ),
                                ),

                                // Badge "En ligne"
                                Positioned(
                                  bottom: 2,
                                  right: 2,
                                  child: Container(
                                    width: 16,
                                    height: 16,
                                    decoration: BoxDecoration(
                                      shape: BoxShape.circle,
                                      color: Colors.green,
                                      border: Border.all(
                                        color: Colors.white,
                                        width: 1.5,
                                      ),
                                    ),
                                    child: const Icon(
                                      Icons.check,
                                      color: Colors.white,
                                      size: 10,
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),

                          const SizedBox(width: 12),

                          // Nom et description
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  'Marc, le Barman',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                    shadows: [
                                      Shadow(
                                        color: Colors.black.withOpacity(0.5),
                                        blurRadius: 3,
                                        offset: const Offset(0, 1),
                                      ),
                                    ],
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow.ellipsis,
                                ),

                                const SizedBox(height: 4),

                                Text(
                                  'SpÃ©cialiste cocktails â€¢ Disponible',
                                  style: TextStyle(
                                    color: Colors.white.withOpacity(0.9),
                                    fontSize: 12,
                                    fontStyle: FontStyle.italic,
                                  ),
                                  maxLines: 2,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),

                      const SizedBox(height: 12),

                      // Compteur de personnes au bar
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.3),
                          borderRadius: BorderRadius.circular(10),
                          border: Border.all(
                            color: Colors.amber.withOpacity(0.2),
                            width: 1,
                          ),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.group,
                              color: Colors.amber,
                              size: 14,
                            ),
                            const SizedBox(width: 6),
                            Text(
                              '3 personnes au bar',
                              style: TextStyle(
                                color: Colors.white.withOpacity(0.9),
                                fontSize: 12,
                              ),
                            ),
                          ],
                        ),
                      ),

                      // IcÃ´nes de bouteilles (optionnel)
                      const SizedBox(height: 12),
                      Row(
                        children: [
                          _buildBottleIcon(Icons.local_drink, Colors.blue.withOpacity(0.8), 24),
                          const SizedBox(width: 8),
                          _buildBottleIcon(Icons.wine_bar, Colors.red.withOpacity(0.8), 24),
                          const SizedBox(width: 8),
                          _buildBottleIcon(Icons.local_drink, Colors.green.withOpacity(0.8), 24),
                          const SizedBox(width: 8),
                          _buildBottleIcon(Icons.local_drink, Colors.purple.withOpacity(0.8), 24),
                        ],
                      ),
                    ],
                  ),
                ),

                // Bouton "Discuter" Ã  droite
                Padding(
                  padding: const EdgeInsets.only(left: 16.0),
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.start,
                    children: [
                      Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.amber.shade600,
                              Colors.orange.shade600,
                            ],
                          ),
                          borderRadius: BorderRadius.circular(20),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withOpacity(0.3),
                              blurRadius: 8,
                              offset: const Offset(0, 3),
                            ),
                            BoxShadow(
                              color: Colors.orange.withOpacity(0.4),
                              blurRadius: 6,
                              spreadRadius: 1,
                            ),
                          ],
                          border: Border.all(
                            color: Colors.white.withOpacity(0.3),
                            width: 1,
                          ),
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.video_call,
                              color: Colors.white,
                              size: 24,
                            ),
                            const SizedBox(height: 6),
                            Text(
                              'Discuter',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                                fontWeight: FontWeight.w600,
                                shadows: [
                                  Shadow(
                                    color: Colors.black.withOpacity(0.3),
                                    blurRadius: 2,
                                    offset: const Offset(0, 1),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),

                      // Petite indication (optionnel)
                      Container(
                        margin: const EdgeInsets.only(top: 8),
                        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.2),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Text(
                          '1:1',
                          style: TextStyle(
                            color: Colors.white.withOpacity(0.7),
                            fontSize: 10,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildBottleIcon(IconData icon, Color color, double size) {
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: color.withOpacity(0.2),
        borderRadius: BorderRadius.circular(6),
        border: Border.all(
          color: color.withOpacity(0.6),
          width: 1.5,
        ),
      ),
      child: Icon(
        icon,
        color: color,
        size: size * 0.6,
      ),
    );
  }


  Widget _buildTableCard(
      Map<String, dynamic> table,
      Color occupiedColor,
      Color emptyColor,
      Color primaryColor,
      Color textPrimary, {
        required VoidCallback onTap,
      }) {
    final occupiedSeats = table['occupiedSeats'] as int;
    final totalSeats = table['totalSeats'] as int;
    final isFull = occupiedSeats == totalSeats;
    final availableSeats = totalSeats - occupiedSeats;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Carte de la table
        Expanded(
          child: InkWell(
            onTap: isFull ? null : onTap,
            borderRadius: BorderRadius.circular(16),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              color: Colors.white.withOpacity(0.05),
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(
                    color: isFull ? Colors.red.withOpacity(0.3) : primaryColor.withOpacity(0.3),
                    width: 1,
                  ),
                ),
                child: Stack(
                  children: [
                    // SVG de la table au centre
                    Center(
                      child: SvgPicture.string(
                        '''
                        <svg width="80" height="80" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                          <!-- Plateau de table -->
                          <circle cx="50" cy="50" r="35" fill="#2D3748" stroke="#4A5568" stroke-width="2"/>

                          <!-- Pied de table -->
                          <rect x="48" y="70" width="4" height="20" fill="#4A5568" rx="2"/>

                          <!-- DÃ©tails du plateau -->
                          <circle cx="50" cy="50" r="30" fill="none" stroke="#6366F1" stroke-width="1" stroke-dasharray="4 4"/>
                        </svg>
                        ''',
                        width: 80,
                        height: 80,
                      ),
                    ),

                    // Places autour de la table
                    Positioned.fill(
                      child: _buildSeats(
                        occupiedSeats,
                        totalSeats,
                        occupiedColor,
                        emptyColor,
                      ),
                    ),

                    // Badge des places disponibles (en bas Ã  droite)
                    Positioned(
                      bottom: 8,
                      right: 8,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 2, vertical: 1),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(
                              Icons.chair,
                              color: isFull ? Colors.red : primaryColor,
                              size: 10,
                            ),
                            const SizedBox(width: 4),
                            Text(
                              '$availableSeats',
                              style: TextStyle(
                                color: isFull ? Colors.redAccent : primaryColor,
                                fontSize: 10,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),

                    // IcÃ´ne de verre (si occupÃ©) - en haut Ã  gauche
                    if (occupiedSeats > 0)
                      Positioned(
                        top: 4,
                        left: 4,
                        child: Container(
                          padding: const EdgeInsets.all(6),
                          child: Icon(
                            Icons.local_drink,
                            color: Colors.amber,
                            size: 16,
                          ),
                        ),
                      ),

                    // Indicateur "Complet" au centre de la table
                    if (isFull)
                      Center(
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: Colors.red.withOpacity(0.9),
                            borderRadius: BorderRadius.circular(20),
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withOpacity(0.3),
                                blurRadius: 8,
                                offset: const Offset(0, 3),
                              ),
                            ],
                          ),
                          child: Text(
                            'COMPLET',
                            style: TextStyle(
                              color: Colors.white,
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                              letterSpacing: 1.5,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
        ),

        // Nom de la table en dehors du cadre (en bas)
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
          child: Text(
            table['name'],
            style: TextStyle(
              color: textPrimary,
              fontSize: 14,
              fontWeight: FontWeight.w600,
            ),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  Widget _buildSeats(int occupied, int total, Color occupiedColor, Color emptyColor) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final centerX = constraints.maxWidth / 2;
        final centerY = constraints.maxHeight / 2;
        final radius = 48.0;

        return Stack(
          children: List.generate(total, (index) {
            final angle = (2 * 3.14159 * index / total) - (3.14159 / 2);
            final x = centerX + radius * cos(angle);
            final y = centerY + radius * sin(angle);
            final isOccupied = index < occupied;

            return Positioned(
              left: x - 18,
              top: y - 18,
              child: Container(
                width: 36,
                height: 36,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isOccupied ? occupiedColor : emptyColor,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 4,
                      offset: const Offset(0, 2),
                    ),
                  ],
                  border: Border.all(
                    color: Colors.white.withOpacity(0.1),
                    width: 1,
                  ),
                ),
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    Icon(
                      isOccupied ? Icons.person : Icons.person_outline,
                      color: Colors.white,
                      size: 18,
                    ),
                    if (isOccupied)
                      Positioned(
                        top: 2,
                        right: 2,
                        child: Container(
                          width: 8,
                          height: 8,
                          decoration: BoxDecoration(
                            color: Colors.green,
                            shape: BoxShape.circle,
                            border: Border.all(
                              color: Colors.white,
                              width: 1,
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            );
          }),
        );
      },
    );
  }
}

class _StarsPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white.withOpacity(0.1)
      ..style = PaintingStyle.fill;

    final random = Random(42);
    for (int i = 0; i < 30; i++) {
      final x = random.nextDouble() * size.width;
      final y = random.nextDouble() * size.height;
      final radius = random.nextDouble() * 1.2 + 0.3;

      canvas.drawCircle(Offset(x, y), radius, paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class _WoodGrainPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final basePaint = Paint()
      ..color = Color(0xFF8B4513)
      ..style = PaintingStyle.fill;

    canvas.drawRect(Rect.fromLTWH(0, 0, size.width, size.height), basePaint);

    // Effet de grain de bois
    final grainPaint = Paint()
      ..color = Color(0xFF5D2906)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 0.5;

    final random = Random(123);
    for (int i = 0; i < 50; i++) {
      final startY = random.nextDouble() * size.height;
      final endY = startY + random.nextDouble() * 20;
      final x = random.nextDouble() * size.width;

      canvas.drawLine(
        Offset(x, startY),
        Offset(x + random.nextDouble() * 50, endY),
        grainPaint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// Classe Random simple pour le CustomPainter
class Random {
  final int seed;

  Random(this.seed);

  double nextDouble() {
    final x = sin(seed * 1000.0) * 10000.0;
    return x - x.floorToDouble();
  }
}


FICHIER: flutter_lib/features/tables/presentation/widgets/controls.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/material.dart';
import 'package:flutter_background/flutter_background.dart';
import 'package:livekit_client/livekit_client.dart';
// ignore: depend_on_referenced_packages
import 'package:flutter_webrtc/flutter_webrtc.dart';

import '../../../../drinkks/exts.dart';

class ControlsWidget extends StatefulWidget {
  //
  final Room room;
  final LocalParticipant participant;

  const ControlsWidget(
    this.room,
    this.participant, {
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _ControlsWidgetState();
}

class _ControlsWidgetState extends State<ControlsWidget> {
  //
  CameraPosition position = CameraPosition.front;

  List<MediaDevice>? _audioInputs;
  List<MediaDevice>? _audioOutputs;
  List<MediaDevice>? _videoInputs;

  StreamSubscription? _subscription;

  bool _speakerphoneOn = Hardware.instance.speakerOn ?? false;

  @override
  void initState() {
    super.initState();
    participant.addListener(_onChange);
    _subscription = Hardware.instance.onDeviceChange.stream.listen((List<MediaDevice> devices) {
      _loadDevices(devices);
    });
    unawaited(Hardware.instance.enumerateDevices().then(_loadDevices));
  }

  @override
  void dispose() {
    unawaited(_subscription?.cancel());
    participant.removeListener(_onChange);
    super.dispose();
  }

  LocalParticipant get participant => widget.participant;

  void _loadDevices(List<MediaDevice> devices) async {
    _audioInputs = devices.where((d) => d.kind == 'audioinput').toList();
    _audioOutputs = devices.where((d) => d.kind == 'audiooutput').toList();
    _videoInputs = devices.where((d) => d.kind == 'videoinput').toList();
    setState(() {});
  }

  void _onChange() {
    // trigger refresh
    setState(() {});
  }

  void _unpublishAll() async {
    final result = await context.showUnPublishDialog();
    if (result == true) await participant.unpublishAllTracks();
  }

  bool get isMuted => participant.isMuted;

  void _disableAudio() async {
    await participant.setMicrophoneEnabled(false);
  }

  Future<void> _enableAudio() async {
    await participant.setMicrophoneEnabled(true);
  }

  void _disableVideo() async {
    await participant.setCameraEnabled(false);
  }

  void _enableVideo() async {
    await participant.setCameraEnabled(true);
  }

  void _selectAudioOutput(MediaDevice device) async {
    await widget.room.setAudioOutputDevice(device);
    setState(() {});
  }

  void _selectAudioInput(MediaDevice device) async {
    await widget.room.setAudioInputDevice(device);
    setState(() {});
  }

  void _selectVideoInput(MediaDevice device) async {
    await widget.room.setVideoInputDevice(device);
    setState(() {});
  }

  void _setSpeakerphoneOn() async {
    _speakerphoneOn = !_speakerphoneOn;
    await widget.room.setSpeakerOn(_speakerphoneOn, forceSpeakerOutput: false);
    setState(() {});
  }

  void _toggleCamera() async {
    final track = participant.videoTrackPublications.firstOrNull?.track;
    if (track == null) return;

    try {
      final newPosition = position.switched();
      await track.setCameraPosition(newPosition);
      setState(() {
        position = newPosition;
      });
    } catch (error) {
      print('could not restart track: $error');
      return;
    }
  }

  void _enableScreenShare() async {
    if (lkPlatformIsDesktop()) {
      try {
        final source = await showDialog<DesktopCapturerSource>(
          context: context,
          builder: (context) => ScreenSelectDialog(),
        );
        if (source == null) {
          print('cancelled screenshare');
          return;
        }
        print('DesktopCapturerSource: ${source.id}');
        final track = await LocalVideoTrack.createScreenShareTrack(
          ScreenShareCaptureOptions(
            sourceId: source.id,
            maxFrameRate: 15.0,
          ),
        );
        await participant.publishVideoTrack(track);
      } catch (e) {
        print('could not publish video: $e');
      }
      return;
    }
    if (lkPlatformIs(PlatformType.android)) {
      // Android specific
      final hasCapturePermission = await Helper.requestCapturePermission();
      if (!hasCapturePermission) {
        return;
      }

      requestBackgroundPermission([bool isRetry = false]) async {
        // Required for android screenshare.
        try {
          bool hasPermissions = await FlutterBackground.hasPermissions;
          if (!isRetry) {
            const androidConfig = FlutterBackgroundAndroidConfig(
              notificationTitle: 'Screen Sharing',
              notificationText: 'LiveKit Example is sharing the screen.',
              notificationImportance: AndroidNotificationImportance.normal,
              notificationIcon: AndroidResource(name: 'livekit_ic_launcher', defType: 'mipmap'),
            );
            hasPermissions = await FlutterBackground.initialize(androidConfig: androidConfig);
          }
          if (hasPermissions && !FlutterBackground.isBackgroundExecutionEnabled) {
            await FlutterBackground.enableBackgroundExecution();
          }
        } catch (e) {
          if (!isRetry) {
            return await Future<void>.delayed(const Duration(seconds: 1), () => requestBackgroundPermission(true));
          }
          print('could not publish video: $e');
        }
      }

      await requestBackgroundPermission();
    }

    if (lkPlatformIsWebMobile()) {
      if (!mounted) return;
      await context.showErrorDialog('Screen share is not supported on mobile web');
      return;
    }
    await participant.setScreenShareEnabled(true, captureScreenAudio: true);
  }

  void _disableScreenShare() async {
    await participant.setScreenShareEnabled(false);
    if (lkPlatformIs(PlatformType.android)) {
      // Android specific
      try {
        //   await FlutterBackground.disableBackgroundExecution();
      } catch (error) {
        print('error disabling screen share: $error');
      }
    }
  }

  void _onTapDisconnect() async {
    final result = await context.showDisconnectDialog();
    if (result == true) await widget.room.disconnect();
  }

  void _onTapUpdateSubscribePermission() async {
    final result = await context.showSubscribePermissionDialog();
    if (result != null) {
      try {
        widget.room.localParticipant?.setTrackSubscriptionPermissions(
          allParticipantsAllowed: result,
        );
      } catch (error) {
        if (!mounted) return;
        await context.showErrorDialog(error);
      }
    }
  }

  void _onTapSimulateScenario() async {
    final result = await context.showSimulateScenarioDialog();
    if (result != null) {
      print('${result}');

      if (SimulateScenarioResult.e2eeKeyRatchet == result) {
        await widget.room.e2eeManager?.ratchetKey();
      }

      if (SimulateScenarioResult.participantMetadata == result) {
        widget.room.localParticipant?.setMetadata('new metadata ${widget.room.localParticipant?.identity}');
      }

      if (SimulateScenarioResult.participantName == result) {
        widget.room.localParticipant?.setName('new name for ${widget.room.localParticipant?.identity}');
      }

      await widget.room.sendSimulateScenario(
        speakerUpdate: result == SimulateScenarioResult.speakerUpdate ? 3 : null,
        signalReconnect: result == SimulateScenarioResult.signalReconnect ? true : null,
        fullReconnect: result == SimulateScenarioResult.fullReconnect ? true : null,
        nodeFailure: result == SimulateScenarioResult.nodeFailure ? true : null,
        migration: result == SimulateScenarioResult.migration ? true : null,
        serverLeave: result == SimulateScenarioResult.serverLeave ? true : null,
        switchCandidate: result == SimulateScenarioResult.switchCandidate ? true : null,
      );
    }
  }

  void _onTapSendData() async {
    final result = await context.showSendDataDialog();
    if (result == true) {
      await widget.participant.publishData(
        utf8.encode('This is a sample data message'),
        reliable: true,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(
        vertical: 15,
        horizontal: 15,
      ),
      child: Wrap(
        alignment: WrapAlignment.center,
        spacing: 5,
        runSpacing: 5,
        children: [
          IconButton(
            onPressed: _unpublishAll,
            icon: const Icon(Icons.cancel),
            tooltip: 'Unpublish all',
          ),
          if (participant.isMicrophoneEnabled())
            if (lkPlatformIs(PlatformType.android))
              IconButton(
                onPressed: _disableAudio,
                icon: const Icon(Icons.mic),
                tooltip: 'mute audio',
              )
            else
              PopupMenuButton<MediaDevice>(
                icon: const Icon(Icons.settings_voice),
                offset: const Offset(0, -90),
                itemBuilder: (BuildContext context) {
                  return [
                    PopupMenuItem<MediaDevice>(
                      value: null,
                      onTap: isMuted ? _enableAudio : _disableAudio,
                      child: const ListTile(
                        leading: Icon(
                          Icons.mic_off,
                          color: Colors.white,
                        ),
                        title: Text('Mute Microphone'),
                      ),
                    ),
                    if (_audioInputs != null)
                      ..._audioInputs!.map((device) {
                        return PopupMenuItem<MediaDevice>(
                          value: device,
                          child: ListTile(
                            leading: (device.deviceId == widget.room.selectedAudioInputDeviceId)
                                ? const Icon(
                                    Icons.check_box_outlined,
                                    color: Colors.white,
                                  )
                                : const Icon(
                                    Icons.check_box_outline_blank,
                                    color: Colors.white,
                                  ),
                            title: Text(device.label),
                          ),
                          onTap: () => _selectAudioInput(device),
                        );
                      })
                  ];
                },
              )
          else
            IconButton(
              onPressed: _enableAudio,
              icon: const Icon(Icons.mic_off),
              tooltip: 'un-mute audio',
            ),
          if (!lkPlatformIsMobile())
            PopupMenuButton<MediaDevice>(
              icon: const Icon(Icons.volume_up),
              itemBuilder: (BuildContext context) {
                return [
                  const PopupMenuItem<MediaDevice>(
                    value: null,
                    child: ListTile(
                      leading: Icon(
                        Icons.speaker,
                        color: Colors.white,
                      ),
                      title: Text('Select Audio Output'),
                    ),
                  ),
                  if (_audioOutputs != null)
                    ..._audioOutputs!.map((device) {
                      return PopupMenuItem<MediaDevice>(
                        value: device,
                        child: ListTile(
                          leading: (device.deviceId == widget.room.selectedAudioOutputDeviceId)
                              ? const Icon(
                                  Icons.check_box_outlined,
                                  color: Colors.white,
                                )
                              : const Icon(
                                  Icons.check_box_outline_blank,
                                  color: Colors.white,
                                ),
                          title: Text(device.label),
                        ),
                        onTap: () => _selectAudioOutput(device),
                      );
                    })
                ];
              },
            ),
          if (!kIsWeb && lkPlatformIsMobile())
            IconButton(
              disabledColor: Colors.grey,
              onPressed: _setSpeakerphoneOn,
              icon: Icon(_speakerphoneOn ? Icons.speaker_phone : Icons.phone_android),
              tooltip: 'Switch SpeakerPhone',
            ),
          if (participant.isCameraEnabled())
            PopupMenuButton<MediaDevice>(
              icon: const Icon(Icons.videocam_sharp),
              itemBuilder: (BuildContext context) {
                return [
                  PopupMenuItem<MediaDevice>(
                    value: null,
                    onTap: _disableVideo,
                    child: const ListTile(
                      leading: Icon(
                        Icons.videocam_off,
                        color: Colors.white,
                      ),
                      title: Text('Disable Camera'),
                    ),
                  ),
                  if (_videoInputs != null)
                    ..._videoInputs!.map((device) {
                      return PopupMenuItem<MediaDevice>(
                        value: device,
                        child: ListTile(
                          leading: (device.deviceId == widget.room.selectedVideoInputDeviceId)
                              ? const Icon(
                                  Icons.check_box_outlined,
                                  color: Colors.white,
                                )
                              : const Icon(
                                  Icons.check_box_outline_blank,
                                  color: Colors.white,
                                ),
                          title: Text(device.label),
                        ),
                        onTap: () => _selectVideoInput(device),
                      );
                    })
                ];
              },
            )
          else
            IconButton(
              onPressed: _enableVideo,
              icon: const Icon(Icons.videocam_off),
              tooltip: 'un-mute video',
            ),
          IconButton(
            icon: Icon(position == CameraPosition.back ? Icons.video_camera_back : Icons.video_camera_front),
            onPressed: () => _toggleCamera(),
            tooltip: 'toggle camera',
          ),
          if (participant.isScreenShareEnabled())
            IconButton(
              icon: const Icon(Icons.monitor_outlined),
              onPressed: () => _disableScreenShare(),
              tooltip: 'unshare screen (experimental)',
            )
          else
            IconButton(
              icon: const Icon(Icons.monitor),
              onPressed: () => _enableScreenShare(),
              tooltip: 'share screen (experimental)',
            ),
          IconButton(
            onPressed: _onTapDisconnect,
            icon: const Icon(Icons.close_sharp),
            tooltip: 'disconnect',
          ),
          IconButton(
            onPressed: _onTapSendData,
            icon: const Icon(Icons.message),
            tooltip: 'send demo data',
          ),
          IconButton(
            onPressed: _onTapUpdateSubscribePermission,
            icon: const Icon(Icons.settings),
            tooltip: 'Subscribe permission',
          ),
          IconButton(
            onPressed: _onTapSimulateScenario,
            icon: const Icon(Icons.bug_report),
            tooltip: 'Simulate scenario',
          ),
        ],
      ),
    );
  }
}



FICHIER: flutter_lib/features/tables/presentation/widgets/no_video.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'dart:math' as math;

import '../../../../drinkks/theme.dart';

class NoVideoWidget extends StatelessWidget {
  //
  const NoVideoWidget({super.key});

  @override
  Widget build(BuildContext context) => Container(
        alignment: Alignment.center,
        child: LayoutBuilder(
          builder: (ctx, constraints) => Icon(
            Icons.videocam_off_outlined,
            color: LKColors.lkBlue,
            size: math.min(constraints.maxHeight, constraints.maxWidth) * 0.3,
          ),
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/widgets/participant.dart
--------------------------------------------------------------------------------
import 'package:collection/collection.dart';
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import '../../../../drinkks/theme.dart';

import 'dart:async';
import './no_video.dart';
import './participant_info.dart';
import './participant_stats.dart';
import './sound_waveform.dart';

abstract class ParticipantWidget extends StatefulWidget {
  // Convenience method to return relevant widget for participant
  static ParticipantWidget widgetFor(ParticipantTrack participantTrack, {bool showStatsLayer = false}) {
    if (participantTrack.participant is LocalParticipant) {
      return LocalParticipantWidget(
          participantTrack.participant as LocalParticipant, participantTrack.type, showStatsLayer);
    } else if (participantTrack.participant is RemoteParticipant) {
      return RemoteParticipantWidget(
          participantTrack.participant as RemoteParticipant, participantTrack.type, showStatsLayer);
    }
    throw UnimplementedError('Unknown participant type');
  }

  // Must be implemented by child class
  abstract final Participant participant;
  abstract final ParticipantTrackType type;
  abstract final bool showStatsLayer;
  final VideoQuality quality;

  const ParticipantWidget({
    this.quality = VideoQuality.MEDIUM,
    super.key,
  });
}

class LocalParticipantWidget extends ParticipantWidget {
  @override
  final LocalParticipant participant;
  @override
  final ParticipantTrackType type;
  @override
  final bool showStatsLayer;

  const LocalParticipantWidget(
    this.participant,
    this.type,
    this.showStatsLayer, {
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _LocalParticipantWidgetState();
}

class RemoteParticipantWidget extends ParticipantWidget {
  @override
  final RemoteParticipant participant;
  @override
  final ParticipantTrackType type;
  @override
  final bool showStatsLayer;

  const RemoteParticipantWidget(
    this.participant,
    this.type,
    this.showStatsLayer, {
    super.key,
  });

  @override
  State<StatefulWidget> createState() => _RemoteParticipantWidgetState();
}

abstract class _ParticipantWidgetState<T extends ParticipantWidget> extends State<T> {
  bool _visible = true;
  VideoTrack? get activeVideoTrack;
  AudioTrack? get activeAudioTrack;
  TrackPublication? get videoPublication;
  TrackPublication? get audioPublication;
  bool get isScreenShare => widget.type == ParticipantTrackType.kScreenShare;
  EventsListener<ParticipantEvent>? _listener;

  @override
  void initState() {
    super.initState();
    _listener = widget.participant.createListener();
    _listener?.on<TranscriptionEvent>((e) {
      for (var seg in e.segments) {
        print('Transcription: ${seg.text} ${seg.isFinal}');
      }
    });

    widget.participant.addListener(_onParticipantChanged);
    _onParticipantChanged();
  }

  @override
  void dispose() {
    widget.participant.removeListener(_onParticipantChanged);
    unawaited(_listener?.dispose());
    super.dispose();
  }

  @override
  void didUpdateWidget(covariant T oldWidget) {
    oldWidget.participant.removeListener(_onParticipantChanged);
    widget.participant.addListener(_onParticipantChanged);
    _onParticipantChanged();
    super.didUpdateWidget(oldWidget);
  }

  // Notify Flutter that UI re-build is required, but we don't set anything here
  // since the updated values are computed properties.
  void _onParticipantChanged() => setState(() {});

  // Widgets to show above the info bar
  List<Widget> extraWidgets(bool isScreenShare) => [];

  @override
  Widget build(BuildContext ctx) => Container(
        foregroundDecoration: BoxDecoration(
          border: widget.participant.isSpeaking && !isScreenShare
              ? Border.all(
                  width: 5,
                  color: LKColors.lkBlue,
                )
              : null,
        ),
        decoration: BoxDecoration(
          color: Theme.of(ctx).cardColor,
        ),
        child: Stack(
          children: [
            // Video
            InkWell(
              onTap: () => setState(() => _visible = !_visible),
              child: activeVideoTrack != null && !activeVideoTrack!.muted
                  ? VideoTrackRenderer(
                      renderMode: VideoRenderMode.auto,
                      activeVideoTrack!,
                    )
                  : const NoVideoWidget(),
            ),
            // Bottom bar
            Align(
              alignment: Alignment.bottomCenter,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                mainAxisSize: MainAxisSize.min,
                children: [
                  ...extraWidgets(isScreenShare),
                  ParticipantInfoWidget(
                    title: widget.participant.name.isNotEmpty
                        ? '${widget.participant.name} (${widget.participant.identity})'
                        : widget.participant.identity,
                    audioAvailable: audioPublication?.muted == false && audioPublication?.subscribed == true,
                    connectionQuality: widget.participant.connectionQuality,
                    isScreenShare: isScreenShare,
                    enabledE2EE: widget.participant.isEncrypted,
                  ),
                ],
              ),
            ),
            if (widget.showStatsLayer)
              Positioned(
                  top: 130,
                  right: 30,
                  child: ParticipantStatsWidget(
                    participant: widget.participant,
                  )),
            if (activeAudioTrack != null && !activeAudioTrack!.muted)
              Positioned(
                top: 10,
                right: 10,
                left: 10,
                bottom: 10,
                child: SoundWaveformWidget(
                  key: ValueKey(activeAudioTrack!.hashCode),
                  audioTrack: activeAudioTrack!,
                  width: 8,
                ),
              ),
          ],
        ),
      );
}

class _LocalParticipantWidgetState extends _ParticipantWidgetState<LocalParticipantWidget> {
  @override
  LocalTrackPublication<LocalVideoTrack>? get videoPublication => widget.participant.videoTrackPublications
      .where((element) => element.source == widget.type.lkVideoSourceType)
      .firstOrNull;

  @override
  LocalTrackPublication<LocalAudioTrack>? get audioPublication => widget.participant.audioTrackPublications
      .where((element) => element.source == widget.type.lkAudioSourceType)
      .firstOrNull;

  @override
  VideoTrack? get activeVideoTrack => videoPublication?.track;

  @override
  AudioTrack? get activeAudioTrack => audioPublication?.track;
}

class _RemoteParticipantWidgetState extends _ParticipantWidgetState<RemoteParticipantWidget> {
  @override
  RemoteTrackPublication<RemoteVideoTrack>? get videoPublication => widget.participant.videoTrackPublications
      .where((element) => element.source == widget.type.lkVideoSourceType)
      .firstOrNull;

  @override
  RemoteTrackPublication<RemoteAudioTrack>? get audioPublication => widget.participant.audioTrackPublications
      .where((element) => element.source == widget.type.lkAudioSourceType)
      .firstOrNull;

  @override
  VideoTrack? get activeVideoTrack => videoPublication?.track;

  @override
  AudioTrack? get activeAudioTrack => audioPublication?.track;

  @override
  List<Widget> extraWidgets(bool isScreenShare) => [
        Row(
          mainAxisSize: MainAxisSize.max,
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            // Menu for RemoteTrackPublication<RemoteAudioTrack>
            if (audioPublication != null)
              RemoteTrackPublicationMenuWidget(
                pub: audioPublication!,
                icon: Icons.volume_up,
              ),
            // Menu for RemoteTrackPublication<RemoteVideoTrack>
            if (videoPublication != null)
              RemoteTrackPublicationMenuWidget(
                pub: videoPublication!,
                icon: isScreenShare ? Icons.monitor : Icons.videocam,
              ),
            if (videoPublication != null)
              RemoteTrackFPSMenuWidget(
                pub: videoPublication!,
                icon: Icons.menu,
              ),
            if (videoPublication != null)
              RemoteTrackQualityMenuWidget(
                pub: videoPublication!,
                icon: Icons.monitor_outlined,
              ),
          ],
        ),
      ];
}

class RemoteTrackPublicationMenuWidget extends StatelessWidget {
  final IconData icon;
  final RemoteTrackPublication pub;
  const RemoteTrackPublicationMenuWidget({
    required this.pub,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Material(
        color: Colors.black.withValues(alpha: 0.3),
        child: PopupMenuButton<Function>(
          tooltip: 'Subscribe menu',
          icon: Icon(icon,
              color: {
                TrackSubscriptionState.notAllowed: Colors.red,
                TrackSubscriptionState.unsubscribed: Colors.grey,
                TrackSubscriptionState.subscribed: Colors.green,
              }[pub.subscriptionState]),
          onSelected: (value) => value(),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<Function>>[
            // Subscribe/Unsubscribe
            if (pub.subscribed == false)
              PopupMenuItem(
                child: const Text('Subscribe'),
                value: () => pub.subscribe(),
              )
            else if (pub.subscribed == true)
              PopupMenuItem(
                child: const Text('Un-subscribe'),
                value: () => pub.unsubscribe(),
              ),
          ],
        ),
      );
}

class RemoteTrackFPSMenuWidget extends StatelessWidget {
  final IconData icon;
  final RemoteTrackPublication pub;
  const RemoteTrackFPSMenuWidget({
    required this.pub,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Material(
        color: Colors.black.withValues(alpha: 0.3),
        child: PopupMenuButton<Function>(
          tooltip: 'Preferred FPS',
          icon: Icon(icon, color: Colors.white),
          onSelected: (value) => value(),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<Function>>[
            PopupMenuItem(
              child: const Text('30'),
              value: () => pub.setVideoFPS(30),
            ),
            PopupMenuItem(
              child: const Text('15'),
              value: () => pub.setVideoFPS(15),
            ),
            PopupMenuItem(
              child: const Text('8'),
              value: () => pub.setVideoFPS(8),
            ),
          ],
        ),
      );
}

class RemoteTrackQualityMenuWidget extends StatelessWidget {
  final IconData icon;
  final RemoteTrackPublication pub;
  const RemoteTrackQualityMenuWidget({
    required this.pub,
    required this.icon,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Material(
        color: Colors.black.withValues(alpha: 0.3),
        child: PopupMenuButton<Function>(
          tooltip: 'Preferred Quality',
          icon: Icon(icon, color: Colors.white),
          onSelected: (value) => value(),
          itemBuilder: (BuildContext context) => <PopupMenuEntry<Function>>[
            PopupMenuItem(
              child: const Text('HIGH'),
              value: () => pub.setVideoQuality(VideoQuality.HIGH),
            ),
            PopupMenuItem(
              child: const Text('MEDIUM'),
              value: () => pub.setVideoQuality(VideoQuality.MEDIUM),
            ),
            PopupMenuItem(
              child: const Text('LOW'),
              value: () => pub.setVideoQuality(VideoQuality.LOW),
            ),
          ],
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/widgets/participant_info.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';

enum ParticipantTrackType {
  kUserMedia,
  kScreenShare,
}

extension ParticipantTrackTypeExt on ParticipantTrackType {
  TrackSource get lkVideoSourceType => {
        ParticipantTrackType.kUserMedia: TrackSource.camera,
        ParticipantTrackType.kScreenShare: TrackSource.screenShareVideo,
      }[this]!;

  TrackSource get lkAudioSourceType => {
        ParticipantTrackType.kUserMedia: TrackSource.microphone,
        ParticipantTrackType.kScreenShare: TrackSource.screenShareAudio,
      }[this]!;
}

class ParticipantTrack {
  ParticipantTrack({required this.participant, this.type = ParticipantTrackType.kUserMedia});
  Participant participant;
  final ParticipantTrackType type;
}

class ParticipantInfoWidget extends StatelessWidget {
  final String? title;
  final bool audioAvailable;
  final ConnectionQuality connectionQuality;
  final bool isScreenShare;
  final bool enabledE2EE;

  const ParticipantInfoWidget({
    this.title,
    this.audioAvailable = true,
    this.connectionQuality = ConnectionQuality.unknown,
    this.isScreenShare = false,
    this.enabledE2EE = false,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Container(
        color: Colors.black.withValues(alpha: 0.3),
        padding: const EdgeInsets.symmetric(
          vertical: 7,
          horizontal: 10,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.end,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            if (title != null)
              Flexible(
                child: Text(
                  title!,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            isScreenShare
                ? const Padding(
                    padding: EdgeInsets.only(left: 5),
                    child: Icon(
                      Icons.monitor,
                      color: Colors.white,
                      size: 16,
                    ),
                  )
                : Padding(
                    padding: const EdgeInsets.only(left: 5),
                    child: Icon(
                      audioAvailable ? Icons.mic : Icons.mic_off,
                      color: audioAvailable ? Colors.white : Colors.red,
                      size: 16,
                    ),
                  ),
            if (connectionQuality != ConnectionQuality.unknown)
              Padding(
                padding: const EdgeInsets.only(left: 5),
                child: Icon(
                  connectionQuality == ConnectionQuality.poor ? Icons.wifi_off_outlined : Icons.wifi,
                  color: {
                    ConnectionQuality.excellent: Colors.green,
                    ConnectionQuality.good: Colors.orange,
                    ConnectionQuality.poor: Colors.red,
                  }[connectionQuality],
                  size: 16,
                ),
              ),
            Padding(
              padding: const EdgeInsets.only(left: 5),
              child: Icon(
                enabledE2EE ? Icons.lock : Icons.lock_open,
                color: enabledE2EE ? Colors.green : Colors.red,
                size: 16,
              ),
            ),
          ],
        ),
      );
}



FICHIER: flutter_lib/features/tables/presentation/widgets/participant_stats.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import 'dart:async';

enum StatsType {
  kUnknown,
  kLocalAudioSender,
  kLocalVideoSender,
  kRemoteAudioReceiver,
  kRemoteVideoReceiver,
}

class ParticipantStatsWidget extends StatefulWidget {
  const ParticipantStatsWidget({super.key, required this.participant});
  final Participant participant;
  @override
  State<StatefulWidget> createState() => _ParticipantStatsWidgetState();
}

class _ParticipantStatsWidgetState extends State<ParticipantStatsWidget> {
  List<EventsListener<TrackEvent>> listeners = [];
  StatsType statsType = StatsType.kUnknown;
  Map<String, Map<String, String>> stats = {'audio': {}, 'video': {}};

  void _setUpListener(Track track) {
    final listener = track.createListener();
    listeners.add(listener);
    if (track is LocalVideoTrack) {
      statsType = StatsType.kLocalVideoSender;
      listener.on<VideoSenderStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          stats['tx'] = 'total sent ${event.currentBitrate.toInt()} kpbs';
          event.stats.forEach((key, value) {
            stats['layer-$key'] =
                '${value.frameWidth ?? 0}x${value.frameHeight ?? 0} ${value.framesPerSecond?.toDouble() ?? 0} fps, ${event.bitrateForLayers[key] ?? 0} kbps';
          });
          final firstStats = event.stats['f'] ?? event.stats['h'] ?? event.stats['q'];
          if (firstStats != null) {
            stats['encoder'] = firstStats.encoderImplementation ?? '';
            if (firstStats.mimeType != null) {
              stats['codec'] = '${firstStats.mimeType!.split('/')[1]}/${firstStats.clockRate}';
            }
            stats['payload'] = '${firstStats.payloadType}';
            stats['qualityLimitationReason'] = firstStats.qualityLimitationReason ?? '';
          }

          this.stats['video']!.addEntries(stats.entries);
        });
      });
    } else if (track is RemoteVideoTrack) {
      statsType = StatsType.kRemoteVideoReceiver;
      listener.on<VideoReceiverStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          if (!event.currentBitrate.isNaN) {
            stats['rx'] = '${event.currentBitrate.toInt()} kpbs';
          }
          if (event.stats.mimeType != null) {
            stats['codec'] = '${event.stats.mimeType!.split('/')[1]}/${event.stats.clockRate}';
          }
          stats['payload'] = '${event.stats.payloadType}';
          stats['size/fps'] =
              '${event.stats.frameWidth}x${event.stats.frameHeight} ${event.stats.framesPerSecond?.toDouble()}fps';
          stats['jitter'] = '${event.stats.jitter} s';
          stats['decoder'] = '${event.stats.decoderImplementation}';
          //stats['video packets lost'] = '${event.stats.packetsLost}';
          //stats['video packets received'] = '${event.stats.packetsReceived}';
          stats['frames received'] = '${event.stats.framesReceived}';
          stats['frames decoded'] = '${event.stats.framesDecoded}';
          stats['frames dropped'] = '${event.stats.framesDropped}';

          this.stats['video']!.addEntries(stats.entries);
        });
      });
    } else if (track is LocalAudioTrack) {
      statsType = StatsType.kLocalAudioSender;
      listener.on<AudioSenderStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          stats['tx'] = '${event.currentBitrate.toInt()} kpbs';
          if (event.stats.mimeType != null) {
            stats['codec'] = '${event.stats.mimeType!.split('/')[1]}/${event.stats.clockRate}/${event.stats.channels}';
          }
          stats['payload'] = '${event.stats.payloadType}';
          this.stats['audio']!.addEntries(stats.entries);
        });
      });
    } else if (track is RemoteAudioTrack) {
      statsType = StatsType.kRemoteAudioReceiver;
      listener.on<AudioReceiverStatsEvent>((event) {
        final stats = <String, String>{};
        setState(() {
          stats['rx'] = '${event.currentBitrate.toInt()} kpbs';
          if (event.stats.mimeType != null) {
            stats['codec'] = '${event.stats.mimeType!.split('/')[1]}/${event.stats.clockRate}/${event.stats.channels}';
          }
          stats['payload'] = '${event.stats.payloadType}';
          stats['jitter'] = '${event.stats.jitter} s';
          //stats['concealed samples'] =
          //    '${event.stats.concealedSamples} / ${event.stats.concealmentEvents}';
          stats['packets lost'] = '${event.stats.packetsLost}';
          stats['packets received'] = '${event.stats.packetsReceived}';

          this.stats['audio']!.addEntries(stats.entries);
        });
      });
    }
  }

  _onParticipantChanged() {
    for (var element in listeners) {
      unawaited(element.dispose());
    }
    listeners.clear();
    for (var track in [...widget.participant.videoTrackPublications, ...widget.participant.audioTrackPublications]) {
      if (track.track != null) {
        _setUpListener(track.track!);
      }
    }
  }

  @override
  void initState() {
    super.initState();
    widget.participant.addListener(_onParticipantChanged);
    // trigger initial change
    _onParticipantChanged();
  }

  @override
  void deactivate() {
    for (var element in listeners) {
      unawaited(element.dispose());
    }
    widget.participant.removeListener(_onParticipantChanged);
    super.deactivate();
  }

  num sendBitrate = 0;

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black.withValues(alpha: 0.3),
      padding: const EdgeInsets.symmetric(
        vertical: 8,
        horizontal: 8,
      ),
      child: Column(children: [
        const Text('audio stats', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        ...stats['audio']!.entries.map((e) => Text('${e.key}: ${e.value}')),
        const Text('video stats', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        ...stats['video']!.entries.map((e) => Text('${e.key}: ${e.value}')),
      ]),
    );
  }
}



FICHIER: flutter_lib/features/tables/presentation/widgets/sound_waveform.dart
--------------------------------------------------------------------------------
/*
 * Copyright 2024 LiveKit, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * [SoundWaveformWidget] Originally adapted from: https://github.com/SushanShakya/sound_waveform
 *
 * MIT License
 *
 * Copyright (c) 2022 Sushan Shakya
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

import 'package:flutter/material.dart';
import 'package:livekit_client/livekit_client.dart';
import 'dart:async';

class SoundWaveformWidget extends StatefulWidget {
  final int barCount;
  final double width;
  final double minHeight;
  final double maxHeight;
  final int durationInMilliseconds;
  const SoundWaveformWidget({
    super.key,
    required this.audioTrack,
    this.barCount = 5,
    this.width = 5,
    this.minHeight = 8,
    this.maxHeight = 100,
    this.durationInMilliseconds = 500,
  });
  final AudioTrack audioTrack;
  @override
  State<SoundWaveformWidget> createState() => _SoundWaveformWidgetState();
}

class _SoundWaveformWidgetState extends State<SoundWaveformWidget> with TickerProviderStateMixin {
  late AnimationController controller;
  late List<double> samples;
  AudioVisualizer? _visualizer;
  EventsListener<AudioVisualizerEvent>? _listener;

  Future<void> _startVisualizer(AudioTrack track) async {
    samples = List.filled(widget.barCount, 0);
    _visualizer ??= createVisualizer(track, options: AudioVisualizerOptions(barCount: widget.barCount));
    _listener ??= _visualizer?.createListener();
    _listener?.on<AudioVisualizerEvent>((e) {
      if (mounted) {
        setState(() {
          samples = e.event.map((e) => ((e as num) * 100).toDouble()).toList();
        });
      }
    });

    await _visualizer!.start();
  }

  void _stopVisualizer(AudioTrack track) async {
    await _visualizer?.stop();
    await _visualizer?.dispose();
    _visualizer = null;
    await _listener?.dispose();
    _listener = null;
  }

  @override
  void initState() {
    super.initState();

    unawaited(_startVisualizer(widget.audioTrack));

    controller = AnimationController(
        vsync: this,
        duration: Duration(
          milliseconds: widget.durationInMilliseconds,
        ))
      ..repeat(); // ignore: discarded_futures
  }

  @override
  void dispose() {
    controller.dispose();
    _stopVisualizer(widget.audioTrack);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final count = widget.barCount;
    final minHeight = widget.minHeight;
    final maxHeight = widget.maxHeight;
    return AnimatedBuilder(
      animation: controller,
      builder: (c, child) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: List.generate(
            count,
            (i) => AnimatedContainer(
              duration: Duration(milliseconds: widget.durationInMilliseconds ~/ count),
              margin: i == (samples.length - 1) ? EdgeInsets.zero : const EdgeInsets.only(right: 5),
              height: samples[i] < minHeight
                  ? minHeight
                  : samples[i] > maxHeight
                      ? maxHeight
                      : samples[i],
              width: widget.width,
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(9999),
              ),
            ),
          ),
        );
      },
    );
  }
}



FICHIER: flutter_lib/features/tables/presentation/widgets/text_field.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';

class LKTextField extends StatelessWidget {
  final String label;
  final TextEditingController? ctrl;
  const LKTextField({
    required this.label,
    this.ctrl,
    super.key,
  });

  @override
  Widget build(BuildContext context) => Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 10),
            child: Text(
              label,
              style: const TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          Container(
            padding: const EdgeInsets.symmetric(
              vertical: 15,
              horizontal: 15,
            ),
            decoration: BoxDecoration(
              border: Border.all(
                width: 1,
                color: Colors.white.withValues(alpha: .3),
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: TextField(
              controller: ctrl,
              decoration: const InputDecoration.collapsed(
                hintText: '',
              ),
              keyboardType: TextInputType.url,
              autocorrect: false,
            ),
          ),
        ],
      );
}



FICHIER: flutter_lib/features/venues/data/datasources/venues_remote_data_source.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:dio/dio.dart';
import '../../../../services/api_service.dart';
import '../models/venues_model.dart';
import '../models/paginated_response_model.dart';

part 'venues_remote_data_source.g.dart';

abstract class VenuesRemoteDataSource {
  Future<PaginatedResponseModel> getVenues({
    required int page,
    required int limit,
    String? search,
    int? type,
  });
  Future<VenuesModel> getVenue(String uuid);
}

@riverpod
VenuesRemoteDataSource venuesRemoteDataSource(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return VenuesRemoteDataSourceImpl(apiService);
}

class VenuesRemoteDataSourceImpl implements VenuesRemoteDataSource {
  final ApiService _apiService;

  VenuesRemoteDataSourceImpl(this._apiService);

  @override
  Future<PaginatedResponseModel> getVenues({
    required int page,
    required int limit,
    String? search,
    int? type,
  }) async {
    final queryParams = <String, dynamic>{
      'page': page,
      'limit': limit,
    };

    if (search != null && search.isNotEmpty) {
      queryParams['search'] = search;
    }

    if (type != null) {
      queryParams['type'] = type;
    }

    final response = await _apiService.dio.get(
      '/venue/list',
      queryParameters: queryParams,
    );

    return PaginatedResponseModel.fromJson(response.data);
  }

  @override
  Future<VenuesModel> getVenue(String uuid) async {
    final response = await _apiService._dio.get('/venue/$uuid');
    return VenuesModel.fromJson(response.data);
  }
}


FICHIER: flutter_lib/features/venues/data/datasources/venues_remote_data_source.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_remote_data_source.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(venuesRemoteDataSource)
final venuesRemoteDataSourceProvider = VenuesRemoteDataSourceProvider._();

final class VenuesRemoteDataSourceProvider
    extends
        $FunctionalProvider<
          VenuesRemoteDataSource,
          VenuesRemoteDataSource,
          VenuesRemoteDataSource
        >
    with $Provider<VenuesRemoteDataSource> {
  VenuesRemoteDataSourceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'venuesRemoteDataSourceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$venuesRemoteDataSourceHash();

  @$internal
  @override
  $ProviderElement<VenuesRemoteDataSource> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  VenuesRemoteDataSource create(Ref ref) {
    return venuesRemoteDataSource(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(VenuesRemoteDataSource value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<VenuesRemoteDataSource>(value),
    );
  }
}

String _$venuesRemoteDataSourceHash() =>
    r'7b8103122bc9097fbeefab13cd7153821ef3b0b6';



FICHIER: flutter_lib/features/venues/data/models/paginated_response_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import 'venues_model.dart';

part 'paginated_response_model.freezed.dart';
part 'paginated_response_model.g.dart';

@freezed
abstract class PaginatedResponseModel with _$PaginatedResponseModel {
  const factory PaginatedResponseModel({
    required List<VenuesModel> items,
    required int total,
    required int page,
    required int limit,
    required int pages,
  }) = _PaginatedResponseModel;

  factory PaginatedResponseModel.fromJson(Map<String, dynamic> json) =>
      _$PaginatedResponseModelFromJson(json);
}


FICHIER: flutter_lib/features/venues/data/models/paginated_response_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'paginated_response_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$PaginatedResponseModel {

 List<VenuesModel> get items; int get total; int get page; int get limit; int get pages;
/// Create a copy of PaginatedResponseModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PaginatedResponseModelCopyWith<PaginatedResponseModel> get copyWith => _$PaginatedResponseModelCopyWithImpl<PaginatedResponseModel>(this as PaginatedResponseModel, _$identity);

  /// Serializes this PaginatedResponseModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PaginatedResponseModel&&const DeepCollectionEquality().equals(other.items, items)&&(identical(other.total, total) || other.total == total)&&(identical(other.page, page) || other.page == page)&&(identical(other.limit, limit) || other.limit == limit)&&(identical(other.pages, pages) || other.pages == pages));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items),total,page,limit,pages);

@override
String toString() {
  return 'PaginatedResponseModel(items: $items, total: $total, page: $page, limit: $limit, pages: $pages)';
}


}

/// @nodoc
abstract mixin class $PaginatedResponseModelCopyWith<$Res>  {
  factory $PaginatedResponseModelCopyWith(PaginatedResponseModel value, $Res Function(PaginatedResponseModel) _then) = _$PaginatedResponseModelCopyWithImpl;
@useResult
$Res call({
 List<VenuesModel> items, int total, int page, int limit, int pages
});




}
/// @nodoc
class _$PaginatedResponseModelCopyWithImpl<$Res>
    implements $PaginatedResponseModelCopyWith<$Res> {
  _$PaginatedResponseModelCopyWithImpl(this._self, this._then);

  final PaginatedResponseModel _self;
  final $Res Function(PaginatedResponseModel) _then;

/// Create a copy of PaginatedResponseModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,Object? total = null,Object? page = null,Object? limit = null,Object? pages = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<VenuesModel>,total: null == total ? _self.total : total // ignore: cast_nullable_to_non_nullable
as int,page: null == page ? _self.page : page // ignore: cast_nullable_to_non_nullable
as int,limit: null == limit ? _self.limit : limit // ignore: cast_nullable_to_non_nullable
as int,pages: null == pages ? _self.pages : pages // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}


/// Adds pattern-matching-related methods to [PaginatedResponseModel].
extension PaginatedResponseModelPatterns on PaginatedResponseModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _PaginatedResponseModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _PaginatedResponseModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _PaginatedResponseModel value)  $default,){
final _that = this;
switch (_that) {
case _PaginatedResponseModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _PaginatedResponseModel value)?  $default,){
final _that = this;
switch (_that) {
case _PaginatedResponseModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( List<VenuesModel> items,  int total,  int page,  int limit,  int pages)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _PaginatedResponseModel() when $default != null:
return $default(_that.items,_that.total,_that.page,_that.limit,_that.pages);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( List<VenuesModel> items,  int total,  int page,  int limit,  int pages)  $default,) {final _that = this;
switch (_that) {
case _PaginatedResponseModel():
return $default(_that.items,_that.total,_that.page,_that.limit,_that.pages);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( List<VenuesModel> items,  int total,  int page,  int limit,  int pages)?  $default,) {final _that = this;
switch (_that) {
case _PaginatedResponseModel() when $default != null:
return $default(_that.items,_that.total,_that.page,_that.limit,_that.pages);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _PaginatedResponseModel implements PaginatedResponseModel {
  const _PaginatedResponseModel({required final  List<VenuesModel> items, required this.total, required this.page, required this.limit, required this.pages}): _items = items;
  factory _PaginatedResponseModel.fromJson(Map<String, dynamic> json) => _$PaginatedResponseModelFromJson(json);

 final  List<VenuesModel> _items;
@override List<VenuesModel> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

@override final  int total;
@override final  int page;
@override final  int limit;
@override final  int pages;

/// Create a copy of PaginatedResponseModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PaginatedResponseModelCopyWith<_PaginatedResponseModel> get copyWith => __$PaginatedResponseModelCopyWithImpl<_PaginatedResponseModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PaginatedResponseModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PaginatedResponseModel&&const DeepCollectionEquality().equals(other._items, _items)&&(identical(other.total, total) || other.total == total)&&(identical(other.page, page) || other.page == page)&&(identical(other.limit, limit) || other.limit == limit)&&(identical(other.pages, pages) || other.pages == pages));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items),total,page,limit,pages);

@override
String toString() {
  return 'PaginatedResponseModel(items: $items, total: $total, page: $page, limit: $limit, pages: $pages)';
}


}

/// @nodoc
abstract mixin class _$PaginatedResponseModelCopyWith<$Res> implements $PaginatedResponseModelCopyWith<$Res> {
  factory _$PaginatedResponseModelCopyWith(_PaginatedResponseModel value, $Res Function(_PaginatedResponseModel) _then) = __$PaginatedResponseModelCopyWithImpl;
@override @useResult
$Res call({
 List<VenuesModel> items, int total, int page, int limit, int pages
});




}
/// @nodoc
class __$PaginatedResponseModelCopyWithImpl<$Res>
    implements _$PaginatedResponseModelCopyWith<$Res> {
  __$PaginatedResponseModelCopyWithImpl(this._self, this._then);

  final _PaginatedResponseModel _self;
  final $Res Function(_PaginatedResponseModel) _then;

/// Create a copy of PaginatedResponseModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,Object? total = null,Object? page = null,Object? limit = null,Object? pages = null,}) {
  return _then(_PaginatedResponseModel(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<VenuesModel>,total: null == total ? _self.total : total // ignore: cast_nullable_to_non_nullable
as int,page: null == page ? _self.page : page // ignore: cast_nullable_to_non_nullable
as int,limit: null == limit ? _self.limit : limit // ignore: cast_nullable_to_non_nullable
as int,pages: null == pages ? _self.pages : pages // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/venues/data/models/paginated_response_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'paginated_response_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_PaginatedResponseModel _$PaginatedResponseModelFromJson(
  Map<String, dynamic> json,
) => _PaginatedResponseModel(
  items: (json['items'] as List<dynamic>)
      .map((e) => VenuesModel.fromJson(e as Map<String, dynamic>))
      .toList(),
  total: (json['total'] as num).toInt(),
  page: (json['page'] as num).toInt(),
  limit: (json['limit'] as num).toInt(),
  pages: (json['pages'] as num).toInt(),
);

Map<String, dynamic> _$PaginatedResponseModelToJson(
  _PaginatedResponseModel instance,
) => <String, dynamic>{
  'items': instance.items,
  'total': instance.total,
  'page': instance.page,
  'limit': instance.limit,
  'pages': instance.pages,
};



FICHIER: flutter_lib/features/venues/data/models/venues_model.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import '../../domain/entities/venues_entity.dart';

part 'venues_model.freezed.dart';
part 'venues_model.g.dart';

@freezed
abstract class VenuesModel with _$VenuesModel {
  const VenuesModel._();

  const factory VenuesModel({
    required int id,
    required String uuid,
    required String name,
    String? description,
    int? type,
    int? rank,
  }) = _VenuesModel;

  factory VenuesModel.fromJson(Map<String, dynamic> json) =>
      _$VenuesModelFromJson(json);

  VenuesEntity toEntity() => VenuesEntity(
    id: id,
    uuid: uuid,
    name: name,
    description: description,
    type: type,
    rank: rank,
  );
}


FICHIER: flutter_lib/features/venues/data/models/venues_model.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'venues_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$VenuesModel {

 int get id; String get uuid; String get name; String? get description; int? get type; int? get rank;
/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VenuesModelCopyWith<VenuesModel> get copyWith => _$VenuesModelCopyWithImpl<VenuesModel>(this as VenuesModel, _$identity);

  /// Serializes this VenuesModel to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VenuesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.uuid, uuid) || other.uuid == uuid)&&(identical(other.name, name) || other.name == name)&&(identical(other.description, description) || other.description == description)&&(identical(other.type, type) || other.type == type)&&(identical(other.rank, rank) || other.rank == rank));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,uuid,name,description,type,rank);

@override
String toString() {
  return 'VenuesModel(id: $id, uuid: $uuid, name: $name, description: $description, type: $type, rank: $rank)';
}


}

/// @nodoc
abstract mixin class $VenuesModelCopyWith<$Res>  {
  factory $VenuesModelCopyWith(VenuesModel value, $Res Function(VenuesModel) _then) = _$VenuesModelCopyWithImpl;
@useResult
$Res call({
 int id, String uuid, String name, String? description, int? type, int? rank
});




}
/// @nodoc
class _$VenuesModelCopyWithImpl<$Res>
    implements $VenuesModelCopyWith<$Res> {
  _$VenuesModelCopyWithImpl(this._self, this._then);

  final VenuesModel _self;
  final $Res Function(VenuesModel) _then;

/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? uuid = null,Object? name = null,Object? description = freezed,Object? type = freezed,Object? rank = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int,uuid: null == uuid ? _self.uuid : uuid // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,type: freezed == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as int?,rank: freezed == rank ? _self.rank : rank // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// Adds pattern-matching-related methods to [VenuesModel].
extension VenuesModelPatterns on VenuesModel {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _VenuesModel value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _VenuesModel value)  $default,){
final _that = this;
switch (_that) {
case _VenuesModel():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _VenuesModel value)?  $default,){
final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int id,  String uuid,  String name,  String? description,  int? type,  int? rank)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that.id,_that.uuid,_that.name,_that.description,_that.type,_that.rank);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int id,  String uuid,  String name,  String? description,  int? type,  int? rank)  $default,) {final _that = this;
switch (_that) {
case _VenuesModel():
return $default(_that.id,_that.uuid,_that.name,_that.description,_that.type,_that.rank);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int id,  String uuid,  String name,  String? description,  int? type,  int? rank)?  $default,) {final _that = this;
switch (_that) {
case _VenuesModel() when $default != null:
return $default(_that.id,_that.uuid,_that.name,_that.description,_that.type,_that.rank);case _:
  return null;

}
}

}

/// @nodoc
@JsonSerializable()

class _VenuesModel extends VenuesModel {
  const _VenuesModel({required this.id, required this.uuid, required this.name, this.description, this.type, this.rank}): super._();
  factory _VenuesModel.fromJson(Map<String, dynamic> json) => _$VenuesModelFromJson(json);

@override final  int id;
@override final  String uuid;
@override final  String name;
@override final  String? description;
@override final  int? type;
@override final  int? rank;

/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VenuesModelCopyWith<_VenuesModel> get copyWith => __$VenuesModelCopyWithImpl<_VenuesModel>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$VenuesModelToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VenuesModel&&(identical(other.id, id) || other.id == id)&&(identical(other.uuid, uuid) || other.uuid == uuid)&&(identical(other.name, name) || other.name == name)&&(identical(other.description, description) || other.description == description)&&(identical(other.type, type) || other.type == type)&&(identical(other.rank, rank) || other.rank == rank));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,uuid,name,description,type,rank);

@override
String toString() {
  return 'VenuesModel(id: $id, uuid: $uuid, name: $name, description: $description, type: $type, rank: $rank)';
}


}

/// @nodoc
abstract mixin class _$VenuesModelCopyWith<$Res> implements $VenuesModelCopyWith<$Res> {
  factory _$VenuesModelCopyWith(_VenuesModel value, $Res Function(_VenuesModel) _then) = __$VenuesModelCopyWithImpl;
@override @useResult
$Res call({
 int id, String uuid, String name, String? description, int? type, int? rank
});




}
/// @nodoc
class __$VenuesModelCopyWithImpl<$Res>
    implements _$VenuesModelCopyWith<$Res> {
  __$VenuesModelCopyWithImpl(this._self, this._then);

  final _VenuesModel _self;
  final $Res Function(_VenuesModel) _then;

/// Create a copy of VenuesModel
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? uuid = null,Object? name = null,Object? description = freezed,Object? type = freezed,Object? rank = freezed,}) {
  return _then(_VenuesModel(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int,uuid: null == uuid ? _self.uuid : uuid // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,type: freezed == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as int?,rank: freezed == rank ? _self.rank : rank // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/venues/data/models/venues_model.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_VenuesModel _$VenuesModelFromJson(Map<String, dynamic> json) => _VenuesModel(
  id: (json['id'] as num).toInt(),
  uuid: json['uuid'] as String,
  name: json['name'] as String,
  description: json['description'] as String?,
  type: (json['type'] as num?)?.toInt(),
  rank: (json['rank'] as num?)?.toInt(),
);

Map<String, dynamic> _$VenuesModelToJson(_VenuesModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'uuid': instance.uuid,
      'name': instance.name,
      'description': instance.description,
      'type': instance.type,
      'rank': instance.rank,
    };



FICHIER: flutter_lib/features/venues/data/repositories/venues_repository_impl.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../domain/entities/venues_entity.dart';
import '../../domain/repositories/venues_repository.dart';
import '../datasources/venues_remote_data_source.dart';
import '../models/paginated_response_model.dart';

part 'venues_repository_impl.g.dart';

@riverpod
VenuesRepository venuesRepository(Ref ref) {
  final remoteDataSource = ref.watch(venuesRemoteDataSourceProvider);
  return VenuesRepositoryImpl(remoteDataSource);
}

class VenuesRepositoryImpl implements VenuesRepository {
  final VenuesRemoteDataSource _remoteDataSource;

  // Cache pour stocker la derniÃ¨re rÃ©ponse paginÃ©e
  PaginatedResponseModel? _lastResponse;

  VenuesRepositoryImpl(this._remoteDataSource);

  @override
  Future<List<VenuesEntity>> getVenues({
    required int page,
    required int limit,
    String? search,
    int? type,
  }) async {
    final response = await _remoteDataSource.getVenues(
      page: page,
      limit: limit,
      search: search,
      type: type,
    );

    // Mettre en cache la rÃ©ponse pour les mÃ©tadonnÃ©es
    _lastResponse = response;

    return response.items.map((model) => model.toEntity()).toList();
  }

  @override
  Future<VenuesEntity> getVenue(String uuid) async {
    final model = await _remoteDataSource.getVenue(uuid);
    return model.toEntity();
  }

  @override
  Future<int> getTotalPages() async {
    return _lastResponse?.pages ?? 1;
  }

  @override
  Future<int> getTotalItems() async {
    return _lastResponse?.total ?? 0;
  }
}


FICHIER: flutter_lib/features/venues/data/repositories/venues_repository_impl.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_repository_impl.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(venuesRepository)
final venuesRepositoryProvider = VenuesRepositoryProvider._();

final class VenuesRepositoryProvider
    extends
        $FunctionalProvider<
          VenuesRepository,
          VenuesRepository,
          VenuesRepository
        >
    with $Provider<VenuesRepository> {
  VenuesRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'venuesRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$venuesRepositoryHash();

  @$internal
  @override
  $ProviderElement<VenuesRepository> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  VenuesRepository create(Ref ref) {
    return venuesRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(VenuesRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<VenuesRepository>(value),
    );
  }
}

String _$venuesRepositoryHash() => r'955ae296e3ec7371336fe0c1b64a9ea6bb687cc9';



FICHIER: flutter_lib/features/venues/domain/entities/venues_entity.dart
--------------------------------------------------------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'venues_entity.freezed.dart';

@freezed
abstract class VenuesEntity with _$VenuesEntity {
  const factory VenuesEntity({
    required int id,
    required String uuid,
    required String name,
    String? description,
    int? type,
    int? rank,
  }) = _VenuesEntity;
}


FICHIER: flutter_lib/features/venues/domain/entities/venues_entity.freezed.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'venues_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$VenuesEntity {

 int get id; String get uuid; String get name; String? get description; int? get type; int? get rank;
/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VenuesEntityCopyWith<VenuesEntity> get copyWith => _$VenuesEntityCopyWithImpl<VenuesEntity>(this as VenuesEntity, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VenuesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.uuid, uuid) || other.uuid == uuid)&&(identical(other.name, name) || other.name == name)&&(identical(other.description, description) || other.description == description)&&(identical(other.type, type) || other.type == type)&&(identical(other.rank, rank) || other.rank == rank));
}


@override
int get hashCode => Object.hash(runtimeType,id,uuid,name,description,type,rank);

@override
String toString() {
  return 'VenuesEntity(id: $id, uuid: $uuid, name: $name, description: $description, type: $type, rank: $rank)';
}


}

/// @nodoc
abstract mixin class $VenuesEntityCopyWith<$Res>  {
  factory $VenuesEntityCopyWith(VenuesEntity value, $Res Function(VenuesEntity) _then) = _$VenuesEntityCopyWithImpl;
@useResult
$Res call({
 int id, String uuid, String name, String? description, int? type, int? rank
});




}
/// @nodoc
class _$VenuesEntityCopyWithImpl<$Res>
    implements $VenuesEntityCopyWith<$Res> {
  _$VenuesEntityCopyWithImpl(this._self, this._then);

  final VenuesEntity _self;
  final $Res Function(VenuesEntity) _then;

/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? uuid = null,Object? name = null,Object? description = freezed,Object? type = freezed,Object? rank = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int,uuid: null == uuid ? _self.uuid : uuid // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,type: freezed == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as int?,rank: freezed == rank ? _self.rank : rank // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// Adds pattern-matching-related methods to [VenuesEntity].
extension VenuesEntityPatterns on VenuesEntity {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _VenuesEntity value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _VenuesEntity value)  $default,){
final _that = this;
switch (_that) {
case _VenuesEntity():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _VenuesEntity value)?  $default,){
final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( int id,  String uuid,  String name,  String? description,  int? type,  int? rank)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that.id,_that.uuid,_that.name,_that.description,_that.type,_that.rank);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( int id,  String uuid,  String name,  String? description,  int? type,  int? rank)  $default,) {final _that = this;
switch (_that) {
case _VenuesEntity():
return $default(_that.id,_that.uuid,_that.name,_that.description,_that.type,_that.rank);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( int id,  String uuid,  String name,  String? description,  int? type,  int? rank)?  $default,) {final _that = this;
switch (_that) {
case _VenuesEntity() when $default != null:
return $default(_that.id,_that.uuid,_that.name,_that.description,_that.type,_that.rank);case _:
  return null;

}
}

}

/// @nodoc


class _VenuesEntity implements VenuesEntity {
  const _VenuesEntity({required this.id, required this.uuid, required this.name, this.description, this.type, this.rank});


@override final  int id;
@override final  String uuid;
@override final  String name;
@override final  String? description;
@override final  int? type;
@override final  int? rank;

/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VenuesEntityCopyWith<_VenuesEntity> get copyWith => __$VenuesEntityCopyWithImpl<_VenuesEntity>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VenuesEntity&&(identical(other.id, id) || other.id == id)&&(identical(other.uuid, uuid) || other.uuid == uuid)&&(identical(other.name, name) || other.name == name)&&(identical(other.description, description) || other.description == description)&&(identical(other.type, type) || other.type == type)&&(identical(other.rank, rank) || other.rank == rank));
}


@override
int get hashCode => Object.hash(runtimeType,id,uuid,name,description,type,rank);

@override
String toString() {
  return 'VenuesEntity(id: $id, uuid: $uuid, name: $name, description: $description, type: $type, rank: $rank)';
}


}

/// @nodoc
abstract mixin class _$VenuesEntityCopyWith<$Res> implements $VenuesEntityCopyWith<$Res> {
  factory _$VenuesEntityCopyWith(_VenuesEntity value, $Res Function(_VenuesEntity) _then) = __$VenuesEntityCopyWithImpl;
@override @useResult
$Res call({
 int id, String uuid, String name, String? description, int? type, int? rank
});




}
/// @nodoc
class __$VenuesEntityCopyWithImpl<$Res>
    implements _$VenuesEntityCopyWith<$Res> {
  __$VenuesEntityCopyWithImpl(this._self, this._then);

  final _VenuesEntity _self;
  final $Res Function(_VenuesEntity) _then;

/// Create a copy of VenuesEntity
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? uuid = null,Object? name = null,Object? description = freezed,Object? type = freezed,Object? rank = freezed,}) {
  return _then(_VenuesEntity(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int,uuid: null == uuid ? _self.uuid : uuid // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,type: freezed == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as int?,rank: freezed == rank ? _self.rank : rank // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on



FICHIER: flutter_lib/features/venues/domain/repositories/venues_repository.dart
--------------------------------------------------------------------------------
import '../entities/venues_entity.dart';

abstract class VenuesRepository {
  Future<List<VenuesEntity>> getVenues({
    required int page,
    required int limit,
    String? search,
    int? type,
  });
  Future<VenuesEntity> getVenue(String uuid);
  Future<int> getTotalPages();
  Future<int> getTotalItems();
}


FICHIER: flutter_lib/features/venues/domain/usecases/get_venues_usecase.dart
--------------------------------------------------------------------------------
// flutter_lib/features/venues/domain/usecases/get_venues_usecase.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../entities/venues_entity.dart';
import '../repositories/venues_repository.dart';
import '../../data/repositories/venues_repository_impl.dart';

part 'get_venues_usecase.g.dart';

@riverpod
Future<List<VenuesEntity>> getVenues(
    Ref ref, {
      required int page,
      required int limit,
      String? search,
      int? type,
    }) {
  return ref.watch(venuesRepositoryProvider).getVenues(
    page: page,
    limit: limit,
    search: search,
    type: type,
  );
}


FICHIER: flutter_lib/features/venues/domain/usecases/get_venues_usecase.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'get_venues_usecase.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(getVenues)
final getVenuesProvider = GetVenuesFamily._();

final class GetVenuesProvider
    extends
        $FunctionalProvider<
          AsyncValue<List<VenuesEntity>>,
          List<VenuesEntity>,
          FutureOr<List<VenuesEntity>>
        >
    with
        $FutureModifier<List<VenuesEntity>>,
        $FutureProvider<List<VenuesEntity>> {
  GetVenuesProvider._({
    required GetVenuesFamily super.from,
    required ({int page, int limit, String? search, int? type}) super.argument,
  }) : super(
         retry: null,
         name: r'getVenuesProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$getVenuesHash();

  @override
  String toString() {
    return r'getVenuesProvider'
        ''
        '$argument';
  }

  @$internal
  @override
  $FutureProviderElement<List<VenuesEntity>> $createElement(
    $ProviderPointer pointer,
  ) => $FutureProviderElement(pointer);

  @override
  FutureOr<List<VenuesEntity>> create(Ref ref) {
    final argument =
        this.argument as ({int page, int limit, String? search, int? type});
    return getVenues(
      ref,
      page: argument.page,
      limit: argument.limit,
      search: argument.search,
      type: argument.type,
    );
  }

  @override
  bool operator ==(Object other) {
    return other is GetVenuesProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$getVenuesHash() => r'31b31665348244ac2786515ee31604c48b04d44d';

final class GetVenuesFamily extends $Family
    with
        $FunctionalFamilyOverride<
          FutureOr<List<VenuesEntity>>,
          ({int page, int limit, String? search, int? type})
        > {
  GetVenuesFamily._()
    : super(
        retry: null,
        name: r'getVenuesProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  GetVenuesProvider call({
    required int page,
    required int limit,
    String? search,
    int? type,
  }) => GetVenuesProvider._(
    argument: (page: page, limit: limit, search: search, type: type),
    from: this,
  );

  @override
  String toString() => r'getVenuesProvider';
}



FICHIER: flutter_lib/features/venues/presentation/controllers/venues_controller.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../data/repositories/venues_repository_impl.dart';
import '../../domain/entities/venues_entity.dart';
import '../../domain/usecases/get_venues_usecase.dart';

part 'venues_controller.g.dart';

@riverpod
class VenuesController extends _$VenuesController {
  int _currentPage = 1;
  int _totalPages = 1;
  final int _limit = 20;
  String? _currentSearch;
  int? _currentType;

  @override
  FutureOr<List<VenuesEntity>> build() {
    // RafraÃ®chir lors du changement de page/recherche/filtre
    // ref.listenSelf((previous, next) {
    //   // Logique si nÃ©cessaire
    // });

    return _fetchVenues();
  }

  Future<List<VenuesEntity>> _fetchVenues() async {
    final venues = await ref.watch(
      getVenuesProvider(
        page: _currentPage,
        limit: _limit,
        search: _currentSearch,
        type: _currentType,
      ).future,
    );

    // RÃ©cupÃ©rer les mÃ©tadonnÃ©es de pagination depuis le repository
    final repository = ref.read(venuesRepositoryProvider);
    _totalPages = await repository.getTotalPages();

    return venues;
  }

  Future<void> nextPage() async {
    if (_currentPage < _totalPages) {
      _currentPage++;
      await refresh();
    }
  }

  Future<void> previousPage() async {
    if (_currentPage > 1) {
      _currentPage--;
      await refresh();
    }
  }

  Future<void> goToPage(int page) async {
    if (page >= 1 && page <= _totalPages && page != _currentPage) {
      _currentPage = page;
      await refresh();
    }
  }

  Future<void> search(String query) async {
    _currentSearch = query.isEmpty ? null : query;
    _currentPage = 1; // Revenir Ã  la premiÃ¨re page pour la recherche
    await refresh();
  }

  Future<void> filterByType(int? type) async {
    _currentType = type;
    _currentPage = 1; // Revenir Ã  la premiÃ¨re page pour le filtre
    await refresh();
  }

  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => _fetchVenues());
  }

  int get currentPage => _currentPage;
  int get totalPages => _totalPages;
  int get limit => _limit;
  bool get hasNextPage => _currentPage < _totalPages;
  bool get hasPreviousPage => _currentPage > 1;
}


FICHIER: flutter_lib/features/venues/presentation/controllers/venues_controller.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'venues_controller.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(VenuesController)
final venuesControllerProvider = VenuesControllerProvider._();

final class VenuesControllerProvider
    extends $AsyncNotifierProvider<VenuesController, List<VenuesEntity>> {
  VenuesControllerProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'venuesControllerProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$venuesControllerHash();

  @$internal
  @override
  VenuesController create() => VenuesController();
}

String _$venuesControllerHash() => r'0499c30d14364dd8ba7b574506e1627cdaabdd21';

abstract class _$VenuesController extends $AsyncNotifier<List<VenuesEntity>> {
  FutureOr<List<VenuesEntity>> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final ref =
        this.ref as $Ref<AsyncValue<List<VenuesEntity>>, List<VenuesEntity>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<List<VenuesEntity>>, List<VenuesEntity>>,
              AsyncValue<List<VenuesEntity>>,
              Object?,
              Object?
            >;
    element.handleCreate(ref, build);
  }
}



FICHIER: flutter_lib/features/venues/presentation/screens/venues_screen.dart
--------------------------------------------------------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import '../../../../providers/auth_provider.dart';
import '../controllers/venues_controller.dart';

class VenuesScreen extends ConsumerStatefulWidget {
  const VenuesScreen({super.key});

  @override
  ConsumerState<VenuesScreen> createState() => _VenuesScreenState();
}

class _VenuesScreenState extends ConsumerState<VenuesScreen> {
  bool _isLoggingOut = false;
  final TextEditingController _searchController = TextEditingController();
  int? _selectedType;
  bool _showFilters = false;

  // Mapping des types vers les images
  static const Map<int, String> _typeToImage = {
    1: 'assets/images/venues/lounge.png',
    2: 'assets/images/venues/port.png',
    3: 'assets/images/venues/rooftop.png',
    4: 'assets/images/venues/jazz.png',
    5: 'assets/images/venues/garden.png',
    6: 'assets/images/venues/club.png',
  };

  // Mapping des types vers les libellÃ©s
  static const Map<int, String> _typeToLabel = {
    1: 'Lounge',
    2: 'Port',
    3: 'Rooftop',
    4: 'Jazz',
    5: 'Jardin',
    6: 'Club',
  };

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _handleLogout(BuildContext context) async {
    if (_isLoggingOut) return;

    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E3F),
        title: const Text(
          'DÃ©connexion',
          style: TextStyle(color: Colors.white),
        ),
        content: const Text(
          'Voulez-vous vraiment vous dÃ©connecter ?',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text(
              'Annuler',
              style: TextStyle(color: Colors.white70),
            ),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF6366F1),
            ),
            child: const Text('DÃ©connexion', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );

    if (confirm == true && !_isLoggingOut) {
      setState(() => _isLoggingOut = true);

      try {
        print('ğŸ”´ [VENUES] DÃ©but de la dÃ©connexion');
        final notifier = ref.read(authStateNotifierProvider.notifier);
        await notifier.signOut();
        await Future.delayed(const Duration(milliseconds: 300));

        if (context.mounted) {
          context.go('/login');
        }
      } catch (e, stack) {
        print('âŒ [VENUES] Erreur dÃ©connexion: $e');
        print('ğŸ“š [VENUES] Stack: $stack');

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Erreur dÃ©connexion: ${e.toString()}'),
              backgroundColor: Colors.red,
            ),
          );
          context.go('/login');
        }
      } finally {
        if (mounted) {
          setState(() => _isLoggingOut = false);
        }
      }
    }
  }

  void _performSearch() {
    final controller = ref.read(venuesControllerProvider.notifier);
    controller.search(_searchController.text);
  }

  void _selectType(int? type) {
    setState(() {
      _selectedType = type;
    });
    final controller = ref.read(venuesControllerProvider.notifier);
    controller.filterByType(type);
  }

  String? _getImageForType(int? type) {
    if (type == null || !_typeToImage.containsKey(type)) {
      return 'assets/images/venues/default.png';
    }
    return _typeToImage[type];
  }

  String _getTypeLabel(int? type) {
    if (type == null || !_typeToLabel.containsKey(type)) {
      return 'Inconnu';
    }
    return _typeToLabel[type]!;
  }

  @override
  Widget build(BuildContext context) {
    const backgroundColor = Color(0xFF0F0F23);
    const primaryColor = Color(0xFF6366F1);
    const textPrimary = Colors.white;

    final venuesState = ref.watch(venuesControllerProvider);
    final controller = ref.read(venuesControllerProvider.notifier);

    return Scaffold(
      backgroundColor: backgroundColor,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        elevation: 0,
        leading: IconButton(
          icon: _isLoggingOut
              ? const SizedBox(
            width: 20,
            height: 20,
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: Colors.white,
            ),
          )
              : const Icon(Icons.logout, color: textPrimary),
          onPressed: _isLoggingOut ? null : () => _handleLogout(context),
          tooltip: 'Se dÃ©connecter',
        ),
        title: const Text(
          'Nos Bars Virtuels',
          style: TextStyle(
            color: textPrimary,
            fontSize: 24,
            fontWeight: FontWeight.bold,
          ),
        ),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings, color: textPrimary),
            onPressed: () {
              context.go('/account');
            },
            tooltip: 'Mon compte',
          ),
          IconButton(
            icon: Icon(
              _showFilters ? Icons.filter_list_off : Icons.filter_list,
              color: textPrimary,
            ),
            onPressed: () {
              setState(() {
                _showFilters = !_showFilters;
              });
            },
            tooltip: 'Filtres',
          ),
        ],
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(100),
          child: Column(
            children: [
              // Barre de recherche
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0),
                child: TextField(
                  controller: _searchController,
                  style: const TextStyle(color: Colors.white),
                  decoration: InputDecoration(
                    hintText: 'Rechercher un bar...',
                    hintStyle: const TextStyle(color: Colors.white54),
                    prefixIcon: const Icon(Icons.search, color: primaryColor),
                    suffixIcon: IconButton(
                      icon: const Icon(Icons.clear, color: Colors.white54),
                      onPressed: () {
                        _searchController.clear();
                        _performSearch();
                      },
                    ),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                      borderSide: BorderSide.none,
                    ),
                    filled: true,
                    fillColor: const Color(0xFF1E1E3F),
                    contentPadding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  onSubmitted: (_) => _performSearch(),
                ),
              ),
              // Filtres par type
              if (_showFilters) ...[
                const SizedBox(height: 8),
                SizedBox(
                  height: 40,
                  child: ListView(
                    scrollDirection: Axis.horizontal,
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    children: [
                      _buildFilterChip('Tous', null, _selectedType == null),
                      ..._typeToLabel.entries.map(
                            (entry) => _buildFilterChip(
                          entry.value,
                          entry.key,
                          _selectedType == entry.key,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
              const SizedBox(height: 8),
            ],
          ),
        ),
      ),
      body: venuesState.when(
        data: (venues) {
          return Column(
            children: [
              Expanded(
                child: venues.isEmpty
                    ? const Center(
                  child: Text(
                    'Aucun bar trouvÃ©',
                    style: TextStyle(color: Colors.white54),
                  ),
                )
                    : GridView.builder(
                  padding: const EdgeInsets.all(16),
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 2,
                    crossAxisSpacing: 16,
                    mainAxisSpacing: 16,
                    childAspectRatio: 0.8,
                  ),
                  itemCount: venues.length,
                  itemBuilder: (context, index) {
                    final venue = venues[index];
                    return _buildVenueCard(
                      venue,
                      primaryColor,
                      backgroundColor,
                      textPrimary,
                    );
                  },
                ),
              ),
              // Pagination
              if (venues.isNotEmpty)
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: backgroundColor,
                    border: Border(
                      top: BorderSide(color: Colors.white.withOpacity(0.1)),
                    ),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.chevron_left),
                        color: controller.hasPreviousPage
                            ? primaryColor
                            : Colors.white24,
                        onPressed: controller.hasPreviousPage
                            ? () => controller.previousPage()
                            : null,
                      ),
                      Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 8,
                        ),
                        decoration: BoxDecoration(
                          color: const Color(0xFF1E1E3F),
                          borderRadius: BorderRadius.circular(20),
                        ),
                        child: Text(
                          'Page ${controller.currentPage} / ${controller.totalPages}',
                          style: const TextStyle(color: Colors.white),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.chevron_right),
                        color: controller.hasNextPage
                            ? primaryColor
                            : Colors.white24,
                        onPressed: controller.hasNextPage
                            ? () => controller.nextPage()
                            : null,
                      ),
                    ],
                  ),
                ),
            ],
          );
        },
        loading: () => const Center(
          child: CircularProgressIndicator(
            color: Color(0xFF6366F1),
          ),
        ),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, color: Colors.red, size: 48),
              const SizedBox(height: 16),
              Text(
                'Erreur: $error',
                style: const TextStyle(color: Colors.white),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () => controller.refresh(),
                style: ElevatedButton.styleFrom(
                  backgroundColor: primaryColor,
                ),
                child: const Text('RÃ©essayer'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildFilterChip(String label, int? value, bool isSelected) {
    return Padding(
      padding: const EdgeInsets.only(right: 8),
      child: FilterChip(
        label: Text(
          label,
          style: TextStyle(
            color: isSelected ? Colors.white : Colors.white70,
          ),
        ),
        selected: isSelected,
        onSelected: (_) => _selectType(value),
        backgroundColor: const Color(0xFF1E1E3F),
        selectedColor: const Color(0xFF6366F1),
        checkmarkColor: Colors.white,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
      ),
    );
  }

  Widget _buildVenueCard(
      dynamic venue,
      Color primaryColor,
      Color backgroundColor,
      Color textPrimary,
      ) {
    final imagePath = _getImageForType(venue.type);
    final typeLabel = _getTypeLabel(venue.type);

    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      color: backgroundColor,
      child: InkWell(
        onTap: () {
          context.go('/venues/${venue.uuid}/tables');
        },
        borderRadius: BorderRadius.circular(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              height: 120,
              decoration: BoxDecoration(
                borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(16),
                  topRight: Radius.circular(16),
                ),
                image: DecorationImage(
                  image: AssetImage(imagePath!),
                  fit: BoxFit.cover,
                ),
              ),
              child: Container(
                decoration: BoxDecoration(
                  borderRadius: const BorderRadius.only(
                    topLeft: Radius.circular(16),
                    topRight: Radius.circular(16),
                  ),
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [
                      Colors.transparent,
                      Colors.black.withOpacity(0.6),
                    ],
                  ),
                ),
                alignment: Alignment.bottomLeft,
                padding: const EdgeInsets.all(12),
                child: Text(
                  venue.name,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Type
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: primaryColor.withOpacity(0.2),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      typeLabel,
                      style: TextStyle(
                        color: primaryColor,
                        fontSize: 10,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),
                  // Description
                  Text(
                    venue.description ?? 'Aucune description',
                    style: TextStyle(
                      color: textPrimary.withOpacity(0.8),
                      fontSize: 12,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}


FICHIER: flutter_lib/providers/auth_provider.dart
--------------------------------------------------------------------------------
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import '../services/api_service.dart';
import '../services/auth_service.dart';

// Provider pour FlutterSecureStorage (sÃ©parÃ© pour Ã©viter les dÃ©pendances circulaires)
final secureStorageProvider = Provider<FlutterSecureStorage>((ref) {
  return const FlutterSecureStorage();
});

// Provider pour Dio
final dioProvider = Provider<Dio>((ref) {
  return Dio();
});

// Provider pour ApiService (sans rÃ©fÃ©rence Ã  authStateNotifierProvider)
final apiServiceProvider = Provider<ApiService>((ref) {
  final dio = ref.watch(dioProvider);
  final storage = ref.watch(secureStorageProvider);
  return ApiService(dio: dio, storage: storage);
});

// Provider pour AuthService
final authServiceProvider = Provider<AuthService>((ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AuthService(
    onAuthenticationEvent: (event) async {
      print('Authentication event: $event');
    },
    onAuthenticationError: (error) async {
      print('Authentication error: $error');
    },
    apiService: apiService,
  );
});

// Stream provider pour les changements d'Ã©tat Firebase
final authStateProvider = StreamProvider<User?>((ref) {
  final authService = ref.watch(authServiceProvider);
  return authService.authStateChanges;
});

// Provider pour l'utilisateur courant Firebase
final currentUserProvider = Provider<User?>((ref) {
  return ref.watch(authServiceProvider).currentUser;
});

// Provider pour rÃ©cupÃ©rer le JWT applicatif (version FutureProvider)
final appJwtProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getAppJwt();
});

// Provider pour rÃ©cupÃ©rer le refresh token
final refreshTokenProvider = FutureProvider<String?>((ref) async {
  final authService = ref.watch(authServiceProvider);
  return await authService.getRefreshToken();
});

// ============================================================
// GESTION COMPLÃˆTE DE L'AUTH
// ============================================================

// Enum pour les diffÃ©rents statuts d'authentification
enum AuthStatus {
  initial,           // Non connectÃ©
  authenticated,     // Firebase OK mais JWT en cours
  fullyAuthenticated, // Firebase + JWT OK
  error,             // Erreur
}

// Classe reprÃ©sentant l'Ã©tat d'authentification complet
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? jwtToken;
  final String? refreshToken;
  final Object? error;

  const AuthState({
    required this.status,
    this.user,
    this.jwtToken,
    this.refreshToken,
    this.error,
  });

  static const AuthState initial = AuthState(status: AuthStatus.initial);

  const AuthState.authenticated(User user) : this(
    status: AuthStatus.authenticated,
    user: user,
  );

  const AuthState.fullyAuthenticated({
    required User user,
    required String jwtToken,
    String? refreshToken,
  }) : this(
    status: AuthStatus.fullyAuthenticated,
    user: user,
    jwtToken: jwtToken,
    refreshToken: refreshToken,
  );

  const AuthState.error(Object error) : this(
    status: AuthStatus.error,
    error: error,
  );

  // MÃ©thodes utilitaires
  bool get isFullyAuthenticated => status == AuthStatus.fullyAuthenticated;
  bool get isAuthenticated => status == AuthStatus.authenticated || status == AuthStatus.fullyAuthenticated;
  bool get isInitial => status == AuthStatus.initial;
  bool get hasError => status == AuthStatus.error;

  // MÃ©thode copyWith
  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? jwtToken,
    String? refreshToken,
    Object? error,
  }) {
    return AuthState(
      status: status ?? this.status,
      user: user ?? this.user,
      jwtToken: jwtToken ?? this.jwtToken,
      refreshToken: refreshToken ?? this.refreshToken,
      error: error ?? this.error,
    );
  }

  @override
  String toString() {
    return 'AuthState(status: $status, user: ${user?.uid ?? 'null'}, hasJwt: ${jwtToken != null}, hasRefresh: ${refreshToken != null})';
  }
}

// StateNotifier pour gÃ©rer l'Ã©tat d'authentification complet
class AuthStateNotifier extends StateNotifier<AuthState> {
  final AuthService _authService;
  final Ref _ref;
  StreamSubscription<User?>? _authSubscription;

  AuthStateNotifier({
    required AuthService authService,
    required Ref ref,
  }) : _authService = authService,
        _ref = ref,
        super(AuthState.initial) {
    _init();
  }

  Future<void> _init() async {
    print('ğŸŸ¡ [NOTIFIER] Initialisation...');

    // Configurer le callback unauthorized dans ApiService APRÃˆS la crÃ©ation
    // Mais on ne peut pas le faire ici car Ã§a crÃ©erait une dÃ©pendance circulaire
    // On va plutÃ´t le faire depuis le main ou depuis un provider sÃ©parÃ©

    // Ã‰couter DIRECTEMENT le stream Firebase Auth (plus fiable)
    _authSubscription = _authService.authStateChanges.listen(
          (user) {
        print('ğŸ”µ [NOTIFIER] Firebase Auth State Change: ${user?.uid ?? 'null'}');

        if (user != null) {
          print('âœ… [NOTIFIER] Utilisateur Firebase connectÃ©');
          state = AuthState.authenticated(user);
          _checkTokens(user);
        } else {
          print('âŒ [NOTIFIER] Utilisateur Firebase DÃ‰CONNECTÃ‰ - RÃ©initialisation');
          state = AuthState.initial;
        }
      },
      onError: (error) {
        print('âŒ [NOTIFIER] Erreur auth stream: $error');
        state = AuthState.error(error);
      },
    );

    // Garder le listener du provider pour compatibilitÃ©
    _ref.listen(authStateProvider, (previous, next) {
      next.whenData((user) {
        print('ğŸŸ¡ [PROVIDER] authStateProvider: ${user?.uid ?? 'null'}');
      });
    });

    // Ã‰couter les Ã©vÃ©nements d'authentification
    _authService.onAuthenticationEvent = (event) async {
      if (event is GoogleSignInAuthenticationEventSignIn) {
        print('ğŸ“¡ [NOTIFIER] Ã‰vÃ©nement d\'authentification reÃ§u');

        const maxAttempts = 10;
        var attempts = 0;
        String? jwt;
        String? refreshToken;

        while (attempts < maxAttempts) {
          await Future.delayed(const Duration(milliseconds: 300));
          jwt = await _authService.getAppJwt();
          refreshToken = await _authService.getRefreshToken();
          if (jwt != null && jwt.isNotEmpty) {
            break;
          }
          attempts++;
        }

        final user = _authService.currentUser;

        if (jwt != null && jwt.isNotEmpty && user != null) {
          state = AuthState.fullyAuthenticated(
            user: user,
            jwtToken: jwt,
            refreshToken: refreshToken,
          );
          print('âœ… [NOTIFIER] Authentification complÃ¨te (Firebase + JWT)');
        } else if (user != null) {
          state = AuthState.authenticated(user);
          print('âš ï¸ [NOTIFIER] Firebase authentifiÃ© mais JWT manquant');
        }
      }
    };

    // Ã‰couter les erreurs d'authentification
    _authService.onAuthenticationError = (error) async {
      state = AuthState.error(error);
      print('âŒ [NOTIFIER] Erreur d\'authentification: $error');
    };
  }

  Future<void> _checkTokens(User user) async {
    try {
      final existingJwt = await _authService.getAppJwt();
      final existingRefresh = await _authService.getRefreshToken();

      if (existingJwt != null && existingJwt.isNotEmpty) {
        state = AuthState.fullyAuthenticated(
          user: user,
          jwtToken: existingJwt,
          refreshToken: existingRefresh,
        );
        print('âœ… [NOTIFIER] Tokens dÃ©jÃ  prÃ©sents');
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur vÃ©rification tokens: $e');
    }
  }

  /*
  // Nouvelle mÃ©thode pour gÃ©rer les erreurs 401
  Future<void> handleUnauthorized() async {
    print('âš ï¸ [NOTIFIER] Erreur 401 - Tentative de refresh token...');

    try {
      final newToken = await _authService.refreshJwtToken();

      if (newToken != null && state.user != null) {
        final refreshToken = await _authService.getRefreshToken();
        state = AuthState.fullyAuthenticated(
          user: state.user!,
          jwtToken: newToken,
          refreshToken: refreshToken,
        );
        print('âœ… [NOTIFIER] Token rafraÃ®chi avec succÃ¨s');
      } else {
        // Impossible de rafraÃ®chir, dÃ©connexion
        print('âŒ [NOTIFIER] Ã‰chec du refresh - DÃ©connexion');
        await signOut();
      }
    } catch (e) {
      print('âŒ [NOTIFIER] Erreur handleUnauthorized: $e');
      await signOut();
    }
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ [NOTIFIER] signOut() appelÃ©');

    try {
      state = AuthState.initial;
      await _authService.signOut();

      final userAfter = _authService.currentUser;
      print('ğŸ‘¤ [NOTIFIER] Utilisateur aprÃ¨s service.signOut(): ${userAfter?.uid ?? 'null'}');

      await Future.delayed(const Duration(milliseconds: 200));

      if (_authService.currentUser != null) {
        print('âš ï¸ [NOTIFIER] Utilisateur toujours connectÃ© - tentative de force');
        await _authService.forceSignOut();
        state = AuthState.initial;
      }

      print('âœ… [NOTIFIER] signOut() terminÃ©');
    } catch (e, stack) {
      print('âŒ [NOTIFIER] Erreur signOut: $e');
      print('ğŸ“š [NOTIFIER] Stack: $stack');
      state = AuthState.initial;
      rethrow;
    }
  }

  // MÃ©thode pour rÃ©initialiser manuellement l'Ã©tat
  void reset() {
    print('ğŸŸ¡ [NOTIFIER] reset() appelÃ©');
    state = AuthState.initial;
  }

  // MÃ©thode pour forcer une erreur
  void setError(Object error) {
    print('âŒ [NOTIFIER] setError(): $error');
    state = AuthState.error(error);
  }

  @override
  void dispose() {
    _authSubscription?.cancel();
    super.dispose();
  }
}

// StateNotifierProvider
final authStateNotifierProvider = StateNotifierProvider<AuthStateNotifier, AuthState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return AuthStateNotifier(
    authService: authService,
    ref: ref,
  );
});

// Providers utilitaires
final isFullyAuthenticatedProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.isFullyAuthenticated;
});

final appJwtSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.jwtToken;
});

final refreshTokenSyncProvider = Provider<String?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.refreshToken;
});

final currentUserSyncProvider = Provider<User?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.user;
});

final isAuthenticatingProvider = Provider<bool>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.status == AuthStatus.authenticated;
});

final authErrorProvider = Provider<Object?>((ref) {
  final authState = ref.watch(authStateNotifierProvider);
  return authState.error;
});

/*
// Provider sÃ©parÃ© pour configurer le callback unauthorized (Ã  utiliser dans main.dart)
final unauthorizedCallbackProvider = Provider<void Function()>((ref) {
  return () {
    // Cette fonction sera appelÃ©e quand une erreur 401 non rÃ©cupÃ©rable survient
    ref.read(authStateNotifierProvider.notifier).handleUnauthorized();
  };
});

 */


FICHIER: flutter_lib/services/account_service.dart
--------------------------------------------------------------------------------
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'api_service.dart';

part 'account_service.g.dart';

class AccountService {
  final ApiService _apiService;

  AccountService({required ApiService apiService}) : _apiService = apiService;

  // Profile
  Future<Map<String, dynamic>> getProfile() async {
    return _apiService.getProfile();
  }

  Future<Map<String, dynamic>> getAboutMe() async {
    return _apiService.getAboutMe();
  }

  Future<Map<String, dynamic>> getPhoto() async {
    return _apiService.getPhoto();
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    await _apiService.updateProfile(
      displayName: displayName,
      gender: gender,
      birthdate: birthdate,
    );
  }

  Future<void> updateAboutMe(String aboutMe) async {
    await _apiService.updateAboutMe(aboutMe);
  }

  Future<void> updatePhoto(String photoPath) async {
    await _apiService.updatePhoto(photoPath);
  }
}

@riverpod
AccountService accountService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return AccountService(apiService: apiService);
}


FICHIER: flutter_lib/services/account_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'account_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(accountService)
final accountServiceProvider = AccountServiceProvider._();

final class AccountServiceProvider
    extends $FunctionalProvider<AccountService, AccountService, AccountService>
    with $Provider<AccountService> {
  AccountServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'accountServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$accountServiceHash();

  @$internal
  @override
  $ProviderElement<AccountService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  AccountService create(Ref ref) {
    return accountService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AccountService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AccountService>(value),
    );
  }
}

String _$accountServiceHash() => r'b1473d081de813201df44ed2b261f6b3f8538fee';



FICHIER: flutter_lib/services/api_service.dart
--------------------------------------------------------------------------------
import 'dart:async';
import 'dart:developer';
import 'dart:ui';

import 'package:dio/dio.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'api_service.g.dart';

class ApiException implements Exception {
  final String message;
  final int? statusCode;
  final dynamic originalError;

  ApiException({
    required this.message,
    this.statusCode,
    this.originalError,
  });

  @override
  String toString() => 'ApiException: $message (Status: $statusCode)';
}

class ApiService {
  final Dio _dio;
  final FlutterSecureStorage _storage;
  static const _baseUrl = 'http://192.168.1.56:8101/api';

  // Callback pour la dÃ©connexion en cas d'Ã©chec de refresh
  VoidCallback? onUnauthorized;

  ApiService({
    required Dio dio,
    required FlutterSecureStorage storage,
  })  : _dio = dio,
        _storage = storage {
    _dio.options.baseUrl = _baseUrl;
    _dio.options.headers['accept'] = 'application/json';
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.connectTimeout = const Duration(seconds: 10);
    _dio.options.receiveTimeout = const Duration(seconds: 10);

    _dio.interceptors.add(LogInterceptor(requestBody: true, responseBody: true));

    // Ajouter l'intercepteur pour le refresh token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) async {
          // Ne pas ajouter le token pour les endpoints d'auth
          if (!options.path.contains('/auth/refresh') &&
              !options.path.contains('/auth/login') &&
              !options.path.contains('/users/jwt-by-firebase-token')) {

            final token = await _storage.read(key: 'app_jwt_token');

            if (token != null) {
              options.headers['Authorization'] = 'Bearer $token';
            }
          }

          return handler.next(options);
        },
        onError: (error, handler) async {
          // Si erreur 401 et que ce n'est pas dÃ©jÃ  une tentative de refresh
          if (error.response?.statusCode == 401 &&
              !error.requestOptions.path.contains('/auth/refresh')) {

            try {
              // Tenter de rafraÃ®chir le token
              final newToken = await _refreshToken();

              if (newToken != null) {
                // Rejouer la requÃªte originale avec le nouveau token
                final options = error.requestOptions;
                options.headers['Authorization'] = 'Bearer $newToken';

                final response = await _dio.fetch(options);
                return handler.resolve(response);
              }
            } catch (refreshError) {
              print('âŒ Erreur lors du refresh: $refreshError');
            }

            // Si le refresh Ã©choue, notifier pour dÃ©connecter l'utilisateur
            if (onUnauthorized != null) {
              onUnauthorized!();
            }
          }

          return handler.next(error);
        },
      ),
    );
  }

  bool _isRefreshing = false;
  final List<Completer<String?>> _refreshCompleters = [];

  Future<String?> _refreshToken() async {
    if (_isRefreshing) {
      // Si un refresh est dÃ©jÃ  en cours, attendre son rÃ©sultat
      final completer = Completer<String?>();
      _refreshCompleters.add(completer);
      return completer.future;
    }

    _isRefreshing = true;
    final completer = Completer<String?>();
    _refreshCompleters.add(completer);

    try {
      final refreshToken = await _storage.read(key: 'refresh_token');

      if (refreshToken == null) {
        throw Exception('No refresh token');
      }

      final appJwtToken = await _storage.read(key: 'app_jwt_token');

      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
            extra: {'noToken': true},
            headers: {'Authorization': 'Bearer $appJwtToken'}
        ),
      );

      if (response.statusCode == 200) {
        final newToken = response.data['token'];
        final newRefreshToken = response.data['refresh_token'];

        await _storage.write(key: 'app_jwt_token', value: newToken);
        if (newRefreshToken != null) {
          await _storage.write(key: 'refresh_token', value: newRefreshToken);
        }

        // RÃ©soudre tous les completer en attente
        for (final c in _refreshCompleters) {
          c.complete(newToken);
        }

        return newToken;
      }
    } catch (e) {
      print('âŒ Erreur refresh token: $e');
      // En cas d'erreur, Ã©chouer tous les completer
      for (final c in _refreshCompleters) {
        c.completeError(e);
      }
    } finally {
      _isRefreshing = false;
      _refreshCompleters.clear();
    }

    return null;
  }

  // MÃ©thode gÃ©nÃ©rique pour gÃ©rer les requÃªtes avec gestion d'erreur centralisÃ©e
  Future<T> safeApiCall<T>({
    required Future<T> Function() apiCall,
    String? errorMessage,
  }) async {
    try {
      return await apiCall();
    } on DioException catch (e) {
      throw _handleDioError(e, errorMessage);
    } catch (e) {
      throw ApiException(
        message: errorMessage ?? 'Une erreur inattendue est survenue',
        originalError: e,
      );
    }
  }

  ApiException _handleDioError(DioException e, String? customMessage) {
    String message;
    int? statusCode = e.response?.statusCode;

    switch (e.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        message = 'DÃ©lai de connexion dÃ©passÃ©';
        break;
      case DioExceptionType.badResponse:
        message = _parseErrorResponse(e.response);
        break;
      case DioExceptionType.cancel:
        message = 'RequÃªte annulÃ©e';
        break;
      case DioExceptionType.connectionError:
        message = 'Erreur de connexion rÃ©seau';
        break;
      default:
        message = customMessage ?? 'Erreur rÃ©seau inconnue';
    }

    return ApiException(
      message: message,
      statusCode: statusCode,
      originalError: e,
    );
  }

  String _parseErrorResponse(Response? response) {
    try {
      if (response?.data != null && response!.data is Map) {
        return response.data['message'] ??
            response.data['error'] ??
            'Erreur serveur (${response.statusCode})';
      }
      return 'Erreur serveur (${response?.statusCode ?? 'inconnue'})';
    } catch (_) {
      return 'Erreur serveur inconnue';
    }
  }

  // MÃ©thodes API spÃ©cifiques
  Future<Map<String, dynamic>> getJwtFromFirebaseToken(String firebaseToken) async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.post(
          '/users/jwt-by-firebase-token',
          data: {'token': firebaseToken},
          options: Options(extra: {'noToken': true}),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la rÃ©cupÃ©ration du JWT',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le token JWT',
    );
  }

  // Nouvelle mÃ©thode pour rÃ©voquer le refresh token (logout)
  Future<void> revokeRefreshToken(String refreshToken) async {
    try {
      final token = await _storage.read(key: 'app_jwt_token');
      await _dio.post(
        '/auth/logout',
        data: {'refresh_token': refreshToken},
        options: Options(
          headers: token != null ? {'Authorization': 'Bearer $token'} : {},
          extra: {'noToken': true},
        ),
      );
    } catch (e) {
      print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
    }
  }

  Future<Map<String, dynamic>> generateLiveKitToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return safeApiCall(
      apiCall: () async {
        final payload = {
          "participant_identity": participantIdentity,
          "participant_name": participantName,
          "participant_metadata": participantMetadata,
          "participant_attributes": participantAttributes,
          "room_name": roomName,
          "room_config": roomConfig
        };

        final appJwt = await _storage.read(key: 'app_jwt_token');

        if (appJwt == null) {
          throw ApiException(message: 'JWT token non disponible');
        }

        final response = await _dio.post(
          '/sfu/generate-token',
          data: payload,
          options: Options(
            headers: {
              'Authorization': 'Bearer $appJwt',
            },
          ),
        );

        if (response.statusCode == 200) {
          return response.data as Map<String, dynamic>;
        } else {
          throw ApiException(
            message: 'Erreur lors de la gÃ©nÃ©ration du token LiveKit',
            statusCode: response.statusCode,
          );
        }
      },
      errorMessage: 'Impossible de gÃ©nÃ©rer le token LiveKit',
    );
  }

  // Profile methods
  Future<Map<String, dynamic>> getProfile() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/me');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer le profil',
    );
  }

  Future<Map<String, dynamic>> getAboutMe() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/about-me');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer "Ã  propos"',
    );
  }

  Future<Map<String, dynamic>> getPhoto() async {
    return safeApiCall(
      apiCall: () async {
        final response = await _dio.get('/account/photo');
        return response.data as Map<String, dynamic>;
      },
      errorMessage: 'Impossible de rÃ©cupÃ©rer la photo',
    );
  }

  Future<void> updateProfile({
    String? displayName,
    int? gender,
    DateTime? birthdate,
  }) async {
    return safeApiCall(
      apiCall: () async {
        final data = <String, dynamic>{};
        if (displayName != null) data['displayName'] = displayName;
        if (gender != null) data['gender'] = gender;
        if (birthdate != null) data['birthdate'] = birthdate.toIso8601String();

        await _dio.put('/account/me', data: data);
      },
      errorMessage: 'Impossible de mettre Ã  jour le profil',
    );
  }

  Future<void> updateAboutMe(String aboutMe) async {
    return safeApiCall(
      apiCall: () async {
        await _dio.put('/account/about-me', data: {'about_me': aboutMe});
      },
      errorMessage: 'Impossible de mettre Ã  jour "Ã  propos"',
    );
  }

  Future<void> updatePhoto(String photoPath) async {
    return safeApiCall(
      apiCall: () async {
        final formData = FormData.fromMap({
          'photo': await MultipartFile.fromFile(photoPath),
        });
        await _dio.put('/account/photo', data: formData);
      },
      errorMessage: 'Impossible de mettre Ã  jour la photo',
    );
  }


// Dans flutter_lib/services/api_service.dart

  Future<Map<String, dynamic>?> refreshJwtToken(String refreshToken) async {
    try {
      final response = await _dio.post(
        '/auth/refresh',
        data: {'refresh_token': refreshToken},
        options: Options(
          extra: {'noToken': true},
        ),
      );

      if (response.statusCode == 200) {
        return response.data as Map<String, dynamic>;
      }
    } catch (e) {
      print('âŒ Erreur refresh token API: $e');
    }

    return null;
  }


}

@riverpod
ApiService apiService(Ref ref) {
  final dio = Dio();
  final storage = const FlutterSecureStorage();
  return ApiService(dio: dio, storage: storage);
}


FICHIER: flutter_lib/services/api_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'api_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(apiService)
final apiServiceProvider = ApiServiceProvider._();

final class ApiServiceProvider
    extends $FunctionalProvider<ApiService, ApiService, ApiService>
    with $Provider<ApiService> {
  ApiServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'apiServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$apiServiceHash();

  @$internal
  @override
  $ProviderElement<ApiService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  ApiService create(Ref ref) {
    return apiService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ApiService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ApiService>(value),
    );
  }
}

String _$apiServiceHash() => r'eb9a66cc54e1c15d5870b8da260d4ea1f6b053ac';



FICHIER: flutter_lib/services/auth_service.dart
--------------------------------------------------------------------------------
import 'dart:developer';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'api_service.dart';

class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;
  final ApiService _apiService;

  final _storage = const FlutterSecureStorage();

  static const _tokenKey = 'firebase_id_token';
  static const _appJwtKey = 'app_jwt_token';
  static const _refreshTokenKey = 'refresh_token';
  static const _userIdentityKey = 'connected_user_identity';
  static const _userDisplayNameKey = 'connected_user_displayname';

  Future<void> Function(GoogleSignInAuthenticationEvent)? onAuthenticationEvent;
  Future<void> Function(Object)? onAuthenticationError;

  AuthService({
    this.onAuthenticationEvent,
    this.onAuthenticationError,
    required ApiService apiService,
  }) : _apiService = apiService;

  User? get currentUser => _firebaseAuth.currentUser;

  Stream<User?> get authStateChanges => _firebaseAuth.authStateChanges();

  bool _isSignInInitialized = false;

  String? clientId;
  String? serverClientId = '1084343369802-36565dmgarm2gkos54eb6j9q6so0s9bf.apps.googleusercontent.com';
  List<String> scopes = <String>[
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
  ];
  final GoogleSignIn signIn = GoogleSignIn.instance;

  Future<void> _handleAuthenticationEvent(GoogleSignInAuthenticationEvent event) async {
    final GoogleSignInAccount? user = switch (event) {
      GoogleSignInAuthenticationEventSignIn() => event.user,
      GoogleSignInAuthenticationEventSignOut() => null,
    };

    final GoogleSignInClientAuthorization? authorization = await user?.authorizationClient.authorizationForScopes(scopes);

    if (user != null && authorization != null) {
      print(user);
      print("===== user =======");

      try {
        final OAuthCredential googleCredential = GoogleAuthProvider.credential(
          accessToken: authorization.accessToken,
          idToken: user.authentication.idToken,
        );

        final UserCredential googleUserCredential = await FirebaseAuth.instance.signInWithCredential(googleCredential);

        IdTokenResult tokenResult = await FirebaseAuth.instance.currentUser!.getIdTokenResult();

        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        print('============================ tokenResult.token ==================================');
        log(tokenResult.token.toString());

        if (tokenResult.token != null) {
          await _storage.write(key: _tokenKey, value: tokenResult.token);
          await _storage.write(key: _userIdentityKey, value: user.displayName);
          await _storage.write(key: _userDisplayNameKey, value: user.displayName);

          try {
            print('ğŸ”„ RÃ©cupÃ©ration du JWT applicatif... =======================================');
            final response = await _apiService.getJwtFromFirebaseToken(tokenResult.token!);

            // La rÃ©ponse contient maintenant jwt ET refresh_token
            if (response is Map<String, dynamic>) {
              print('TOKEN ==============');
              log('***** from firebase token : ' + response['token'].toString());
              await _storage.write(key: _appJwtKey, value: response['token']);
              if (response['refresh_token'] != null) {
                print('REFRESH TOKEN ==============');
                print(response['refresh_token']);
                await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
              }
            } else {
              // Pour compatibilitÃ© avec l'ancien format
              await _storage.write(key: _appJwtKey, value: response.toString());
            }

            print('âœ… JWT applicatif rÃ©cupÃ©rÃ© et stockÃ©');
          } catch (e) {
            print('âŒ Erreur lors de la rÃ©cupÃ©ration du JWT applicatif: $e');
          }

          if (onAuthenticationEvent != null) {
            await onAuthenticationEvent!(event);
          }

          print(tokenResult.token);
          print("====== tokenResult.token =======");
        }
      } catch (error) {
        print(error);
        print('error');

        if (onAuthenticationError != null) {
          await onAuthenticationError!(error);
        }
      }
    }
  }

  Future<void> _handleAuthenticationError(Object e) async {
    print(e);
    if (onAuthenticationError != null) {
      await onAuthenticationError!(e);
    }
  }

  Future<void> initGoogleSignIn() async {
    if (_isSignInInitialized) return;

    _isSignInInitialized = true;

    await signIn.initialize(clientId: clientId, serverClientId: serverClientId).then((_) async {
      signIn.authenticationEvents.listen(_handleAuthenticationEvent).onError(_handleAuthenticationError);
    });
  }

  Future<User?> signInWithGoogle() async {
    await initGoogleSignIn();

    if (GoogleSignIn.instance.supportsAuthenticate()) {
      try {
        await GoogleSignIn.instance.authenticate();
      } catch (e) {
        print("Erreur Google Sign-In : $e");
      }
    }
  }

  Future<String?> getAppJwt() async {
    return await _storage.read(key: _appJwtKey);
  }

  Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }

  /*
  // Nouvelle mÃ©thode pour rafraÃ®chir le token
  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }

   */

  // MÃ©thode de dÃ©connexion amÃ©liorÃ©e
  Future<void> signOut() async {
    print('ğŸ”´ DÃ‰BUT DÃ‰CONNEXION - Utilisateur avant: ${_firebaseAuth.currentUser?.uid}');

    try {
      // 1. RÃ©voquer le refresh token cÃ´tÃ© serveur
      final refreshToken = await getRefreshToken();
      if (refreshToken != null) {
        try {
          await _apiService.revokeRefreshToken(refreshToken);
          print('âœ… Refresh token rÃ©voquÃ© cÃ´tÃ© serveur');
        } catch (e) {
          print('âš ï¸ Erreur lors de la rÃ©vocation du refresh token: $e');
        }
      }

      // 2. DÃ©connexion Google
      await GoogleSignIn.instance.signOut();

      // 3. DÃ©connexion Firebase
      print('ğŸŸ¡ DÃ©connexion Firebase...');
      await _firebaseAuth.signOut();
      print('âœ… Firebase signOut() exÃ©cutÃ©');

      // 4. VÃ©rification post-dÃ©connexion
      final userAfter = _firebaseAuth.currentUser;
      print('ğŸ‘¤ Utilisateur aprÃ¨s Firebase.signOut(): $userAfter');

      // 5. Attendre un cycle d'event loop pour propager le changement
      await Future.delayed(const Duration(milliseconds: 100));

      // 6. Nettoyer le stockage
      print('ğŸŸ¡ Nettoyage du stockage...');
      await _storage.delete(key: _tokenKey);
      await _storage.delete(key: _appJwtKey);
      await _storage.delete(key: _refreshTokenKey);
      await _storage.delete(key: _userIdentityKey);
      await _storage.delete(key: _userDisplayNameKey);
      print('âœ… Stockage nettoyÃ©');

      // 7. VÃ©rification finale
      final finalUser = _firebaseAuth.currentUser;
      if (finalUser != null) {
        print('âš ï¸ ATTENTION: Utilisateur toujours prÃ©sent aprÃ¨s dÃ©connexion!');
        await forceSignOut();
      } else {
        print('âœ… Utilisateur bien null aprÃ¨s dÃ©connexion');
      }

      print('âœ… DÃ‰CONNEXION TERMINÃ‰E');
    } catch (e, stack) {
      print('âŒ ERREUR DÃ‰CONNEXION: $e');
      print('ğŸ“š Stack: $stack');
      rethrow;
    }
  }

  // MÃ©thode utilitaire pour forcer une dÃ©connexion radicale
  Future<void> forceSignOut() async {
    print('ğŸ”´ FORCE SIGN OUT - MÃ©thode radicale');

    try {
      await _firebaseAuth.signOut();
      await GoogleSignIn.instance.signOut();
      await _storage.deleteAll();
      await Future.delayed(const Duration(milliseconds: 200));
      print('âœ… Force sign out exÃ©cutÃ©');
      print('ğŸ‘¤ Utilisateur aprÃ¨s force: ${_firebaseAuth.currentUser?.uid ?? 'null'}');
    } catch (e) {
      print('âŒ Erreur force sign out: $e');
    }
  }

  bool isLoggedIn() {
    return _firebaseAuth.currentUser != null;
  }

  Future<bool> isUserLoggedIn() async {
    return _firebaseAuth.currentUser != null;
  }


  Future<String?> refreshJwtToken() async {
    try {
      final refreshToken = await getRefreshToken();

      if (refreshToken == null) {
        print('âš ï¸ Pas de refresh token disponible');
        return null;
      }

      print('ğŸ”„ Tentative de rafraÃ®chissement du token...');
      final response = await _apiService.refreshJwtToken(refreshToken);

      if (response != null) {
        // Stocker le nouveau token
        await _storage.write(key: _appJwtKey, value: response['token']);

        // Si un nouveau refresh token est fourni (rotation), le stocker
        if (response['refresh_token'] != null) {
          await _storage.write(key: _refreshTokenKey, value: response['refresh_token']);
        }

        print('âœ… Token rafraÃ®chi avec succÃ¨s');
        return response['token'];
      }
    } catch (e) {
      print('âŒ Erreur lors du rafraÃ®chissement du token: $e');
    }

    return null;
  }
}


FICHIER: flutter_lib/services/sfu_service.dart
--------------------------------------------------------------------------------
// CrÃ©er un nouveau fichier: flutter_lib/features/tables/services/sfu_service.dart

import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../../services/api_service.dart';

part 'sfu_service.g.dart';

class SfuService {
  final ApiService _apiService;

  SfuService({required ApiService apiService}) : _apiService = apiService;

  Future<Map<String, dynamic>> generateToken({
    required String participantIdentity,
    required String participantName,
    required String roomName,
    String participantMetadata = '',
    Map<String, dynamic> participantAttributes = const {},
    Map<String, dynamic> roomConfig = const {},
  }) async {
    return _apiService.generateLiveKitToken(
      participantIdentity: participantIdentity,
      participantName: participantName,
      participantAttributes: participantAttributes,
      participantMetadata: participantMetadata,
      roomName: roomName,
      roomConfig: roomConfig,
    );
  }
}

@riverpod
SfuService sfuService(Ref ref) {
  final apiService = ref.watch(apiServiceProvider);
  return SfuService(apiService: apiService);
}


FICHIER: flutter_lib/services/sfu_service.g.dart
--------------------------------------------------------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sfu_service.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(sfuService)
final sfuServiceProvider = SfuServiceProvider._();

final class SfuServiceProvider
    extends $FunctionalProvider<SfuService, SfuService, SfuService>
    with $Provider<SfuService> {
  SfuServiceProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'sfuServiceProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$sfuServiceHash();

  @$internal
  @override
  $ProviderElement<SfuService> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  SfuService create(Ref ref) {
    return sfuService(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(SfuService value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<SfuService>(value),
    );
  }
}

String _$sfuServiceHash() => r'eec97a26458eb6027d15e5c5845938b8e56f520d';



FICHIER: src/Domain/Entity/User.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\Entity;

use App\Domain\ValueObject\Email;
use App\Domain\ValueObject\UserRole;

/**
 * Domain Entity - Aucune dÃ©pendance vers Doctrine ou Symfony
 */
class User
{
    private ?int $id = null;
    private Email $email;
    private array $roles = [];
    private string $password;
    private ?string $firstname = null;
    private ?string $lastname = null;
    private bool $isActive = true;
    private \DateTimeInterface $createdAt;
    private ?\DateTimeInterface $updatedAt = null;

    public function __construct(
        Email $email,
        string $hashedPassword,
        ?string $firstname = null,
        ?string $lastname = null
    ) {
        $this->email = $email;
        $this->password = $hashedPassword;
        $this->firstname = $firstname;
        $this->lastname = $lastname;
        $this->roles = [UserRole::ROLE_USER];
        $this->createdAt = new \DateTime();
    }

    public static function create(
        string $email,
        string $hashedPassword,
        ?string $firstname = null,
        ?string $lastname = null
    ): self {
        return new self(
            new Email($email),
            $hashedPassword,
            $firstname,
            $lastname
        );
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function getEmail(): Email
    {
        return $this->email;
    }

    public function changeEmail(Email $email): void
    {
        $this->email = $email;
        $this->markAsUpdated();
    }

    public function getRoles(): array
    {
        return array_unique($this->roles);
    }

    public function addRole(string $role): void
    {
        if (!in_array($role, $this->roles)) {
            $this->roles[] = $role;
            $this->markAsUpdated();
        }
    }

    public function removeRole(string $role): void
    {
        $this->roles = array_filter($this->roles, fn($r) => $r !== $role);
        $this->markAsUpdated();
    }

    public function hasRole(string $role): bool
    {
        return in_array($role, $this->roles);
    }

    public function getPassword(): string
    {
        return $this->password;
    }

    public function changePassword(string $hashedPassword): void
    {
        $this->password = $hashedPassword;
        $this->markAsUpdated();
    }

    public function getFirstname(): ?string
    {
        return $this->firstname;
    }

    public function setFirstname(?string $firstname): void
    {
        $this->firstname = $firstname;
        $this->markAsUpdated();
    }

    public function getLastname(): ?string
    {
        return $this->lastname;
    }

    public function setLastname(?string $lastname): void
    {
        $this->lastname = $lastname;
        $this->markAsUpdated();
    }

    public function getFullName(): string
    {
        return trim(($this->firstname ?? '') . ' ' . ($this->lastname ?? ''));
    }

    public function isActive(): bool
    {
        return $this->isActive;
    }

    public function activate(): void
    {
        $this->isActive = true;
        $this->markAsUpdated();
    }

    public function deactivate(): void
    {
        $this->isActive = false;
        $this->markAsUpdated();
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    private function markAsUpdated(): void
    {
        $this->updatedAt = new \DateTime();
    }
}


FICHIER: src/Domain/Repository/UserRepositoryInterface.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\Repository;

use App\Domain\ValueObject\Email;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;

/**
 * Repository Interface (Port) - Contrat du domaine
 */
interface UserRepositoryInterface
{
    public function save(UserEntity $user): void;

    public function delete(UserEntity $user): void;

    public function findById(int $id): ?UserEntity;

    public function findByEmail(Email $email): ?UserEntity;

    /**
     * @return UserEntity[]
     */
    public function findAll(): array;

    /**
     * @return UserEntity[]
     */
    public function findActiveUsers(): array;

    /**
     * @return UserEntity[]
     */
    public function findByRole(string $role): array;

    /**
     * @return UserEntity[]
     */
    public function search(string $searchTerm): array;

    public function countActiveUsers(): int;

    public function existsByEmail(Email $email): bool;
}



FICHIER: src/Domain/ValueObject/Email.php
--------------------------------------------------------------------------------
<?php

namespace App\Domain\ValueObject;

/**
 * Value Object Email
 */
class Email
{
    private string $value;

    public function __construct(string $email)
    {
        $this->validate($email);
        $this->value = strtolower($email);
    }

    private function validate(string $email): void
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \InvalidArgumentException(sprintf('"%s" is not a valid email', $email));
        }
    }

    public function getValue(): string
    {
        return $this->value;
    }

    public function __toString(): string
    {
        return $this->value;
    }

    public function equals(Email $other): bool
    {
        return $this->value === $other->value;
    }
}


FICHIER: src/Domain/ValueObject/UserRole.php
--------------------------------------------------------------------------------
<?php
namespace App\Domain\ValueObject;

class UserRole
{
    public const ROLE_USER = 'ROLE_USER';
    public const ROLE_ADMIN = 'ROLE_ADMIN';
    public const ROLE_MODERATOR = 'ROLE_MODERATOR';

    private const VALID_ROLES = [
        self::ROLE_USER,
        self::ROLE_ADMIN,
        self::ROLE_MODERATOR,
    ];

    public static function isValid(string $role): bool
    {
        return in_array($role, self::VALID_ROLES);
    }

    public static function validate(string $role): void
    {
        if (!self::isValid($role)) {
            throw new \InvalidArgumentException(sprintf('Invalid role: %s', $role));
        }
    }
}


FICHIER: src/Infrastructure/Console/Command/ClearExpiredRefreshTokensCommand.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Console/Command/ClearExpiredRefreshTokensCommand.php

namespace App\Infrastructure\Console\Command;

use App\Infrastructure\Persistence\Doctrine\Repository\RefreshTokenRepository;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

#[AsCommand(
    name: 'app:clear-expired-refresh-tokens',
    description: 'Supprime les refresh tokens expirÃ©s'
)]
class ClearExpiredRefreshTokensCommand extends Command
{
    public function __construct(
        private readonly RefreshTokenRepository $refreshTokenRepository
    ) {
        parent::__construct();
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $deleted = $this->refreshTokenRepository->deleteExpired();
        $output->writeln(sprintf('%d refresh tokens expirÃ©s supprimÃ©s.', $deleted));

        return Command::SUCCESS;
    }
}



FICHIER: src/Infrastructure/Http/Controller/AccountController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Security\Http\Attribute\CurrentUser;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;

#[Route('/api/account')]
#[OA\Tag(name: 'account')]
class AccountController extends AbstractController
{
    private const PHOTO_UPLOAD_DIR = '/upload/photos';
    private const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    private const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

    public function __construct(
        private readonly UserRepository $userRepository,
        private readonly SerializerInterface $serializer,
        private readonly ValidatorInterface $validator,
        private readonly string $projectDir,
    ) {}

    #[Route('/me', name: 'account_get_me', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les informations du compte',
        responses: [
            new OA\Response(
                response: 200,
                description: 'Informations du compte',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'string'),
                        new OA\Property(property: 'displayName', type: 'string', nullable: true),
                        new OA\Property(property: 'gender', type: 'integer', nullable: true),
                        new OA\Property(property: 'birthdate', type: 'string', format: 'date', nullable: true),
                        new OA\Property(property: 'about_me', type: 'string', nullable: true),
                        new OA\Property(property: 'has_photo', type: 'boolean'),
                        new OA\Property(property: 'first_access', type: 'boolean'),
                        new OA\Property(property: 'photo_url', type: 'string', nullable: true),
                    ]
                )
            )
        ]
    )]
    public function getMe(#[CurrentUser] UserEntity $user): JsonResponse
    {
        // SÃ©curitÃ© : s'assurer que hasPhoto est initialisÃ©
        $hasPhoto = false;
        try {
            $hasPhoto = $user->hasPhoto();
        } catch (\Error $e) {
            $hasPhoto = false;
        }

        $firstAccess = false;
        try {
            $firstAccess = $user->isFirstAccess();
        } catch (\Error $e) {
            $firstAccess = false;
        }

        // Si c'est la premiÃ¨re fois qu'on accÃ¨de Ã  /account/me, mettre first_access Ã  false
        if ($firstAccess) {
            $user->setFirstAccess(false);
            $this->userRepository->save($user);
        }

        // Construire l'URL de la photo si elle existe
        $photoUrl = null;
        if ($hasPhoto) {
            // On suppose que la photo est en jpg, mais on pourrait dÃ©tecter l'extension rÃ©elle
            $photoUrl = '/api/photo/' . $user->getAuthUid() . '.jpg';
        }

        return $this->json([
            'id' => $user->getEmail() ?? $user->getAuthUid(),
            'displayName' => $user->getDisplayName() ?? $user->getUsername(),
            'gender' => $user->getGender(),
            'birthdate' => $user->getBirthdate()?->format('Y-m-d'),
            'about_me' => $user->getAboutMe(),
            'has_photo' => $hasPhoto,
            'first_access' => $firstAccess,
            'photo_url' => $photoUrl,
        ]);
    }

    #[Route('/me', name: 'account_update_me', methods: ['PUT'])]
    #[OA\Put(
        summary: 'Met Ã  jour les informations du compte',
        requestBody: new OA\RequestBody(
            content: new OA\JsonContent(
                properties: [
                    new OA\Property(property: 'displayName', type: 'string', nullable: true),
                    new OA\Property(property: 'gender', type: 'integer', nullable: true),
                    new OA\Property(property: 'birthdate', type: 'string', format: 'date', nullable: true),
                ]
            )
        )
    )]
    public function updateMe(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (isset($data['displayName'])) {
            $user->setDisplayName($data['displayName']);
        }

        if (isset($data['gender'])) {
            $user->setGender((int) $data['gender']);
        }

        if (isset($data['birthdate'])) {
            try {
                $user->setBirthdate(new \DateTime($data['birthdate']));
            } catch (\Exception $e) {
                return $this->json(['error' => 'Format de date invalide'], Response::HTTP_BAD_REQUEST);
            }
        }

        $errors = $this->validator->validate($user);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->userRepository->save($user);

        return $this->json(['success' => true]);
    }

    #[Route('/about-me', name: 'account_get_about_me', methods: ['GET'])]
    public function getAboutMe(#[CurrentUser] UserEntity $user): JsonResponse
    {
        return $this->json([
            'about_me' => $user->getAboutMe(),
        ]);
    }

    #[Route('/about-me', name: 'account_update_about_me', methods: ['PUT'])]
    public function updateAboutMe(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (isset($data['about_me'])) {
            $user->setAboutMe($data['about_me']);
            $this->userRepository->save($user);
        }

        return $this->json(['success' => true]);
    }

    #[Route('/photo', name: 'account_get_photo', methods: ['GET'])]
    public function getPhoto(#[CurrentUser] UserEntity $user): JsonResponse
    {
        $photoUrl = null;

        if ($user->hasPhoto()) {
            // Construire l'URL de la photo
            $photoUrl = '/uploads/photos/' . $user->getAuthUid() . '.jpg';
        }

        return $this->json([
            'photo_url' => $photoUrl,
            'has_photo' => $user->hasPhoto(),
        ]);
    }

    #[Route('/photo', name: 'account_delete_photo', methods: ['DELETE'])]
    public function deletePhoto(#[CurrentUser] UserEntity $user): JsonResponse
    {
        if (!$user->hasPhoto()) {
            return $this->json(['error' => 'Aucune photo Ã  supprimer'], Response::HTTP_BAD_REQUEST);
        }

        try {
            $this->deleteOldPhoto($user);
            $user->updatePhotoStatus(false);
            $this->userRepository->save($user);

            return $this->json([
                'success' => true,
                'message' => 'Photo supprimÃ©e avec succÃ¨s'
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Erreur lors de la suppression: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * Valide le fichier photo
     */
    private function validatePhoto(UploadedFile $file): bool
    {
        // VÃ©rifier la taille
        if ($file->getSize() > self::MAX_FILE_SIZE) {
            return false;
        }

        // VÃ©rifier le type MIME
        $mimeType = $file->getMimeType();
        if (!in_array($mimeType, self::ALLOWED_MIME_TYPES)) {
            return false;
        }

        return true;
    }

    /**
     * Supprime l'ancienne photo
     */
    private function deleteOldPhoto(UserEntity $user): void
    {
        $uploadDir = $this->projectDir . self::PHOTO_UPLOAD_DIR;

        // Chercher tous les fichiers commenÃ§ant par l'auth_uid
        $pattern = $uploadDir . '/' . $user->getAuthUid() . '.*';
        $oldFiles = glob($pattern);

        foreach ($oldFiles as $file) {
            if (is_file($file)) {
                unlink($file);
            }
        }
    }

    #[Route('/photo', name: 'account_update_photo', methods: ['PUT'])]
    public function updatePhoto(Request $request, #[CurrentUser] UserEntity $user): JsonResponse
    {
        /** @var UploadedFile|null $photo */
        $photo = $request->files->get('photo');

        if (!$photo) {
            return $this->json(['error' => 'Aucune photo fournie'], Response::HTTP_BAD_REQUEST);
        }

        // Validation du fichier
        if (!$this->validatePhoto($photo)) {
            return $this->json([
                'error' => 'Format de fichier invalide. Types acceptÃ©s: JPEG, PNG, GIF, WEBP. Taille max: 5MB'
            ], Response::HTTP_BAD_REQUEST);
        }

        try {
            // CrÃ©er le dossier d'upload s'il n'existe pas
            $uploadDir = $this->projectDir . self::PHOTO_UPLOAD_DIR;
            if (!is_dir($uploadDir)) {
                mkdir($uploadDir, 0755, true);
            }

            // GÃ©nÃ©rer un nom de fichier basÃ© sur l'auth_uid
            $extension = $photo->guessExtension() ?? 'jpg';
            $filename = $user->getAuthUid() . '.' . $extension;
            $filepath = $uploadDir . '/' . $filename;

            // Supprimer l'ancienne photo si elle existe
            if ($user->hasPhoto()) {
                $this->deleteOldPhoto($user);
            }

            // DÃ©placer le fichier
            $photo->move($uploadDir, $filename);

            // Mettre Ã  jour le statut has_photo
            $user->updatePhotoStatus(true);
            $this->userRepository->save($user);

            // Construire l'URL de la photo via notre nouveau controller
            $photoUrl = '/api/photo/' . $filename;

            return $this->json([
                'success' => true,
                'photo_url' => $photoUrl,
                'has_photo' => true,
                'message' => 'Photo tÃ©lÃ©chargÃ©e avec succÃ¨s'
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Erreur lors du tÃ©lÃ©chargement: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}



FICHIER: src/Infrastructure/Http/Controller/AuthController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use OpenApi\Attributes as OA;

#[OA\Tag(name: 'auth')]
class AuthController extends AbstractController
{
    public function __construct(
        private UserPasswordHasherInterface $passwordHasher
    ) {}

    #[Route('/api/auth/login', name: 'api_auth_login', methods: ['POST'])]
    #[OA\Post(
        summary: 'Authentifie un utilisateur et renvoie un JWT',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                type: 'object',
                required: ['email', 'password'],
                properties: [
                    new OA\Property(property: 'email', type: 'string', example: 'user@example.com'),
                    new OA\Property(property: 'password', type: 'string', example: 'MonMotDePasse123!')
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Token JWT renvoyÃ©',
                content: new OA\JsonContent(
                    type: 'object',
                    properties: [
                        new OA\Property(property: 'token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIsInR5...')
                    ]
                )
            ),
            new OA\Response(response: 401, description: 'Identifiants invalides')
        ]
    )]
    public function login(): void
    {
        // Lexik gÃ¨re la logique, on ne met rien ici
    }

    #[Route('/api/auth/generate-password', name: 'api_auth_generate_password', methods: ['POST'])]
    #[OA\Post(
        summary: 'Hash un mot de passe en clair (utile pour tests ou crÃ©ation manuelle dâ€™utilisateurs).',
        requestBody: new OA\RequestBody(
            required: true,
            description: 'Mot de passe Ã  chiffrer',
            content: new OA\JsonContent(
                type: 'object',
                required: ['password'],
                properties: [
                    new OA\Property(property: 'password', type: 'string', example: 'MonMotDePasse123!')
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Mot de passe chiffrÃ© renvoyÃ© avec succÃ¨s',
                content: new OA\JsonContent(
                    type: 'object',
                    properties: [
                        new OA\Property(property: 'hash', type: 'string', example: '$2y$13$abc123...')
                    ]
                )
            )
        ]
    )]
    public function generatePassword(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        if (!isset($data['password']) || !is_string($data['password']) || $data['password'] === '') {
            return $this->json(['error' => 'Le champ "password" est requis.'], 400);
        }

        $plain = $data['password'];

        if (strlen($plain) < 8) {
            return $this->json(['error' => 'Le mot de passe doit faire au moins 8 caractÃ¨res.'], 400);
        }

        // Fake user conforme Ã  lâ€™interface PasswordAuthenticatedUserInterface
        $user = new class implements PasswordAuthenticatedUserInterface {
            public function getPassword(): ?string { return null; }
        };

        $hash = $this->passwordHasher->hashPassword($user, $plain);

        return $this->json(['hash' => $hash]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/GenerateLiveKitController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Agence104\LiveKit\AccessToken;
use Agence104\LiveKit\AccessTokenOptions;
use Agence104\LiveKit\VideoGrant;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/sfu/generate-token')]
#[OA\Tag(name: 'sfu')]
class GenerateLiveKitController extends AbstractController
{
    public function __construct(
        private readonly string $livekitApiKey,
        private readonly string $livekitApiSecret,
        private readonly string $livekitUrl,
    ) {
    }

    #[Route('', name: 'sfu_generate_token', methods: ['POST'])]
    #[OA\Post(
        description: 'GÃ©nÃ¨re un token JWT pour LiveKit SFU',
        summary: 'GÃ©nÃ©rer un token d\'accÃ¨s LiveKit',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['participant_identity', 'room_name'],
                properties: [
                    new OA\Property(property: 'participant_identity', type: 'string', description: 'Identifiant unique du participant'),
                    new OA\Property(property: 'participant_name', type: 'string', description: 'Nom du participant'),
                    new OA\Property(property: 'participant_metadata', type: 'string', description: 'MÃ©tadonnÃ©es du participant'),
                    new OA\Property(property: 'participant_attributes', type: 'object', description: 'Attributs du participant'),
                    new OA\Property(property: 'room_name', type: 'string', description: 'Nom de la salle'),
                    new OA\Property(property: 'room_config', type: 'object', description: 'Configuration de la salle'),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Token gÃ©nÃ©rÃ© avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'server_url', type: 'string', example: 'wss://livekit.example.com'),
                        new OA\Property(property: 'participant_token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIs...'),
                    ]
                )
            ),
            new OA\Response(
                response: 400,
                description: 'RequÃªte invalide'
            )
        ]
    )]
    public function generateSfuToken(Request $request): JsonResponse
    {
        try {
            // DÃ©coder le corps de la requÃªte JSON
            $body = json_decode($request->getContent(), true);

            // Valider que nous avons du JSON valide
            if (json_last_error() !== JSON_ERROR_NONE) {
                return $this->json([
                    'error' => 'Invalid JSON in request body'
                ], Response::HTTP_BAD_REQUEST);
            }

            // Valider les champs requis
            if (!isset($body['participant_identity']) || !isset($body['room_name'])) {
                return $this->json([
                    'error' => 'Missing required fields: participant_identity and room_name are required'
                ], Response::HTTP_BAD_REQUEST);
            }

            // DÃ©finir les options du token
            $tokenOptions = (new AccessTokenOptions())
                ->setIdentity($body['participant_identity'])
                ->setName($body['participant_name'] ?? $body['participant_identity']);

            // Ajouter les mÃ©tadonnÃ©es si prÃ©sentes
            if (!empty($body['participant_metadata'])) {
                $tokenOptions = $tokenOptions->setMetadata($body['participant_metadata']);
            }

            // Ajouter les attributs si prÃ©sents
            if (!empty($body['participant_attributes']) && is_array($body['participant_attributes'])) {
                $tokenOptions = $tokenOptions->setAttributes($body['participant_attributes']);
            }

            // DÃ©finir les grants vidÃ©o
            $roomName = $body['room_name'];
            $videoGrant = (new VideoGrant())
                ->setRoomJoin()
                ->setRoomName($roomName);

            // CrÃ©er le token
            $token = (new AccessToken($this->livekitApiKey, $this->livekitApiSecret))
                ->init($tokenOptions)
                ->setGrant($videoGrant);

            // Ajouter la configuration de la salle si prÃ©sente
            if (!empty($body['room_config']) && is_array($body['room_config'])) {
                $token = $token->setRoomConfig($body['room_config']);
            }

            // Retourner la rÃ©ponse JSON
            return $this->json([
                'server_url' => $this->livekitUrl,
                'participant_token' => $token->toJwt(),
                'participant_identity' => $body['participant_identity'],
                'participant_name' => $body['participant_name'],
                'room_name' => $body['room_name'],
            ]);

        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Failed to generate token: ' . $e->getMessage()
            ], Response::HTTP_INTERNAL_SERVER_ERROR);
        }
    }
}



FICHIER: src/Infrastructure/Http/Controller/GeneratePromptController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Finder\Finder;

#[Route('/api/generate-prompt')]
#[OA\Tag(name: 'ia assistant', description: 'GÃ©nÃ©ration de prompts pour l\'IA')]
class GeneratePromptController extends AbstractController
{
    #[Route('', name: 'generate_prompt', methods: ['GET'])]
    #[OA\Get(
        description: 'Exporte des fichiers et dossiers au format texte brut pour analyse par IA',
        summary: 'GÃ©nÃ¨re un prompt texte contenant l\'arborescence et le code source',
        parameters: [
            new OA\Parameter(
                name: 'paths',
                description: 'Chemin des dossiers Ã  analyser (sÃ©parÃ©s par des virgules) - absolus ou relatifs Ã  la racine du projet',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    example: 'src,config,templates'
                )
            ),
            new OA\Parameter(
                name: 'files',
                description: 'Chemin des fichiers individuels Ã  analyser (sÃ©parÃ©s par des virgules) - absolus ou relatifs Ã  la racine du projet',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    example: 'src/Controller/GeneratePromptController.php,config/routes.yaml'
                )
            ),
            new OA\Parameter(
                name: 'extensions',
                description: 'Liste des extensions de fichiers Ã  inclure (sÃ©parÃ©es par des virgules)',
                in: 'query',
                required: false,
                schema: new OA\Schema(
                    type: 'string',
                    default: 'php,dart,html,twig,js,css',
                    example: 'php,twig,yaml'
                )
            ),
        ]
    )]
    public function generatePrompt(Request $request): Response
    {
        $pathsParam = $request->query->get('paths');
        $filesParam = $request->query->get('files');
        $extensions = $request->query->get('extensions', 'php,dart,html,twig,js,css');

        // VÃ©rifier qu'au moins un paramÃ¨tre est fourni
        if (!$pathsParam && !$filesParam) {
            return new Response(
                "ERREUR: Vous devez fournir au moins un dossier (paths) ou un fichier (files) Ã  analyser.\n",
                Response::HTTP_BAD_REQUEST,
                ['Content-Type' => 'text/plain']
            );
        }

        $allowedExtensions = array_map('trim', explode(',', $extensions));
        $warningMessages = [];
        $allFiles = [];
        $allDirs = [];

        // Traitement des dossiers (paths)
        $resolvedPaths = [];
        if ($pathsParam) {
            $pathsParam = str_replace(" ", "", $pathsParam);
            $pathsParam = str_replace("\n", "", $pathsParam);
            $pathsParam = trim($pathsParam);
            $pathsParam = rtrim($pathsParam, ',');


            $rawPaths = array_map('trim', explode(',', $pathsParam));

            foreach ($rawPaths as $path) {
                // RÃ©soudre le chemin absolu
                if (!str_starts_with($path, '/')) {
                    $path = $this->getParameter('kernel.project_dir') . '/' . $path;
                }

                $realPath = realpath($path);

                if ($realPath && is_dir($realPath)) {
                    $resolvedPaths[] = $realPath;
                } else {
                    $warningMessages[] = "Dossier ignorÃ© (invalide): " . $path;
                }
            }

            // Collecter les fichiers des dossiers valides
            foreach ($resolvedPaths as $rootPath) {
                $finder = new Finder();
                $finder->files()
                    ->in($rootPath)
                    ->ignoreDotFiles(false)
                    ->ignoreVCS(false);

                foreach ($finder as $file) {
                    $ext = $file->getExtension();
                    if (in_array($ext, $allowedExtensions)) {
                        $allFiles[] = $file;

                        // Collecter tous les dossiers parents
                        $relativePath = $file->getRelativePath();
                        if (!empty($relativePath)) {
                            $parts = explode(DIRECTORY_SEPARATOR, $relativePath);
                            $currentPath = '';
                            foreach ($parts as $part) {
                                $currentPath = empty($currentPath) ? $part : $currentPath . DIRECTORY_SEPARATOR . $part;
                                $allDirs[$currentPath] = true;
                            }
                        }
                    }
                }
            }
        }

        // Traitement des fichiers individuels (files)
        $resolvedFiles = [];
        if ($filesParam) {

            $rawFiles = array_map('trim', explode(',', $filesParam));

            foreach ($rawFiles as $file) {
                // RÃ©soudre le chemin absolu
                if (!str_starts_with($file, '/')) {
                    $file = $this->getParameter('kernel.project_dir') . '/' . $file;
                }

                $realPath = realpath($file);

                if ($realPath && is_file($realPath)) {
                    $ext = pathinfo($realPath, PATHINFO_EXTENSION);
                    if (in_array($ext, $allowedExtensions)) {
                        $resolvedFiles[] = $realPath;

                        // CrÃ©er un objet fichier virtuel pour le traitement
                        $virtualFile = new \SplFileInfo($realPath);
                        $allFiles[] = $virtualFile;

                        // Collecter le dossier parent
                        $relativePath = str_replace($this->getParameter('kernel.project_dir') . '/', '', dirname($realPath));
                        if ($relativePath !== '.' && !empty($relativePath)) {
                            $parts = explode(DIRECTORY_SEPARATOR, $relativePath);
                            $currentPath = '';
                            foreach ($parts as $part) {
                                $currentPath = empty($currentPath) ? $part : $currentPath . DIRECTORY_SEPARATOR . $part;
                                $allDirs[$currentPath] = true;
                            }
                        }
                    } else {
                        $warningMessages[] = "Fichier ignorÃ© (extension non autorisÃ©e): " . $file;
                    }
                } else {
                    $warningMessages[] = "Fichier ignorÃ© (invalide): " . $file;
                }
            }
        }

        // VÃ©rifier qu'on a au moins un fichier Ã  analyser
        if (empty($allFiles)) {
            $errorMsg = "ERREUR: Aucun fichier valide trouvÃ©.\n";
            if (!empty($warningMessages)) {
                $errorMsg .= implode("\n", $warningMessages) . "\n";
            }
            return new Response(
                $errorMsg,
                Response::HTTP_NOT_FOUND,
                ['Content-Type' => 'text/plain']
            );
        }

        try {
            $content = $this->generateExport($allFiles, $allDirs, $resolvedPaths, $allowedExtensions);

            // Ajouter les avertissements au dÃ©but si nÃ©cessaire
            if (!empty($warningMessages)) {
                $warnings = "ATTENTIONS:\n" . implode("\n", $warningMessages) . "\n\n";
                $content = $warnings . $content;
            }

            return new Response(
                $content,
                Response::HTTP_OK,
                ['Content-Type' => 'text/plain']
            );

        } catch (\Exception $e) {
            return new Response(
                "ERREUR: " . $e->getMessage() . "\n",
                Response::HTTP_INTERNAL_SERVER_ERROR,
                ['Content-Type' => 'text/plain']
            );
        }
    }

    private function generateExport(array $allFiles, array $allDirs, array $rootPaths, array $allowedExtensions): string
    {
        $output = [];
        $projectRoot = $this->getParameter('kernel.project_dir');

        // En-tÃªte
        $output[] = "FICHIERS POUR ANALYSE";
        $output[] = "=====================";

        if (!empty($rootPaths)) {
            $output[] = "Dossiers analysÃ©s:";
            foreach ($rootPaths as $path) {
                $relativePath = str_replace($projectRoot . '/', '', $path);
                $output[] = "  - " . $relativePath;
            }
        }

        $output[] = "Extensions: " . implode(', ', $allowedExtensions);
        $output[] = "Date: " . date('Y-m-d H:i:s');
        $output[] = "";

        // Trier les fichiers par chemin
        usort($allFiles, function($a, $b) {
            return strcmp($a->getRealPath(), $b->getRealPath());
        });

        // Trier les dossiers
        $dirs = array_keys($allDirs);
        sort($dirs);

        // GÃ©nÃ©rer l'arborescence complÃ¨te
        $output[] = "ARBORESCENCE:";
        $output[] = "-------------";

        if (empty($allFiles)) {
            $output[] = "  (aucun fichier trouvÃ©)";
        } else {
            // Construire l'arbre global
            $globalTree = [];

            foreach ($allFiles as $file) {
                $fullPath = $file->getRealPath();
                $relativePath = str_replace($projectRoot . '/', '', $fullPath);
                $parts = explode('/', $relativePath);

                $current = &$globalTree;
                $lastIndex = count($parts) - 1;

                foreach ($parts as $index => $part) {
                    if ($index === $lastIndex) {
                        // C'est un fichier
                        $current[$part] = null;
                    } else {
                        // C'est un dossier
                        if (!isset($current[$part])) {
                            $current[$part] = [];
                        }
                        $current = &$current[$part];
                    }
                }
            }

            $output[] = $this->renderTree($globalTree);
        }

        $output[] = "";
        $output[] = "CONTENU DES FICHIERS";
        $output[] = "====================";
        $output[] = "";

        // Contenu de chaque fichier
        foreach ($allFiles as $file) {
            $fullPath = $file->getRealPath();
            $relativeToProject = str_replace($projectRoot . '/', '', $fullPath);

            $output[] = "FICHIER: " . $relativeToProject;
            $output[] = str_repeat("-", 80);

            $content = file_get_contents($fullPath);
            if ($content === false) {
                $output[] = "[ERREUR LECTURE]";
            } else {
                $output[] = $content;
            }

            $output[] = ""; // Ligne vide entre les fichiers
            $output[] = ""; // Une de plus pour la sÃ©paration
        }

        $output[] = "FIN";
        $output[] = "============";
        $output[] = "Total fichiers: " . count($allFiles);

        return implode("\n", $output);
    }

    private function renderTree(array $tree, string $prefix = ''): string
    {
        $output = '';
        $items = $this->sortTreeItems($tree);
        $count = count($items);
        $i = 0;

        foreach ($items as $key => $value) {
            $i++;
            $isLast = ($i === $count);
            $isDir = is_array($value);

            // Choisir le marqueur
            if ($isDir) {
                $marker = $isLast ? 'â””â”€â”€ ğŸ“ ' : 'â”œâ”€â”€ ğŸ“ ';
            } else {
                $marker = $isLast ? 'â””â”€â”€ ğŸ“„ ' : 'â”œâ”€â”€ ğŸ“„ ';
            }

            // Ajouter l'Ã©lÃ©ment courant
            $output .= $prefix . $marker . $key . ($isDir ? '/' : '') . "\n";

            // Si c'est un dossier, rendre son contenu
            if ($isDir) {
                $newPrefix = $prefix . ($isLast ? '    ' : 'â”‚   ');
                $output .= $this->renderTree($value, $newPrefix);
            }
        }

        return $output;
    }

    private function sortTreeItems(array $tree): array
    {
        // SÃ©parer les dossiers et les fichiers
        $dirs = [];
        $files = [];

        foreach ($tree as $key => $value) {
            if (is_array($value)) {
                $dirs[$key] = $value;
            } else {
                $files[$key] = $value;
            }
        }

        // Trier alphabÃ©tiquement
        ksort($dirs);
        ksort($files);

        // Fusionner (dossiers d'abord, puis fichiers)
        return array_merge($dirs, $files);
    }
}



FICHIER: src/Infrastructure/Http/Controller/LogoutController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/LogoutController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Security\RefreshTokenService;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/auth/logout', name: 'api_auth_logout', methods: ['POST'])]
#[OA\Tag(name: 'auth')]
class LogoutController extends AbstractController
{
    public function __construct(
        private readonly RefreshTokenService $refreshTokenService
    ) {}

    #[OA\Post(
        summary: 'DÃ©connecte l\'utilisateur',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                type: 'object',
                required: ['refresh_token'],
                properties: [
                    new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                ]
            )
        ),
        responses: [
            new OA\Response(response: 200, description: 'DÃ©connexion rÃ©ussie')
        ]
    )]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $refreshTokenString = $data['refresh_token'] ?? null;

        if ($refreshTokenString) {
            $this->refreshTokenService->revokeRefreshToken($refreshTokenString);
        }

        return $this->json(['message' => 'DÃ©connexion rÃ©ussie']);
    }
}



FICHIER: src/Infrastructure/Http/Controller/PhotoController.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Http\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\ResponseHeaderBag;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/photo')]
class PhotoController extends AbstractController
{
    private string $uploadDir;

    public function __construct(string $projectDir)
    {
        $this->uploadDir = $projectDir . '/upload/photos';
    }

    #[Route('/{filename}', name: 'photo_get', methods: ['GET'])]
    public function getPhoto(string $filename): Response
    {
        // SÃ©curitÃ© : empÃªcher les traversÃ©es de rÃ©pertoire
        if (str_contains($filename, '..') || str_contains($filename, '/') || str_contains($filename, '\\')) {
            return new JsonResponse(['error' => 'Nom de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        // Validation du format de fichier - CORRIGÃ‰E
        // Accepte: lettres (maj/min), chiffres, tirets, underscore, points
        if (!preg_match('/^[a-zA-Z0-9_-]+\.(jpg|jpeg|png|gif|webp)$/i', $filename)) {
            return new JsonResponse([
                'error' => 'Format de fichier invalide',
                'filename' => $filename,
                'expected_format' => 'auth_uid.extension (ex: AtJbLX0UgIcpiaWCZNnc9JdLzff1.jpg)'
            ], Response::HTTP_BAD_REQUEST);
        }

        $filePath = $this->uploadDir . '/' . $filename;

        if (!file_exists($filePath)) {
            return new JsonResponse(['error' => 'Photo non trouvÃ©e'], Response::HTTP_NOT_FOUND);
        }

        // DÃ©tecter le type MIME
        $mimeType = mime_content_type($filePath);
        if (!$mimeType) {
            $extension = pathinfo($filename, PATHINFO_EXTENSION);
            $mimeType = match(strtolower($extension)) {
                'jpg', 'jpeg' => 'image/jpeg',
                'png' => 'image/png',
                'gif' => 'image/gif',
                'webp' => 'image/webp',
                default => 'application/octet-stream',
            };
        }

        // Retourner le fichier avec des en-tÃªtes de cache
        return new BinaryFileResponse($filePath, 200, [
            'Content-Type' => $mimeType,
            'Cache-Control' => 'public, max-age=31536000', // Cache d'un an
            'Access-Control-Allow-Origin' => '*', // Permettre l'accÃ¨s depuis n'importe quelle origine
        ]);
    }

    #[Route('/{filename}/download', name: 'photo_download', methods: ['GET'])]
    public function downloadPhoto(string $filename): Response
    {
        // MÃªme logique de sÃ©curitÃ©
        if (str_contains($filename, '..') || str_contains($filename, '/') || str_contains($filename, '\\')) {
            return new JsonResponse(['error' => 'Nom de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        if (!preg_match('/^[a-f0-9-]+\.(jpg|jpeg|png|gif|webp)$/i', $filename)) {
            return new JsonResponse(['error' => 'Format de fichier invalide'], Response::HTTP_BAD_REQUEST);
        }

        $filePath = $this->uploadDir . '/' . $filename;

        if (!file_exists($filePath)) {
            return new JsonResponse(['error' => 'Photo non trouvÃ©e'], Response::HTTP_NOT_FOUND);
        }

        $response = new BinaryFileResponse($filePath);
        $response->setContentDisposition(
            ResponseHeaderBag::DISPOSITION_ATTACHMENT,
            $filename
        );
        $response->headers->set('Access-Control-Allow-Origin', '*');

        return $response;
    }
}



FICHIER: src/Infrastructure/Http/Controller/RefreshTokenController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/RefreshTokenController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Security\RefreshTokenService;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;

#[Route('/api/auth/refresh', name: 'api_auth_refresh', methods: ['POST'])]
#[OA\Tag(name: 'auth')]
class RefreshTokenController extends AbstractController
{
    public function __construct(
        private readonly RefreshTokenService $refreshTokenService,
        private readonly JWTTokenManagerInterface $jwtManager
    ) {}

    #[OA\Post(
        summary: 'RafraÃ®chit un token JWT expirÃ©',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['refresh_token'],
                properties: [
                    new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                ],
                type: 'object'
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Nouveau token JWT et nouveau refresh token',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'token', type: 'string', example: 'eyJhbGciOiJIUzI1NiIsInR5...'),
                        new OA\Property(property: 'refresh_token', type: 'string', example: '550e8400-e29b-41d4-a716-446655440000')
                    ],
                    type: 'object'
                )
            ),
            new OA\Response(response: 401, description: 'Refresh token invalide')
        ]
    )]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

//        echo "popipopipopipopipopipopipopipopi\n";
//        print_r($data);
//        exit;

        $refreshTokenString = $data['refresh_token'] ?? null;

        if (!$refreshTokenString) {
            return $this->json(['error' => 'Refresh token requis'], Response::HTTP_BAD_REQUEST);
        }

        // Rotation du refresh token (single use)
        $newRefreshToken = $this->refreshTokenService->rotateRefreshToken($refreshTokenString);

        if (!$newRefreshToken) {
            return $this->json(['error' => 'Refresh token invalide ou expirÃ©'], Response::HTTP_UNAUTHORIZED);
        }

        // GÃ©nÃ©rer un nouveau JWT
        $user = $newRefreshToken->getUser();
        $newJwt = $this->jwtManager->create($user);

        return $this->json([
            'token' => $newJwt,
            'refresh_token' => $newRefreshToken->getRefreshToken()
        ]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/UsersGetJwtTokenFromFirebaseAuthAction.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Infrastructure\Security\RefreshTokenService;
use App\Shared\Application\Query\QueryBusInterface;
use App\Users\Application\Config\UsersAppConfig;
use App\Users\Application\DTO\UserDTO;
use App\Users\Application\Query\GetJwtForSignup\GetJwtForSignupQuery;
use App\Users\Application\Query\GetJwtFromUser\GetJwtFromUserQuery;
use App\Users\Application\Query\GetUserByFirebaseToken\GetUserByFirebaseTokenQuery;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Token\Parser;
use Lcobucci\JWT\Token\Plain;
use OpenApi\Attributes as OA;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Uid\Uuid;

#[Route('/api/users/jwt-by-firebase-token', name: 'UsersGetJwtTokenFromFirebaseAuth', methods: ['POST'])]
class UsersGetJwtTokenFromFirebaseAuthAction
{
    public function __construct(
        private readonly QueryBusInterface $queryBus,
        private readonly RefreshTokenService $refreshTokenService,
        private readonly UserRepository $userRepository,
        private readonly UserPasswordHasherInterface $passwordHasher
    ) {
    }

    #[OA\Tag(name: 'users')]
    public function __invoke(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $token = $data['token'];

        /** @var UserDTO $userDTO */
        $userDTO = $this->queryBus->execute(new GetUserByFirebaseTokenQuery($token));

        if ($userDTO->status >= 20) {
            $message = '';
            switch($userDTO->status) {
                case UsersAppConfig::$USER_UNSUBSCRIBED:
                    $message = 'Vous Ãªtes dÃ©sinscrit(e).';
                    break;
                case UsersAppConfig::$USER_BANNED:
                    $message = 'Vous avez Ã©tÃ© banni(e).';
                    break;
                case UsersAppConfig::$USER_BLOCKED:
                    $message = 'Vous avez Ã©tÃ© bloquÃ©(e).';
                    break;
            }

            return new JsonResponse(['message' => json_encode([
                "code" => UsersAppConfig::$ERREUR_USER,
                "title" => "Erreur",
                "message" => $message."\n\nSupport: contact@playwinher.com",
            ])], Response::HTTP_FORBIDDEN);
        } else {
            $refreshToken = null;
            $userEntity = null;

            if ('' == $userDTO->email) {
                // Nouvel utilisateur - le crÃ©er Ã  partir du token Firebase
                $userEntity = $this->createUserFromFirebaseToken($token);

                // Sauvegarder l'utilisateur
                $this->userRepository->getEntityManager()->persist($userEntity);
                $this->userRepository->getEntityManager()->flush();

                // Re-crÃ©er le UserDTO avec les nouvelles informations
                $userDTO = UserDTO::fromEntity($userEntity);

                // GÃ©nÃ©rer le JWT pour le nouvel utilisateur
                $jwtToken = $this->queryBus->execute(new GetJwtFromUserQuery($userDTO));
            } else {
                // Utilisateur existant - gÃ©nÃ©rer JWT normal
                $jwtToken = $this->queryBus->execute(new GetJwtFromUserQuery($userDTO));

                // RÃ©cupÃ©rer l'entitÃ© utilisateur pour gÃ©nÃ©rer le refresh token
                $userEntity = $this->getUserEntityByAuthUid($userDTO->authUid);
            }

            // GÃ©nÃ©rer le refresh token si on a une entitÃ© utilisateur
            if ($userEntity) {
                // RÃ©voquer tous les anciens refresh tokens (single session)
                $this->refreshTokenService->revokeAllUserTokens($userEntity);

                // CrÃ©er un nouveau refresh token
                $refreshTokenEntity = $this->refreshTokenService->createRefreshToken($userEntity);
                $refreshToken = $refreshTokenEntity->getRefreshToken();
            }

            $response = [
                'token' => $jwtToken,
                'found' => ('' != $userDTO->email),
                'auth_uid' => $userDTO->authUid,
            ];

            // Ajouter le refresh token
            if ($refreshToken) {
                $response['refresh_token'] = $refreshToken;
            }

            return new JsonResponse($response);
        }
    }

    /**
     * CrÃ©e un nouvel utilisateur Ã  partir du token Firebase
     */
    private function createUserFromFirebaseToken(string $firebaseToken): UserEntity
    {
        // Parser le token Firebase pour extraire les informations
        $parser = new Parser(new JoseEncoder());
        /** @var Plain $token */
        $token = $parser->parse($firebaseToken);

        // RÃ©cupÃ©rer les claims
        $claims = $token->claims();

        // Extraire l'email et le sub (auth_uid)
        $email = $claims->get('email');
        $authUid = $claims->get('sub');

        // Essayer de rÃ©cupÃ©rer le nom depuis Firebase
        $name = $claims->get('name', null); // Firebase peut fournir un champ 'name'

        if (!$email || !$authUid) {
            throw new \Exception('Email ou sub manquant dans le token Firebase');
        }

        // CrÃ©er la nouvelle entitÃ©
        $userEntity = new UserEntity();

        // GÃ©nÃ©rer un UID unique pour l'utilisateur
        $userEntity->setUid(Uuid::v4()->toString());
        $userEntity->setAuthUid($authUid);
        $userEntity->setEmail($email);
        $userEntity->setUsername($email); // Garder username pour compatibilitÃ©
        $userEntity->setDisplayName($name ?? $email); // Utiliser le nom Firebase ou fallback sur email
        $userEntity->setAboutMe('');
        $userEntity->setGender(0);
        $userEntity->setBirthdate(new \DateTime('today'));
        $userEntity->setStatus(0);
        $userEntity->setRoles(['ROLE_USER']);

        // Hasher le mot de passe alÃ©atoire
        $randomPassword = bin2hex(random_bytes(16));
        $hashedPassword = $this->passwordHasher->hashPassword($userEntity, $randomPassword);
        $userEntity->setPassword($hashedPassword);

        // DÃ©finir la date de crÃ©ation (sera aussi gÃ©rÃ©e par le PrePersist)
        $userEntity->setCreatedAt(new \DateTime());

        return $userEntity;
    }

    /**
     * MÃ©thode utilitaire pour rÃ©cupÃ©rer l'entitÃ© User Ã  partir de l'authUid
     */
    private function getUserEntityByAuthUid(string $authUid): ?UserEntity
    {
        return $this->userRepository->findOneBy(['authUid' => $authUid]);
    }
}



FICHIER: src/Infrastructure/Http/Controller/VenueController.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Http/Controller/VenueController.php

namespace App\Infrastructure\Http\Controller;

use App\Infrastructure\Persistence\Doctrine\Entity\VenueEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\VenueRepository;
use OpenApi\Attributes as OA;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Attribute\Route;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;
use Symfony\Component\Uid\Uuid;

#[Route('/api/venue')]
#[OA\Tag(name: 'venue')]
class VenueController extends AbstractController
{
    public function __construct(
        private readonly VenueRepository $venueRepository,
        private readonly SerializerInterface $serializer,
        private readonly ValidatorInterface $validator,
    ) {}

    #[Route('/list', name: 'venue_list', methods: ['GET'])]
    #[OA\Get(
        summary: 'Liste des venues avec pagination',
        parameters: [
            new OA\Parameter(
                name: 'page',
                in: 'query',
                description: 'NumÃ©ro de page',
                schema: new OA\Schema(type: 'integer', default: 1)
            ),
            new OA\Parameter(
                name: 'limit',
                in: 'query',
                description: 'Nombre d\'Ã©lÃ©ments par page',
                schema: new OA\Schema(type: 'integer', default: 20, maximum: 100)
            ),
            new OA\Parameter(
                name: 'search',
                in: 'query',
                description: 'Terme de recherche (nom ou description)',
                schema: new OA\Schema(type: 'string')
            ),
            new OA\Parameter(
                name: 'type',
                in: 'query',
                description: 'Filtre par type',
                schema: new OA\Schema(type: 'integer')
            ),
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Liste paginÃ©e des venues',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'items', type: 'array', items: new OA\Items(
                            properties: [
                                new OA\Property(property: 'id', type: 'integer'),
                                new OA\Property(property: 'uuid', type: 'string'),
                                new OA\Property(property: 'name', type: 'string'),
                                new OA\Property(property: 'description', type: 'string', nullable: true),
                                new OA\Property(property: 'type', type: 'integer', nullable: true),
                                new OA\Property(property: 'rank', type: 'integer', nullable: true),
                            ]
                        )),
                        new OA\Property(property: 'total', type: 'integer'),
                        new OA\Property(property: 'page', type: 'integer'),
                        new OA\Property(property: 'limit', type: 'integer'),
                        new OA\Property(property: 'pages', type: 'integer'),
                    ]
                )
            )
        ]
    )]
    public function list(Request $request): JsonResponse
    {
        $page = max(1, (int) $request->query->get('page', 1));
        $limit = min(100, max(1, (int) $request->query->get('limit', 20)));
        $search = $request->query->get('search');
        $type = $request->query->has('type') ? (int) $request->query->get('type') : null;

        $result = $this->venueRepository->findPaginated($page, $limit, $search, $type);

        // Formater les donnÃ©es pour la rÃ©ponse
        $items = array_map(function (VenueEntity $venue) {
            return [
                'id' => $venue->getId(),
                'uuid' => $venue->getUuid(),
                'name' => $venue->getName(),
                'description' => $venue->getDescription(),
                'type' => $venue->getType(),
                'rank' => $venue->getRank(),
            ];
        }, $result['items']);

        return $this->json([
            'items' => $items,
            'total' => $result['total'],
            'page' => $result['page'],
            'limit' => $result['limit'],
            'pages' => $result['pages'],
        ]);
    }

    #[Route('/{uuid}', name: 'venue_get', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re un venue par son UUID',
        parameters: [
            new OA\Parameter(
                name: 'uuid',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'string')
            )
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Venue trouvÃ©',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'integer'),
                        new OA\Property(property: 'uuid', type: 'string'),
                        new OA\Property(property: 'name', type: 'string'),
                        new OA\Property(property: 'description', type: 'string', nullable: true),
                        new OA\Property(property: 'type', type: 'integer', nullable: true),
                        new OA\Property(property: 'rank', type: 'integer', nullable: true),
                    ]
                )
            ),
            new OA\Response(response: 404, description: 'Venue non trouvÃ©')
        ]
    )]
    public function get(string $uuid): JsonResponse
    {
        $venue = $this->venueRepository->findByUuid($uuid);

        if (!$venue) {
            return $this->json(['error' => 'Venue non trouvÃ©'], Response::HTTP_NOT_FOUND);
        }

        return $this->json([
            'id' => $venue->getId(),
            'uuid' => $venue->getUuid(),
            'name' => $venue->getName(),
            'description' => $venue->getDescription(),
            'type' => $venue->getType(),
            'rank' => $venue->getRank(),
        ]);
    }

    #[Route('', name: 'venue_create', methods: ['POST'])]
    #[OA\Post(
        summary: 'CrÃ©e un nouveau venue',
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                required: ['name'],
                properties: [
                    new OA\Property(property: 'name', type: 'string', maxLength: 50),
                    new OA\Property(property: 'description', type: 'string', maxLength: 200, nullable: true),
                    new OA\Property(property: 'type', type: 'integer', nullable: true),
                    new OA\Property(property: 'rank', type: 'integer', nullable: true),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 201,
                description: 'Venue crÃ©Ã© avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'integer'),
                        new OA\Property(property: 'uuid', type: 'string'),
                        new OA\Property(property: 'name', type: 'string'),
                        new OA\Property(property: 'description', type: 'string', nullable: true),
                        new OA\Property(property: 'type', type: 'integer', nullable: true),
                        new OA\Property(property: 'rank', type: 'integer', nullable: true),
                    ]
                )
            ),
            new OA\Response(response: 400, description: 'DonnÃ©es invalides')
        ]
    )]
    public function create(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);

        if (!isset($data['name']) || empty($data['name'])) {
            return $this->json(['error' => 'Le nom est requis'], Response::HTTP_BAD_REQUEST);
        }

        $venue = new VenueEntity();
        $venue->setUuid(Uuid::v4()->toString());
        $venue->setName($data['name']);
        $venue->setDescription($data['description'] ?? null);
        $venue->setType($data['type'] ?? null);
        $venue->setRank($data['rank'] ?? null);

        $errors = $this->validator->validate($venue);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->venueRepository->save($venue);

        return $this->json([
            'id' => $venue->getId(),
            'uuid' => $venue->getUuid(),
            'name' => $venue->getName(),
            'description' => $venue->getDescription(),
            'type' => $venue->getType(),
            'rank' => $venue->getRank(),
        ], Response::HTTP_CREATED);
    }

    #[Route('/{uuid}', name: 'venue_update', methods: ['PUT'])]
    #[OA\Put(
        summary: 'Met Ã  jour un venue existant',
        parameters: [
            new OA\Parameter(
                name: 'uuid',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'string')
            )
        ],
        requestBody: new OA\RequestBody(
            required: true,
            content: new OA\JsonContent(
                properties: [
                    new OA\Property(property: 'name', type: 'string', maxLength: 50),
                    new OA\Property(property: 'description', type: 'string', maxLength: 200, nullable: true),
                    new OA\Property(property: 'type', type: 'integer', nullable: true),
                    new OA\Property(property: 'rank', type: 'integer', nullable: true),
                ]
            )
        ),
        responses: [
            new OA\Response(
                response: 200,
                description: 'Venue mis Ã  jour avec succÃ¨s',
                content: new OA\JsonContent(
                    properties: [
                        new OA\Property(property: 'id', type: 'integer'),
                        new OA\Property(property: 'uuid', type: 'string'),
                        new OA\Property(property: 'name', type: 'string'),
                        new OA\Property(property: 'description', type: 'string', nullable: true),
                        new OA\Property(property: 'type', type: 'integer', nullable: true),
                        new OA\Property(property: 'rank', type: 'integer', nullable: true),
                    ]
                )
            ),
            new OA\Response(response: 404, description: 'Venue non trouvÃ©'),
            new OA\Response(response: 400, description: 'DonnÃ©es invalides')
        ]
    )]
    public function update(string $uuid, Request $request): JsonResponse
    {
        $venue = $this->venueRepository->findByUuid($uuid);

        if (!$venue) {
            return $this->json(['error' => 'Venue non trouvÃ©'], Response::HTTP_NOT_FOUND);
        }

        $data = json_decode($request->getContent(), true);

        if (isset($data['name']) && !empty($data['name'])) {
            $venue->setName($data['name']);
        }

        if (array_key_exists('description', $data)) {
            $venue->setDescription($data['description']);
        }

        if (array_key_exists('type', $data)) {
            $venue->setType($data['type'] !== null ? (int) $data['type'] : null);
        }

        if (array_key_exists('rank', $data)) {
            $venue->setRank($data['rank'] !== null ? (int) $data['rank'] : null);
        }

        $errors = $this->validator->validate($venue);
        if (count($errors) > 0) {
            return $this->json(['errors' => (string) $errors], Response::HTTP_BAD_REQUEST);
        }

        $this->venueRepository->save($venue);

        return $this->json([
            'id' => $venue->getId(),
            'uuid' => $venue->getUuid(),
            'name' => $venue->getName(),
            'description' => $venue->getDescription(),
            'type' => $venue->getType(),
            'rank' => $venue->getRank(),
        ]);
    }

    #[Route('/{uuid}', name: 'venue_delete', methods: ['DELETE'])]
    #[OA\Delete(
        summary: 'Supprime un venue',
        parameters: [
            new OA\Parameter(
                name: 'uuid',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'string')
            )
        ],
        responses: [
            new OA\Response(response: 204, description: 'Venue supprimÃ© avec succÃ¨s'),
            new OA\Response(response: 404, description: 'Venue non trouvÃ©')
        ]
    )]
    public function delete(string $uuid): JsonResponse
    {
        $venue = $this->venueRepository->findByUuid($uuid);

        if (!$venue) {
            return $this->json(['error' => 'Venue non trouvÃ©'], Response::HTTP_NOT_FOUND);
        }

        $this->venueRepository->delete($venue);

        return $this->json(null, Response::HTTP_NO_CONTENT);
    }

    #[Route('/type/{type}', name: 'venue_by_type', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les venues par type',
        parameters: [
            new OA\Parameter(
                name: 'type',
                in: 'path',
                required: true,
                schema: new OA\Schema(type: 'integer')
            )
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Liste des venues du type spÃ©cifiÃ©',
                content: new OA\JsonContent(
                    type: 'array',
                    items: new OA\Items(
                        properties: [
                            new OA\Property(property: 'id', type: 'integer'),
                            new OA\Property(property: 'uuid', type: 'string'),
                            new OA\Property(property: 'name', type: 'string'),
                            new OA\Property(property: 'description', type: 'string', nullable: true),
                            new OA\Property(property: 'type', type: 'integer', nullable: true),
                            new OA\Property(property: 'rank', type: 'integer', nullable: true),
                        ]
                    )
                )
            )
        ]
    )]
    public function getByType(int $type): JsonResponse
    {
        $venues = $this->venueRepository->findByType($type);

        $items = array_map(function (VenueEntity $venue) {
            return [
                'id' => $venue->getId(),
                'uuid' => $venue->getUuid(),
                'name' => $venue->getName(),
                'description' => $venue->getDescription(),
                'type' => $venue->getType(),
                'rank' => $venue->getRank(),
            ];
        }, $venues);

        return $this->json($items);
    }

    #[Route('/top/{limit}', name: 'venue_top', methods: ['GET'])]
    #[OA\Get(
        summary: 'RÃ©cupÃ¨re les venues les mieux classÃ©es',
        parameters: [
            new OA\Parameter(
                name: 'limit',
                in: 'path',
                description: 'Nombre maximum de venues Ã  retourner',
                schema: new OA\Schema(type: 'integer', default: 10)
            )
        ],
        responses: [
            new OA\Response(
                response: 200,
                description: 'Liste des meilleurs venues',
                content: new OA\JsonContent(
                    type: 'array',
                    items: new OA\Items(
                        properties: [
                            new OA\Property(property: 'id', type: 'integer'),
                            new OA\Property(property: 'uuid', type: 'string'),
                            new OA\Property(property: 'name', type: 'string'),
                            new OA\Property(property: 'description', type: 'string', nullable: true),
                            new OA\Property(property: 'type', type: 'integer', nullable: true),
                            new OA\Property(property: 'rank', type: 'integer', nullable: true),
                        ]
                    )
                )
            )
        ]
    )]
    public function getTop(int $limit = 10): JsonResponse
    {
        $limit = min(50, max(1, $limit));
        $venues = $this->venueRepository->findTopRated($limit);

        $items = array_map(function (VenueEntity $venue) {
            return [
                'id' => $venue->getId(),
                'uuid' => $venue->getUuid(),
                'name' => $venue->getName(),
                'description' => $venue->getDescription(),
                'type' => $venue->getType(),
                'rank' => $venue->getRank(),
            ];
        }, $venues);

        return $this->json($items);
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/RefreshTokenEntity.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Entity/RefreshTokenEntity.php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
#[ORM\Table(name: 'refresh_tokens')]
#[ORM\HasLifecycleCallbacks]
class RefreshTokenEntity
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 128, unique: true)]
    private string $refreshToken;

    #[ORM\ManyToOne(targetEntity: UserEntity::class)]
    #[ORM\JoinColumn(nullable: false)]
    private UserEntity $user;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $valid;

    #[ORM\Column(type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(type: 'boolean')]
    private bool $revoked = false;

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        $this->createdAt = new \DateTime();
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getRefreshToken(): string
    {
        return $this->refreshToken;
    }

    public function setRefreshToken(string $refreshToken): self
    {
        $this->refreshToken = $refreshToken;
        return $this;
    }

    public function getUser(): UserEntity
    {
        return $this->user;
    }

    public function setUser(UserEntity $user): self
    {
        $this->user = $user;
        return $this;
    }

    public function getValid(): \DateTimeInterface
    {
        return $this->valid;
    }

    public function setValid(\DateTimeInterface $valid): self
    {
        $this->valid = $valid;
        return $this;
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function isRevoked(): bool
    {
        return $this->revoked;
    }

    public function setRevoked(bool $revoked): self
    {
        $this->revoked = $revoked;
        return $this;
    }

    public function isValid(): bool
    {
        return !$this->revoked && $this->valid > new \DateTime();
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/UserEntity.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\UserInterface;

/**
 * Infrastructure Entity - Mapping Doctrine uniquement
 * Sert d'adapter entre le domaine et la base de donnÃ©es
 */
#[ORM\Entity]
#[ORM\Table(name: '`user`')]
#[ORM\HasLifecycleCallbacks]
class UserEntity implements UserInterface, PasswordAuthenticatedUserInterface
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column(type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $uid = null;

    #[ORM\Column(name: 'auth_uid', type: 'string', length: 100, nullable: true)]
    private ?string $authUid = null;

    #[ORM\Column(type: 'json')]
    private array $roles = [];

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $email = null;

    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $username = null;

    // Champ displayName
    #[ORM\Column(type: 'string', length: 100, nullable: true)]
    private ?string $displayName = null;

    #[ORM\Column(type: 'string', length: 255)]
    private string $password;

    #[ORM\Column(name: 'about_me', type: 'text', nullable: true)]
    private ?string $aboutMe = null;

    #[ORM\Column(type: 'integer', nullable: true)]
    private ?int $gender = null;

    #[ORM\Column(type: 'date', nullable: true)]
    private ?\DateTime $birthdate = null;

    #[ORM\Column(type: 'integer', options: ['default' => 1])]
    private int $status = 1;

    #[ORM\Column(name: 'has_photo', type: 'boolean', options: ['default' => false])]
    private bool $hasPhoto = false;
    #[ORM\Column(name: 'first_access', type: 'boolean', options: ['default' => true])]
    private bool $firstAccess = true;

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime', nullable: true)]
    private ?\DateTimeInterface $updatedAt = null;

    /**
     * Constructeur avec initialisation de toutes les propriÃ©tÃ©s
     */
    public function __construct()
    {
        $this->hasPhoto = false;
        $this->createdAt = new \DateTime();
    }

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        if ($this->createdAt === null) {
            $this->createdAt = new \DateTime();
        }
    }

    #[ORM\PreUpdate]
    public function setUpdatedAtValue(): void
    {
        $this->updatedAt = new \DateTime();
    }

    // Getters and Setters
    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(?int $id): void
    {
        $this->id = $id;
    }

    public function getUid(): ?string
    {
        return $this->uid;
    }

    public function setUid(?string $uid): void
    {
        $this->uid = $uid;
    }

    public function getAuthUid(): ?string
    {
        return $this->authUid;
    }

    public function setAuthUid(?string $authUid): void
    {
        $this->authUid = $authUid;
    }

    public function getEmail(): ?string
    {
        return $this->email;
    }

    public function setEmail(?string $email): void
    {
        $this->email = $email;
    }

    public function getUsername(): ?string
    {
        return $this->username;
    }

    public function setUsername(?string $username): void
    {
        $this->username = $username;
    }

    public function getDisplayName(): ?string
    {
        return $this->displayName;
    }

    public function setDisplayName(?string $displayName): void
    {
        $this->displayName = $displayName;
    }

    public function getAboutMe(): ?string
    {
        return $this->aboutMe;
    }

    public function setAboutMe(?string $aboutMe): void
    {
        $this->aboutMe = $aboutMe;
    }

    public function getGender(): ?int
    {
        return $this->gender;
    }

    public function setGender(?int $gender): void
    {
        $this->gender = $gender;
    }

    public function getBirthdate(): ?\DateTime
    {
        return $this->birthdate;
    }

    public function setBirthdate(?\DateTime $birthdate): void
    {
        $this->birthdate = $birthdate;
    }

    public function getStatus(): int
    {
        return $this->status;
    }

    public function setStatus(int $status): void
    {
        $this->status = $status;
    }

    // Getter/Setter pour hasPhoto
    public function hasPhoto(): bool
    {
        return $this->hasPhoto;
    }

    public function setHasPhoto(bool $hasPhoto): self
    {
        $this->hasPhoto = $hasPhoto;
        return $this;
    }

    public function isFirstAccess(): bool
    {
        return $this->firstAccess;
    }

    public function setFirstAccess(bool $firstAccess): void
    {
        $this->firstAccess = $firstAccess;
    }


    // MÃ©thode utilitaire pour mettre Ã  jour le statut photo
    public function updatePhotoStatus(bool $hasPhoto): void
    {
        $this->hasPhoto = $hasPhoto;
        $this->updatedAt = new \DateTime();
    }

    public function getUserIdentifier(): string
    {
        return $this->email ?? '';
    }

    public function getRoles(): array
    {
        $roles = $this->roles;
        $roles[] = 'ROLE_USER';
        return array_unique($roles);
    }

    public function setRoles(array $roles): void
    {
        $this->roles = $roles;
    }

    public function getPassword(): string
    {
        return $this->password;
    }

    public function setPassword(string $password): void
    {
        $this->password = $password;
    }

    public function eraseCredentials(): void
    {
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTimeInterface $createdAt): void
    {
        $this->createdAt = $createdAt;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    public function setUpdatedAt(?\DateTimeInterface $updatedAt): void
    {
        $this->updatedAt = $updatedAt;
    }

    /**
     * MÃ©thodes d'aide pour la compatibilitÃ© avec l'ancien nommage
     */
    public function isActive(): bool
    {
        return $this->status === 1;
    }

    public function setIsActive(bool $isActive): void
    {
        $this->status = $isActive ? 1 : 0;
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Entity/VenueEntity.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Entity/VenueEntity.php

namespace App\Infrastructure\Persistence\Doctrine\Entity;

use Doctrine\ORM\Mapping as ORM;

#[ORM\Entity]
#[ORM\Table(name: 'venue')]
#[ORM\HasLifecycleCallbacks]
class VenueEntity
{
    #[ORM\Id]
    #[ORM\GeneratedValue(strategy: 'AUTO')]
    #[ORM\Column(name: 'id_venue', type: 'integer')]
    private ?int $id = null;

    #[ORM\Column(type: 'string', length: 50, nullable: false)]
    private string $uuid;

    #[ORM\Column(type: 'string', length: 50, nullable: false)]
    private string $name;

    #[ORM\Column(type: 'string', length: 200, nullable: true)]
    private ?string $description = null;

    #[ORM\Column(type: 'integer', nullable: true)]
    private ?int $type = null;

    #[ORM\Column(name: '`rank`', type: 'integer', nullable: true)]
    private ?int $rank = null;

    #[ORM\Column(name: 'created_at', type: 'datetime')]
    private \DateTimeInterface $createdAt;

    #[ORM\Column(name: 'updated_at', type: 'datetime', nullable: true)]
    private ?\DateTimeInterface $updatedAt = null;

    public function __construct()
    {
        $this->createdAt = new \DateTime();
    }

    #[ORM\PrePersist]
    public function setCreatedAtValue(): void
    {
        if ($this->createdAt === null) {
            $this->createdAt = new \DateTime();
        }
    }

    #[ORM\PreUpdate]
    public function setUpdatedAtValue(): void
    {
        $this->updatedAt = new \DateTime();
    }

    // Getters and Setters

    public function getId(): ?int
    {
        return $this->id;
    }

    public function setId(?int $id): self
    {
        $this->id = $id;
        return $this;
    }

    public function getUuid(): string
    {
        return $this->uuid;
    }

    public function setUuid(string $uuid): self
    {
        $this->uuid = $uuid;
        return $this;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function setName(string $name): self
    {
        $this->name = $name;
        return $this;
    }

    public function getDescription(): ?string
    {
        return $this->description;
    }

    public function setDescription(?string $description): self
    {
        $this->description = $description;
        return $this;
    }

    public function getType(): ?int
    {
        return $this->type;
    }

    public function setType(?int $type): self
    {
        $this->type = $type;
        return $this;
    }

    public function getRank(): ?int
    {
        return $this->rank;
    }

    public function setRank(?int $rank): self
    {
        $this->rank = $rank;
        return $this;
    }

    public function getCreatedAt(): \DateTimeInterface
    {
        return $this->createdAt;
    }

    public function setCreatedAt(\DateTimeInterface $createdAt): self
    {
        $this->createdAt = $createdAt;
        return $this;
    }

    public function getUpdatedAt(): ?\DateTimeInterface
    {
        return $this->updatedAt;
    }

    public function setUpdatedAt(?\DateTimeInterface $updatedAt): self
    {
        $this->updatedAt = $updatedAt;
        return $this;
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/RefreshTokenRepository.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Repository/RefreshTokenRepository.php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Infrastructure\Persistence\Doctrine\Entity\RefreshTokenEntity;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

class RefreshTokenRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, RefreshTokenEntity::class);
    }

    public function save(RefreshTokenEntity $refreshToken): void
    {
        $this->getEntityManager()->persist($refreshToken);
        $this->getEntityManager()->flush();
    }

    public function delete(RefreshTokenEntity $refreshToken): void
    {
        $this->getEntityManager()->remove($refreshToken);
        $this->getEntityManager()->flush();
    }

    public function findByToken(string $refreshToken): ?RefreshTokenEntity
    {
        return $this->findOneBy(['refreshToken' => $refreshToken]);
    }

    public function revokeAllForUser(UserEntity $user): void
    {
        $this->createQueryBuilder('rt')
            ->update()
            ->set('rt.revoked', ':revoked')
            ->where('rt.user = :user')
            ->setParameter('revoked', true)
            ->setParameter('user', $user)
            ->getQuery()
            ->execute();
    }

    public function deleteExpired(): int
    {
        return $this->createQueryBuilder('rt')
            ->delete()
            ->where('rt.valid < :now')
            ->setParameter('now', new \DateTime())
            ->getQuery()
            ->execute();
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/UserRepository.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Domain\Entity\User;
use App\Domain\Repository\UserRepositoryInterface;
use App\Domain\ValueObject\Email;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * Doctrine Repository (Adapter) - ImplÃ©mente le port du domaine
 */
class UserRepository extends ServiceEntityRepository implements UserRepositoryInterface
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, UserEntity::class);
    }

    public function save(UserEntity $user): void
    {
        $userEntity = $this->toDoctrineEntity($user);

        $this->getEntityManager()->persist($userEntity);
        $this->getEntityManager()->flush();

        // Sync l'ID gÃ©nÃ©rÃ© vers l'entitÃ© domain
        if ($user->getId() === null && $userEntity->getId() !== null) {
            $user->setId($userEntity->getId());
        }
    }

    public function delete(UserEntity $user): void
    {
        $userEntity = $this->find($user->getId());
        if ($userEntity) {
            $this->getEntityManager()->remove($userEntity);
            $this->getEntityManager()->flush();
        }
    }

    public function findById(int $id): ?UserEntity
    {
        $userEntity = $this->find($id);
        return $userEntity ? $this->toDomainEntity($userEntity) : null;
    }

    public function findByEmail(Email $email): ?UserEntity
    {
        $userEntity = $this->findOneBy(['email' => $email->getValue()]);
        return $userEntity ? $this->toDomainEntity($userEntity) : null;
    }

    public function findAll(): array
    {
        $entities = $this->findBy([], ['createdAt' => 'DESC']);
        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function findActiveUsers(): array
    {
        $entities = $this->createQueryBuilder('u')
            ->where('u.isActive = :active')
            ->setParameter('active', true)
            ->orderBy('u.createdAt', 'DESC')
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function findByRole(string $role): array
    {
        $entities = $this->createQueryBuilder('u')
            ->andWhere('JSON_CONTAINS(u.roles, :role) = 1')
            ->setParameter('role', json_encode($role))
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function search(string $searchTerm): array
    {
        $entities = $this->createQueryBuilder('u')
            ->where('u.email LIKE :search OR u.firstname LIKE :search OR u.lastname LIKE :search')
            ->setParameter('search', '%' . $searchTerm . '%')
            ->orderBy('u.lastname', 'ASC')
            ->getQuery()
            ->getResult();

        return array_map(fn($e) => $this->toDomainEntity($e), $entities);
    }

    public function countActiveUsers(): int
    {
        return (int) $this->createQueryBuilder('u')
            ->select('COUNT(u.id)')
            ->where('u.isActive = :active')
            ->setParameter('active', true)
            ->getQuery()
            ->getSingleScalarResult();
    }

    public function existsByEmail(Email $email): bool
    {
        return $this->count(['email' => $email->getValue()]) > 0;
    }

    /**
     * Convertit une entitÃ© Domain en entitÃ© Doctrine
     */
    private function toDoctrineEntity(UserEntity $domainUser): UserEntity
    {
        $userEntity = new UserEntity();

        if ($domainUser->getId() !== null) {
            $existing = $this->find($domainUser->getId());
            if ($existing) {
                $userEntity = $existing;
            } else {
                $userEntity->setId($domainUser->getId());
            }
        }

        $userEntity->setEmail($domainUser->getEmail());
        $userEntity->setRoles($domainUser->getRoles());
        $userEntity->setPassword($domainUser->getPassword());
//        $userEntity->setFirstname($domainUser->getFirstname());
//        $userEntity->setLastname($domainUser->getLastname());
        $userEntity->setIsActive($domainUser->isActive());
        $userEntity->setCreatedAt($domainUser->getCreatedAt());

        if ($domainUser->getUpdatedAt()) {
            $userEntity->setUpdatedAt($domainUser->getUpdatedAt());
        }

        return $userEntity;
    }

    /**
     * Convertit une entitÃ© Doctrine en entitÃ© Domain
     */
    private function toDomainEntity(UserEntity $userEntity): UserEntity
    {
        $user = new UserEntity(
            new Email($userEntity->getEmail()),
            $userEntity->getPassword(),
//            $userEntity->getFirstname(),
//            $userEntity->getLastname()
        );

        $user->setId($userEntity->getId());

        // Restaurer les rÃ´les (sans ROLE_USER par dÃ©faut qui sera ajoutÃ© automatiquement)
        $roles = array_filter($userEntity->getRoles(), fn($r) => $r !== 'ROLE_USER');
//        foreach ($roles as $role) {
//            $user->addRole($role);
//        }
        $user->setRoles($roles);

//        if (!$userEntity->isActive()) {
//            $user->deactivate();
//        }

        return $user;
    }

    public function getUserByAuthUid(string $firebaseAuthId): ?UserEntity
    {
        return $this->findOneBy(['authUid' => $firebaseAuthId]);
    }
}



FICHIER: src/Infrastructure/Persistence/Doctrine/Repository/VenueRepository.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Persistence/Doctrine/Repository/VenueRepository.php

namespace App\Infrastructure\Persistence\Doctrine\Repository;

use App\Infrastructure\Persistence\Doctrine\Entity\VenueEntity;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<VenueEntity>
 */
class VenueRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, VenueEntity::class);
    }

    public function save(VenueEntity $venue): void
    {
        $this->getEntityManager()->persist($venue);
        $this->getEntityManager()->flush();
    }

    public function delete(VenueEntity $venue): void
    {
        $this->getEntityManager()->remove($venue);
        $this->getEntityManager()->flush();
    }

    public function findByUuid(string $uuid): ?VenueEntity
    {
        return $this->findOneBy(['uuid' => $uuid]);
    }

    /**
     * RÃ©cupÃ¨re la liste des venues avec pagination
     *
     * @param int $page NumÃ©ro de page (commence Ã  1)
     * @param int $limit Nombre d'Ã©lÃ©ments par page
     * @param string|null $search Terme de recherche optionnel
     * @param int|null $type Filtre par type optionnel
     * @return array{items: VenueEntity[], total: int, page: int, limit: int, pages: int}
     */
    public function findPaginated(int $page = 1, int $limit = 20, ?string $search = null, ?int $type = null): array
    {
        $qb = $this->createQueryBuilder('v')
            ->orderBy('v.rank', 'DESC')
            ->addOrderBy('v.name', 'ASC');

        // Appliquer les filtres
        if ($search !== null && !empty($search)) {
            $qb->andWhere('v.name LIKE :search OR v.description LIKE :search')
                ->setParameter('search', '%' . $search . '%');
        }

        if ($type !== null) {
            $qb->andWhere('v.type = :type')
                ->setParameter('type', $type);
        }

        // Compter le total
        $countQb = clone $qb;
        $total = (int) $countQb->select('COUNT(v.id)')
            ->getQuery()
            ->getSingleScalarResult();

        // Pagination
        $offset = ($page - 1) * $limit;
        $qb->setFirstResult($offset)
            ->setMaxResults($limit);

        $items = $qb->getQuery()->getResult();

        $pages = (int) ceil($total / $limit);

        return [
            'items' => $items,
            'total' => $total,
            'page' => $page,
            'limit' => $limit,
            'pages' => $pages
        ];
    }

    /**
     * RÃ©cupÃ¨re les venues par type
     */
    public function findByType(int $type): array
    {
        return $this->findBy(['type' => $type], ['rank' => 'DESC', 'name' => 'ASC']);
    }

    /**
     * RÃ©cupÃ¨re les venues les mieux classÃ©es
     */
    public function findTopRated(int $limit = 10): array
    {
        return $this->findBy([], ['rank' => 'DESC', 'name' => 'ASC'], $limit);
    }
}



FICHIER: src/Infrastructure/Security/JWTLoginSuccessHandler.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/JWTLoginSuccessHandler.php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use Lexik\Bundle\JWTAuthenticationBundle\Event\AuthenticationSuccessEvent;
use Lexik\Bundle\JWTAuthenticationBundle\Events;
use Lexik\Bundle\JWTAuthenticationBundle\Response\JWTAuthenticationSuccessResponse;
use Lexik\Bundle\JWTAuthenticationBundle\Security\Http\Cookie\JWTCookieProvider;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Http\Authentication\AuthenticationSuccessHandlerInterface;
use Symfony\Contracts\EventDispatcher\EventDispatcherInterface;

class JWTLoginSuccessHandler implements AuthenticationSuccessHandlerInterface
{
    public function __construct(
        protected JWTTokenManagerInterface $jwtManager,
        protected EventDispatcherInterface $dispatcher,
        protected RefreshTokenService $refreshTokenService,
        iterable $cookieProviders = [],
        bool $removeTokenFromBodyWhenCookiesUsed = true
    ) {
        $this->jwtManager = $jwtManager;
        $this->dispatcher = $dispatcher;
        $this->refreshTokenService = $refreshTokenService;
        $this->cookieProviders = $cookieProviders;
        $this->removeTokenFromBodyWhenCookiesUsed = $removeTokenFromBodyWhenCookiesUsed;
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token): Response
    {
        return $this->handleAuthenticationSuccess($token->getUser());
    }

    public function handleAuthenticationSuccess(UserInterface $user, $jwt = null)
    {
        if (null === $jwt) {
            $jwt = $this->jwtManager->create($user);
        }

        // GÃ©nÃ©rer un refresh token si l'utilisateur est une instance de UserEntity
        $refreshToken = null;
        if ($user instanceof UserEntity) {
            $refreshTokenEntity = $this->refreshTokenService->createRefreshToken($user);
            $refreshToken = $refreshTokenEntity->getRefreshToken();
        }

        $jwtCookies = [];
        foreach ($this->cookieProviders as $cookieProvider) {
            $jwtCookies[] = $cookieProvider->createCookie($jwt);
        }

        $responseData = [
            'token' => $jwt,
            'refresh_token' => $refreshToken,
            'user' => [
                'email' => $user->getUserIdentifier(),
                'roles' => $user->getRoles(),
                'firstname' => method_exists($user, 'getFirstname') ? $user->getFirstname() : null,
                'lastname' => method_exists($user, 'getLastname') ? $user->getLastname() : null,
            ],
        ];

        $event = new AuthenticationSuccessEvent($responseData, $user, new JWTAuthenticationSuccessResponse($jwt, [], $jwtCookies));
        $this->dispatcher->dispatch($event, Events::AUTHENTICATION_SUCCESS);

        $response = new JWTAuthenticationSuccessResponse($jwt, [], $jwtCookies);
        $response->setData($event->getData());

        if ($jwtCookies && $this->removeTokenFromBodyWhenCookiesUsed) {
            unset($responseData['token']);
        }

        return $response;
    }
}



FICHIER: src/Infrastructure/Security/JwtAuthenticator.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;

class JwtAuthenticator extends AbstractAuthenticator
{
    private JWTTokenManagerInterface $jwtManager;
    private UserProviderInterface $userProvider;

    public function __construct(JWTTokenManagerInterface $jwtManager, UserProviderInterface $userProvider)
    {
        $this->jwtManager = $jwtManager;
        $this->userProvider = $userProvider;
    }

    public function supports(Request $request): ?bool
    {
        return $request->headers->has('Authorization');
    }

    public function authenticate(Request $request): SelfValidatingPassport
    {
        $authHeader = $request->headers->get('Authorization');
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            throw new AuthenticationException('JWT Token not found');
        }

        $jwt = substr($authHeader, 7);

        try {
            $payload = $this->jwtManager->decodeFromJsonWebToken($jwt);
        } catch (\Exception $e) {
            throw new AuthenticationException('Invalid JWT Token');
        }

        $username = $payload['username'] ?? null;
        if (!$username) {
            throw new AuthenticationException('JWT Token invalid: username missing');
        }

        return new SelfValidatingPassport(
            new UserBadge($username, fn($userIdentifier) => $this->userProvider->loadUserByUsername($userIdentifier))
        );
    }

    public function onAuthenticationSuccess(Request $request, $token, string $firewallName): ?JsonResponse
    {
        // Laisser continuer la requÃªte
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?JsonResponse
    {
        return new JsonResponse([
            'code' => 401,
            'message' => $exception->getMessage(),
        ], 401);
    }
}



FICHIER: src/Infrastructure/Security/RefreshTokenAuthenticator.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/RefreshTokenAuthenticator.php

namespace App\Infrastructure\Security;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\User\UserProviderInterface;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;

class RefreshTokenAuthenticator extends AbstractAuthenticator
{
    public function __construct(
        private RefreshTokenService $refreshTokenService,
        private UserProviderInterface $userProvider
    ) {}

    public function supports(Request $request): ?bool
    {
        return $request->getPathInfo() === '/api/auth/refresh' && $request->isMethod('POST');
    }

    public function authenticate(Request $request): SelfValidatingPassport
    {
        $data = json_decode($request->getContent(), true);
        $refreshTokenString = $data['refresh_token'] ?? null;

        if (!$refreshTokenString) {
            throw new AuthenticationException('Refresh token missing');
        }

        $refreshToken = $this->refreshTokenService->validateRefreshToken($refreshTokenString);

        if (!$refreshToken) {
            throw new AuthenticationException('Invalid refresh token');
        }

        $user = $refreshToken->getUser();

        return new SelfValidatingPassport(
            new UserBadge($user->getUserIdentifier(), fn() => $user)
        );
    }

    public function onAuthenticationSuccess(Request $request, $token, string $firewallName): ?JsonResponse
    {
        return null; // Continue la requÃªte
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?JsonResponse
    {
        return new JsonResponse([
            'error' => 'Refresh token invalide'
        ], 401);
    }
}



FICHIER: src/Infrastructure/Security/RefreshTokenService.php
--------------------------------------------------------------------------------
<?php
// src/Infrastructure/Security/RefreshTokenService.php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Entity\RefreshTokenEntity;
use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Infrastructure\Persistence\Doctrine\Repository\RefreshTokenRepository;
use Symfony\Component\Security\Csrf\TokenGenerator\TokenGeneratorInterface;

class RefreshTokenService
{
    public function __construct(
        private readonly RefreshTokenRepository $refreshTokenRepository,
        private readonly TokenGeneratorInterface $tokenGenerator,
        private readonly int $ttl = 2592000 // 30 jours en secondes
    ) {}

    public function createRefreshToken(UserEntity $user): RefreshTokenEntity
    {
        // Optionnel: rÃ©voquer tous les anciens tokens pour cet utilisateur
        // $this->refreshTokenRepository->revokeAllForUser($user);

        $refreshToken = new RefreshTokenEntity();
        $refreshToken->setRefreshToken($this->tokenGenerator->generateToken());
        $refreshToken->setUser($user);
        $refreshToken->setValid(new \DateTime('+' . $this->ttl . ' seconds'));
        $refreshToken->setRevoked(false);

        $this->refreshTokenRepository->save($refreshToken);

        return $refreshToken;
    }

    public function validateRefreshToken(string $tokenString): ?RefreshTokenEntity
    {
        $refreshToken = $this->refreshTokenRepository->findByToken($tokenString);

        if (!$refreshToken || !$refreshToken->isValid()) {
            return null;
        }

        return $refreshToken;
    }

    public function revokeRefreshToken(string $tokenString): void
    {
        $refreshToken = $this->refreshTokenRepository->findByToken($tokenString);
        if ($refreshToken) {
            $refreshToken->setRevoked(true);
            $this->refreshTokenRepository->save($refreshToken);
        }
    }

    public function revokeAllUserTokens(UserEntity $user): void
    {
        $this->refreshTokenRepository->revokeAllForUser($user);
    }

    public function rotateRefreshToken(string $oldTokenString): ?RefreshTokenEntity
    {
        $oldToken = $this->validateRefreshToken($oldTokenString);
        if (!$oldToken) {
            return null;
        }

        // RÃ©voquer l'ancien token
        $oldToken->setRevoked(true);
        $this->refreshTokenRepository->save($oldToken);

        // CrÃ©er un nouveau token
        return $this->createRefreshToken($oldToken->getUser());
    }
}



FICHIER: src/Infrastructure/Security/UserProvider.php
--------------------------------------------------------------------------------
<?php

namespace App\Infrastructure\Security;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
use Symfony\Component\Security\Core\Exception\UserNotFoundException;
use Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface;
use Symfony\Component\Security\Core\User\PasswordUpgraderInterface;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Security\Core\User\UserProviderInterface;

/**
 * UserProvider adaptÃ© Ã  l'architecture hexagonale
 */
class UserProvider implements UserProviderInterface, PasswordUpgraderInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {}

    public function refreshUser(UserInterface $user): UserInterface
    {
        if (!$user instanceof \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity) {
            throw new UnsupportedUserException(sprintf('Invalid user class "%s".', $user::class));
        }

        $freshUser = $this->userRepository->find($user->getId());

        if (!$freshUser) {
            throw new UserNotFoundException();
        }

        return $freshUser;
    }

    public function supportsClass(string $class): bool
    {
        return \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity::class === $class
            || is_subclass_of($class, \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity::class);
    }

    public function loadUserByIdentifier(string $identifier): UserInterface
    {
        $user = $this->userRepository->findOneBy(['email' => $identifier]);

        if (!$user) {
            throw new UserNotFoundException(sprintf('User "%s" not found.', $identifier));
        }

        return $user;
    }

    public function upgradePassword(PasswordAuthenticatedUserInterface $user, string $newHashedPassword): void
    {
        if (!$user instanceof \App\Infrastructure\Persistence\Doctrine\Entity\UserEntity) {
            throw new UnsupportedUserException(sprintf('Invalid user class "%s".', $user::class));
        }

        $user->setPassword($newHashedPassword);
        $this->userRepository->getEntityManager()->persist($user);
        $this->userRepository->getEntityManager()->flush();
    }
}


FICHIER: src/Kernel.php
--------------------------------------------------------------------------------
<?php

namespace App;

use Symfony\Bundle\FrameworkBundle\Kernel\MicroKernelTrait;
use Symfony\Component\HttpKernel\Kernel as BaseKernel;

class Kernel extends BaseKernel
{
    use MicroKernelTrait;
}



FICHIER: src/Shared/Application/Command/CommandBusInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandBusInterface
{
    public function execute(CommandInterface $command): mixed;
}



FICHIER: src/Shared/Application/Command/CommandHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandHandlerInterface
{
}



FICHIER: src/Shared/Application/Command/CommandInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Command;

interface CommandInterface
{
}



FICHIER: src/Shared/Application/Query/QueryBusInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryBusInterface
{
    public function execute(QueryInterface $query): mixed;
}



FICHIER: src/Shared/Application/Query/QueryHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryHandlerInterface
{
}



FICHIER: src/Shared/Application/Query/QueryInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Application\Query;

interface QueryInterface
{
}



FICHIER: src/Shared/Domain/Event/EventHandlerInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Domain\Event;

interface EventHandlerInterface
{
}



FICHIER: src/Shared/Domain/Event/EventInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Domain\Event;

interface EventInterface
{
}



FICHIER: src/Shared/Infrastructure/Bus/CommandBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Command\CommandBusInterface;
use App\Shared\Application\Command\CommandInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class CommandBus implements CommandBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $commandBus)
    {
        $this->messageBus = $commandBus;
    }

    public function execute(CommandInterface $command): mixed
    {
        return $this->handle($command);
    }
}



FICHIER: src/Shared/Infrastructure/Bus/EventBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Event\EventBusInterface;
use App\Shared\Domain\Event\EventInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class EventBus implements EventBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $queryBus)
    {
        $this->messageBus = $queryBus;
    }

    public function execute(EventInterface $event): mixed
    {
        return $this->handle($event);
    }
}



FICHIER: src/Shared/Infrastructure/Bus/QueryBus.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Shared\Infrastructure\Bus;

use App\Shared\Application\Query\QueryBusInterface;
use App\Shared\Application\Query\QueryInterface;
use Symfony\Component\Messenger\HandleTrait;
use Symfony\Component\Messenger\MessageBusInterface;

class QueryBus implements QueryBusInterface
{
    use HandleTrait;

    public function __construct(MessageBusInterface $queryBus)
    {
        $this->messageBus = $queryBus;
    }

    public function execute(QueryInterface $query): mixed
    {
        return $this->handle($query);
    }
}



FICHIER: src/Users/Application/Config/UsersAppConfig.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Config;

class UsersAppConfig
{
    static int $ERREUR_FATAL = 1;
    static int $ERREUR_SYSTEM_INFO = 2;
    static int $ERREUR_USER = 3;
    static int $USER_NEED_RESTART = 10; // temporaire
    static int $USER_BANNED = 20; // dÃ©finitif
    static int $USER_BLOCKED = 30; // temporaire
    static int $USER_UNSUBSCRIBED = 50; // dÃ©finitif


    static int $RANDOM_LIMIT = 10;
    static int $RANDOM_TIME_LIMIT = 5;
    static int $RANDOM_HISTORY_TIME_LIMIT = 604800;
    static string $SLOT_SECRET = "Nu31Xc8em6X76UKGJxqAOTClh6egRT8vAMQYbQdSqVBuToYcFN";
    static int $LINK_SUGGESTED = 1;
    static int $LINK_ACCEPTED = 2;
    static int $LINK_DECLINED = 3;
    static int $LINK_SLOT_WIN = 4;
    static int $NOTIFICATION_STATE_NEW = 0;
    static int $NOTIFICATION_STATE_READ = 1;
    static int $FOLLOW_TYPE_VISIT = 01;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_SUGGEST = 11;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_ACCEPT = 12;
    static int $FOLLOW_TYPE_MANAGE_CONTACT_DECLINE = 13;
    static int $FOLLOW_TYPE_SLOT_WIN = 21;


    static int $NOTIFICATION_TYPE_CONTACT = 1;
    static int $NOTIFICATION_TYPE_SLOT_WIN = 3;
    static int $NOTIFICATION_TYPE_MESSAGE = 10;

    static int $CREDITS_BY_NB_WON = 5;
    static int $FREE_DAY_CREDITS = 50;


    static int $CREDIT_LOG_REASON_DAY_FREE = 1;
    static int $CREDIT_LOG_REASON_SLOT_WIN_CONFIRM = 2;
}


FICHIER: src/Users/Application/DTO/UserDTO.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Users\Application\DTO;

use App\Infrastructure\Persistence\Doctrine\Entity\UserEntity;
use App\Users\Domain\Entity\User;

class UserDTO
{
    public function __construct(
        public readonly ?int $id,
        public readonly string $uid,
        public readonly string $authUid,
        public readonly string $email,
        public readonly string $username = '',
        public readonly string $aboutMe = '',
        public readonly int $gender = 0,
        public readonly \DateTime $birthdate = new \DateTime(),
        public readonly int $status = 0,
    ) {
    }

    public static function fromEntity(UserEntity $user): self
    {
        return new self(
            $user->getId(),
            $user->getUid(),
            $user->getAuthUid(),
            $user->getEmail(),
            $user->getUsername(),
            $user->getAboutMe(),
            $user->getGender(),
            $user->getBirthdate(),
            $user->getStatus(),
        );
    }
    public static function fromArray(array $user): self
    {
        $birthdate = \DateTime::createFromFormat("Y-m-d", $user['birthdate']);

        return new self(
            $user['id'],
            $user['uid'],
            $user['auth_uid'],
            $user['email'],
            $user['username'],
            $user['about_me'],
            $user['gender'],
            $birthdate,
            $user['status'],
        );
    }

    public static function forSignupProcess(string $authUid): self
    {
        return new self(null, '', $authUid, '');
    }
}



FICHIER: src/Users/Application/Query/GetJwtForSignup/GetJwtForSignupQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtForSignup;

use App\Shared\Application\Query\QueryInterface;
use App\Users\Application\DTO\UserDTO;

class GetJwtForSignupQuery implements QueryInterface
{
    public function __construct(
        public readonly UserDTO $userDto
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetJwtForSignup/GetJwtForSignupQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtForSignup;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Shared\Application\Query\QueryHandlerInterface;
use App\Users\Application\DTO\UserDTO;
//use App\Users\Domain\Repository\UserRepositoryInterface;
use Lcobucci\JWT\Encoding\ChainedFormatter;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Signer\Key\InMemory;
use Lcobucci\JWT\Signer\Hmac\Sha512;
use Lcobucci\JWT\Token\Builder;

class GetJwtForSignupQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {
    }

    public function __invoke(GetJwtForSignupQuery $query): string
    {
        $userDto = $query->userDto;

        $authUid = $userDto->authUid;
        $email = $userDto->email;

        $tokenBuilder = (new Builder(new JoseEncoder(), ChainedFormatter::default()));
        $algorithm = new Sha512();
        $signinKey = InMemory::file(__DIR__.'/../../../../../config/jwt/private.pem');

        $now = new \DateTimeImmutable();

        $token = $tokenBuilder
//            ->issuedBy('http://example.com')
//            ->permittedFor('http://example.org')
//            ->relatedTo('component1')
//            ->identifiedBy('4f1g23a12aa')
//            ->issuedAt($now)
//            ->canOnlyBeUsedAfter($now->modify('+1 minute'))
            ->expiresAt($now->modify('+1 hour'))
            ->withClaim('authUid', $authUid)
            ->withClaim('email', $email)
            ->withClaim('username', $email)
            ->getToken($algorithm, $signinKey);

        return $token->toString();
    }
}



FICHIER: src/Users/Application/Query/GetJwtFromUser/GetJwtFromUserQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtFromUser;

use App\Shared\Application\Query\QueryInterface;
use App\Users\Application\DTO\UserDTO;

class GetJwtFromUserQuery implements QueryInterface
{
    public function __construct(
        public readonly UserDTO $user
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetJwtFromUser/GetJwtFromUserQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetJwtFromUser;

use App\Shared\Application\Query\QueryHandlerInterface;
use Lexik\Bundle\JWTAuthenticationBundle\Encoder\JWTEncoderInterface;

class GetJwtFromUserQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly JWTEncoderInterface $encoder
    ) {
    }

    public function __invoke(GetJwtFromUserQuery $query): string
    {
        return $this->encoder->encode(
            [
                'roles' => [
                    'ROLE_USER',
                ],
                'email' => $query->user->email,
                'username' => $query->user->email,
                'uid' => $query->user->authUid,
            ]
        );
    }
}



FICHIER: src/Users/Application/Query/GetUserByFirebaseToken/GetUserByFirebaseTokenQuery.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetUserByFirebaseToken;

use App\Shared\Application\Query\QueryInterface;

class GetUserByFirebaseTokenQuery implements QueryInterface
{
    public function __construct(
        public readonly string $token,
    ) {
    }
}


FICHIER: src/Users/Application/Query/GetUserByFirebaseToken/GetUserByFirebaseTokenQueryHandler.php
--------------------------------------------------------------------------------
<?php

namespace App\Users\Application\Query\GetUserByFirebaseToken;

use App\Infrastructure\Persistence\Doctrine\Repository\UserRepository;
use App\Shared\Application\Query\QueryHandlerInterface;
use App\Users\Application\DTO\UserDTO;
use Lcobucci\JWT\Encoding\JoseEncoder;
use Lcobucci\JWT\Signer;
use Lcobucci\JWT\Signer\Rsa\Sha256;
use Lcobucci\JWT\Token\Parser;
use Lcobucci\JWT\Token\Plain;
use Lcobucci\JWT\Validation\Constraint\SignedWith;
use Lcobucci\JWT\Validation\Validator;

class GetUserByFirebaseTokenQueryHandler implements QueryHandlerInterface
{
    public function __construct(
        private readonly UserRepository $userRepository
    ) {
    }

    public function __invoke(GetUserByFirebaseTokenQuery $query): UserDTO
    {
        $firebaseToken = $query->token;

        $parser = new Parser(new JoseEncoder());

        /** @var Plain $token */
        $token = $parser->parse($firebaseToken);

        $kid = $token->headers()->get('kid');

        $googleJson = file_get_contents('https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com');

        $jsonParsed = json_decode($googleJson, true);

        $privateKey = $jsonParsed[$kid];

        $signer = new Sha256();

        $validator = new Validator();

        $validator->assert($token, new SignedWith($signer, Signer\Key\InMemory::plainText($privateKey)));

        $firebaseAuthId = $token->claims()->get('user_id');

        $user = $this->userRepository->getUserByAuthUid($firebaseAuthId);

        if (null == $user) {
            return UserDTO::forSignupProcess($firebaseAuthId);
        }

        return UserDTO::fromEntity($user);
    }
}



FICHIER: src/Users/Domain/Repository/UserRepositoryInterface.php
--------------------------------------------------------------------------------
<?php

declare(strict_types=1);

namespace App\Users\Domain\Repository;

use App\Users\Domain\Entity\User;

interface UserRepositoryInterface
{
    public function add(User $user): void;
    public function update(User $user): void;
    public function findByAuthUid(string $authUid): ?User;
    public function findByUid(string $uid): ?User;
    public function findDetailedByUid(string $uid, float $myLatitude, float $myLongitude): array;
    public function findByEmail(string $email): ?User;
    public function getUserByAuthUid(string $firebaseAuthId): ?User;
    public function getFilteredList(bool $totally, int $myIdUser, int $skip, int $genderWanted, int $minAge, int $maxAge, int $maxDistance, bool $onlyWithPhoto, bool $onlyInFavorites, float $myLatitude, float $myLongitude): array;
    public function getRandomList(int $myIdUser, array $excludedUsers, int $genderWanted, int $minAge, int $maxAge, int $maxDistance, bool $onlyWithPhoto, bool $onlyInFavorites, float $myLatitude, float $myLongitude, int $nbMax = -1, bool $excludeFake = false): array;
    public function getAllPhotosByUsers(array $listIdUsers): array;
    public function findManyByUids(array $contactsUids);
    public function getContactsFilteredList(int $idUser): array;
    public function findByUsername(string $username): ?User;

    public function getListFromIds(int $myIdUser, array $usersIds, float $myLatitude, float $myLongitude): array;

}



FIN
============
Total fichiers: 97